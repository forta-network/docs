{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Overview Forta API (beta) (February 2022) We recently launched API access to alerts. For more details, please check out the API docs . Welcome to the Forta Developer SDK documentation! Forta is the first decentralized, community-based runtime security network for smart contracts. Protocol teams, investors and individuals can use Forta to monitor public blockchain transaction activity and receive alerts on security, financial, operational and governance related threats for their own or dependent protocols. The two primary components of Forta are threat detection agents and scan nodes: Agents are scripts that look for suspicious transaction characteristics or state changes (e.g. anomaly detection) on smart contracts across any Layer 1, Layer 2, or sidechain. Scan nodes are responsible for running agents. When agents detect a specific condition or event, an alert is triggered from the network. Forta will maintain a public registry of all alerts, and anyone interested in the security of a contract can consume relevant alerts via the Forta Explorer or API . Anyone can become an agent developer and submit agents to be certified by the network. Agents can currently be written using the Javascript SDK or Python SDK and can be submitted for community feedback here . Get started by building your first agent . Join our community Discord for help and to chat with other developers and our team! Forta is currently in the public testnet phase Javascript SDK version: 0.0.41 Python SDK version: 0.0.15 Last updated: March 24th, 2022","title":"Overview"},{"location":"#overview","text":"Forta API (beta) (February 2022) We recently launched API access to alerts. For more details, please check out the API docs . Welcome to the Forta Developer SDK documentation! Forta is the first decentralized, community-based runtime security network for smart contracts. Protocol teams, investors and individuals can use Forta to monitor public blockchain transaction activity and receive alerts on security, financial, operational and governance related threats for their own or dependent protocols. The two primary components of Forta are threat detection agents and scan nodes: Agents are scripts that look for suspicious transaction characteristics or state changes (e.g. anomaly detection) on smart contracts across any Layer 1, Layer 2, or sidechain. Scan nodes are responsible for running agents. When agents detect a specific condition or event, an alert is triggered from the network. Forta will maintain a public registry of all alerts, and anyone interested in the security of a contract can consume relevant alerts via the Forta Explorer or API . Anyone can become an agent developer and submit agents to be certified by the network. Agents can currently be written using the Javascript SDK or Python SDK and can be submitted for community feedback here . Get started by building your first agent . Join our community Discord for help and to chat with other developers and our team! Forta is currently in the public testnet phase Javascript SDK version: 0.0.41 Python SDK version: 0.0.15 Last updated: March 24th, 2022","title":"Overview"},{"location":"advanced-testing/","text":"Advanced testing There may be cases where developers want to test their agent with more complex interactions using real data, or to test scenarios that have not yet occurred on-chain. One way to do this is to fork the state of the chain locally and point your agent to it. You can then simulate transactions on the forked chain and the agent will scan the resulting blocks and transactions. This page describes how to conduct more advanced testing using a locally forked chain. The complete code for this example can be found here . Run a forked chain We make use of the Ganache forking feature, specifically using the underlying ganache-core library. In the example project, there is a convenient script for you to run in package.json: npm run ganache . This will run the following code (make sure to replace the RPC_URL with a valid endpoint): const RPC_URL = \"https://mainnet.infura.io/v3/YOUR_API_KEY\"; const PORT = 7545; async function runGanacheFork() { // get the latest block number const provider = new ethers.providers.JsonRpcProvider(RPC_URL); const blockNumber = await provider.getBlockNumber(); // fork the chain from the block number and unlock an account to simulate transactions from const server = ganache.server({ fork: RPC_URL, fork_block_number: blockNumber, unlocked_accounts: [USER], }); // start a rpc server server.listen(PORT, () => { console.log(`json-rpc listening on port ${PORT}`); }); } This function will fetch the latest block number and create a Ganache fork at that point in the chain. You can also specify any accounts you want to unlock in order to simulate transactions from them. The last line starts a JSON-RPC server running locally on port 7545. Point the agent to the forked chain Once we have the forked Ganache chain running, we want to point our agent to it. This is easily done by setting the jsonRpcUrl in forta.config.json: { \"jsonRpcUrl\": \"http://127.0.0.1:7545\" } In the example project, we provide a local forta.config.json to point this specific agent to the forked chain (make sure that jsonRpcUrl is uncommented). You could also set jsonRpcUrl in your global forta.config.json (located at ~/.forta) if you want to point all of your local agents to the forked chain. Now you can run the agent in a separate terminal using npm start . This will start listening for blocks from the forked Ganache chain. Awesome! Simulate transactions Now we can simulate a number of transactions on the forked chain and see whether the agent returns any findings. In a separate terminal, run the script provided in package.json: npm run simulation . This will run the following code: async function runSimulatedTransactions() { // get an ethers provider that points to the ganache fork const provider = getEthersProvider(); const tether = new ethers.Contract( TETHER_ADDRESS, TETHER_ABI, provider.getSigner(USER) ); // simulate a tether transfer for 100 TETH const tx1 = await tether.transfer(USER2, 100 * 10 ** TETHER_DECIMALS); const receipt1 = await tx1.wait(); // simulate a tether transfer for 10 TETH const tx2 = await tether.transfer(USER2, 10 * 10 ** TETHER_DECIMALS); const receipt2 = await tx2.wait(); } Here we simulate 2 transfers of Tether tokens from the unlocked account. After these transactions are mined by Ganache, you should see the agent scan the blocks shortly after (may take a few seconds). The agent should alert about one of these transactions. Sweet! Note that Ganache behaviour is to mine a new block for each transaction. Automating the above While it's cool to be able to manually run the above scripts, it would be amazing to have it all automated. This is exactly what we have done in the provided agent.spec.js file. In it you will find a Jest test suite that will fork a Ganache chain, run simulated transactions and verify that the agent outputs the correct findings. Other considerations A known limitation of Ganache is the lack of tracing data. If your agent relies on trace data (either using txEvent.traces directly, or indirectly using txEvent.filterFunction ), then this simulation will not generate the correct findings.","title":"Advanced testing"},{"location":"advanced-testing/#advanced-testing","text":"There may be cases where developers want to test their agent with more complex interactions using real data, or to test scenarios that have not yet occurred on-chain. One way to do this is to fork the state of the chain locally and point your agent to it. You can then simulate transactions on the forked chain and the agent will scan the resulting blocks and transactions. This page describes how to conduct more advanced testing using a locally forked chain. The complete code for this example can be found here .","title":"Advanced testing"},{"location":"advanced-testing/#run-a-forked-chain","text":"We make use of the Ganache forking feature, specifically using the underlying ganache-core library. In the example project, there is a convenient script for you to run in package.json: npm run ganache . This will run the following code (make sure to replace the RPC_URL with a valid endpoint): const RPC_URL = \"https://mainnet.infura.io/v3/YOUR_API_KEY\"; const PORT = 7545; async function runGanacheFork() { // get the latest block number const provider = new ethers.providers.JsonRpcProvider(RPC_URL); const blockNumber = await provider.getBlockNumber(); // fork the chain from the block number and unlock an account to simulate transactions from const server = ganache.server({ fork: RPC_URL, fork_block_number: blockNumber, unlocked_accounts: [USER], }); // start a rpc server server.listen(PORT, () => { console.log(`json-rpc listening on port ${PORT}`); }); } This function will fetch the latest block number and create a Ganache fork at that point in the chain. You can also specify any accounts you want to unlock in order to simulate transactions from them. The last line starts a JSON-RPC server running locally on port 7545.","title":"Run a forked chain"},{"location":"advanced-testing/#point-the-agent-to-the-forked-chain","text":"Once we have the forked Ganache chain running, we want to point our agent to it. This is easily done by setting the jsonRpcUrl in forta.config.json: { \"jsonRpcUrl\": \"http://127.0.0.1:7545\" } In the example project, we provide a local forta.config.json to point this specific agent to the forked chain (make sure that jsonRpcUrl is uncommented). You could also set jsonRpcUrl in your global forta.config.json (located at ~/.forta) if you want to point all of your local agents to the forked chain. Now you can run the agent in a separate terminal using npm start . This will start listening for blocks from the forked Ganache chain. Awesome!","title":"Point the agent to the forked chain"},{"location":"advanced-testing/#simulate-transactions","text":"Now we can simulate a number of transactions on the forked chain and see whether the agent returns any findings. In a separate terminal, run the script provided in package.json: npm run simulation . This will run the following code: async function runSimulatedTransactions() { // get an ethers provider that points to the ganache fork const provider = getEthersProvider(); const tether = new ethers.Contract( TETHER_ADDRESS, TETHER_ABI, provider.getSigner(USER) ); // simulate a tether transfer for 100 TETH const tx1 = await tether.transfer(USER2, 100 * 10 ** TETHER_DECIMALS); const receipt1 = await tx1.wait(); // simulate a tether transfer for 10 TETH const tx2 = await tether.transfer(USER2, 10 * 10 ** TETHER_DECIMALS); const receipt2 = await tx2.wait(); } Here we simulate 2 transfers of Tether tokens from the unlocked account. After these transactions are mined by Ganache, you should see the agent scan the blocks shortly after (may take a few seconds). The agent should alert about one of these transactions. Sweet! Note that Ganache behaviour is to mine a new block for each transaction.","title":"Simulate transactions"},{"location":"advanced-testing/#automating-the-above","text":"While it's cool to be able to manually run the above scripts, it would be amazing to have it all automated. This is exactly what we have done in the provided agent.spec.js file. In it you will find a Jest test suite that will fork a Ganache chain, run simulated transactions and verify that the agent outputs the correct findings.","title":"Automating the above"},{"location":"advanced-testing/#other-considerations","text":"A known limitation of Ganache is the lack of tracing data. If your agent relies on trace data (either using txEvent.traces directly, or indirectly using txEvent.filterFunction ), then this simulation will not generate the correct findings.","title":"Other considerations"},{"location":"api-example-use-cases/","text":"Example Use Cases The Forta API will allow protocols, DAOs, investors, and the community to integrate alerts in dApps and tools. There are many use cases for this, but here are three examples to give you a better idea how this API can be used. You can also learn about these three examples and one Forta community member's API integration in the following youtube videos: Integrating with Forta: Learn more about the Forta API How the Convo Space is using the Forta API 1. Strengthen Protocol Security As a protocol developer... Let\u2019s say you developed an agent that monitors critical events on the protocol, but the agent has been emitting a lot of noisy alerts. To reduce noisy alerts, you can: Query the API for past alerts Analyze your agent\u2019s alerting rate Tweak alerting threshold or logic Or you can also develop more complex mitigation scripts that: Query the API for specific agents\u2019 alerts Automate smart contract operations based on the received alerts 2. Reduce Phishing Attacks As a dApp developer , you can: Notify users of potential threats and governance changes in the dApp. Build out an extension to wallets like Metamask to display warnings about a particular wallet address or smart contracts users are about to interact with. Build a smart contract safety checker tool. This is all possible by querying the API for alerts across agents that are associated with specific wallets and/or smart contracts at different points in time. 3. Make Informed Financial Decisions As a financial analyst , you may want to analyze several blockchain projects\u2019 alerts and identify trends before making any investment decisions. As an insurance protocol , you can decide whether to provide coverage or process claims for a particular smart contract by analyzing its alerts to gauge its security.","title":"Example Use Cases"},{"location":"api-example-use-cases/#example-use-cases","text":"The Forta API will allow protocols, DAOs, investors, and the community to integrate alerts in dApps and tools. There are many use cases for this, but here are three examples to give you a better idea how this API can be used. You can also learn about these three examples and one Forta community member's API integration in the following youtube videos: Integrating with Forta: Learn more about the Forta API How the Convo Space is using the Forta API","title":"Example Use Cases"},{"location":"api-example-use-cases/#1-strengthen-protocol-security","text":"As a protocol developer... Let\u2019s say you developed an agent that monitors critical events on the protocol, but the agent has been emitting a lot of noisy alerts. To reduce noisy alerts, you can: Query the API for past alerts Analyze your agent\u2019s alerting rate Tweak alerting threshold or logic Or you can also develop more complex mitigation scripts that: Query the API for specific agents\u2019 alerts Automate smart contract operations based on the received alerts","title":"1. Strengthen Protocol Security"},{"location":"api-example-use-cases/#2-reduce-phishing-attacks","text":"As a dApp developer , you can: Notify users of potential threats and governance changes in the dApp. Build out an extension to wallets like Metamask to display warnings about a particular wallet address or smart contracts users are about to interact with. Build a smart contract safety checker tool. This is all possible by querying the API for alerts across agents that are associated with specific wallets and/or smart contracts at different points in time.","title":"2. Reduce Phishing Attacks"},{"location":"api-example-use-cases/#3-make-informed-financial-decisions","text":"As a financial analyst , you may want to analyze several blockchain projects\u2019 alerts and identify trends before making any investment decisions. As an insurance protocol , you can decide whether to provide coverage or process claims for a particular smart contract by analyzing its alerts to gauge its security.","title":"3. Make Informed Financial Decisions"},{"location":"api-examples/","text":"Example Queries We provided some example queries for you to try in the API Sandbox : Recent alerts emitted by a specific agent Today's alerts associated with certain addressees Past alerts by block number or date range A list of blockchain projects Details of a blockchain project You can find all examples at forta-protocol.github.io/forta-api . Recent alerts emitted by a specific agent You can also view this example query on github . Today's alerts associated with certain addressees You can also view this example query on github . Past alerts by block number or date range You can also view this example query on github . A list of blockchain projects You can also view this example query on github . Details of a blockchain project You can also view this example query on github .","title":"Example Queries"},{"location":"api-examples/#example-queries","text":"We provided some example queries for you to try in the API Sandbox : Recent alerts emitted by a specific agent Today's alerts associated with certain addressees Past alerts by block number or date range A list of blockchain projects Details of a blockchain project You can find all examples at forta-protocol.github.io/forta-api .","title":"Example Queries"},{"location":"api-examples/#recent-alerts-emitted-by-a-specific-agent","text":"You can also view this example query on github .","title":"Recent alerts emitted by a specific agent"},{"location":"api-examples/#todays-alerts-associated-with-certain-addressees","text":"You can also view this example query on github .","title":"Today's alerts associated with certain addressees"},{"location":"api-examples/#past-alerts-by-block-number-or-date-range","text":"You can also view this example query on github .","title":"Past alerts by block number or date range"},{"location":"api-examples/#a-list-of-blockchain-projects","text":"You can also view this example query on github .","title":"A list of blockchain projects"},{"location":"api-examples/#details-of-a-blockchain-project","text":"You can also view this example query on github .","title":"Details of a blockchain project"},{"location":"api/","text":"API Access Beta Mode (February 2022) The API is in beta mode. If you see any bugs or issues, please let us know at github:forta-protocol/forta-api . Forta currently supports free GraphQL API access to alerts and blockchain projects data. How can I access the API? API Keys API keys are not required at this time. The API endpoint is https://api.forta.network/graphql . If you'd like an interactive interface for building and testing a query, please check out the API Sandbox . How can I contribute? If you'd like to report a bug, request a feature, or ask any questions about the API, please check out the forta-api github repository . We will be tracking all feature requests, bug reports, and feedback there.","title":"API Access"},{"location":"api/#api-access","text":"Beta Mode (February 2022) The API is in beta mode. If you see any bugs or issues, please let us know at github:forta-protocol/forta-api . Forta currently supports free GraphQL API access to alerts and blockchain projects data.","title":"API Access"},{"location":"api/#how-can-i-access-the-api","text":"API Keys API keys are not required at this time. The API endpoint is https://api.forta.network/graphql . If you'd like an interactive interface for building and testing a query, please check out the API Sandbox .","title":"How can I access the API?"},{"location":"api/#how-can-i-contribute","text":"If you'd like to report a bug, request a feature, or ask any questions about the API, please check out the forta-api github repository . We will be tracking all feature requests, bug reports, and feedback there.","title":"How can I contribute?"},{"location":"best-practices/","text":"Best practices This page describes some of the best practices observed for agent development. Target specific conditions Write your agent to target a specific condition so that it does not generate findings for every other block/transaction. Verbose agents can make it hard to distinguish the signal from the noise i.e. if an agent alerts on more than 5% of transactions, the usefulness of those alerts would not be very high as it is difficult to know what to pay attention to. Return findings in a timely manner Ensure that your agent returns findings in a timely manner as requests will timeout after 30 seconds. If your agent needs to execute for longer than 30 seconds, check out the pattern for long running tasks . Break down large agents into smaller files Your agent may be looking for multiple conditions that you could write in a single file. We recommend keeping each condition in its own file. This will make testing your agent easier and keep the code more maintainable. You would then combine all the agents in the top-level entrypoint file (i.e. agent.js). See here for an example. Keep findings lean There is a metadata field in the Finding object that you can use to store any extra information that is useful. Try to keep the data here as lean as possible i.e. don't throw the whole TransactionEvent into the metadata since that information is already available on Etherscan. Create useful alertIds You are required to populate the alertId field of the Finding object. Ideally, you would want it to be unique so that when you search for your alertId in Forta Explorer it only shows your agent's alerts. Typically, an alertId has a string component (describing either the protocol or project) and a numeric component (to distinguish between different types of alerts about the same protocol or project) e.g. TETHER-1 . It is left to the agent developer to choose what makes sense for their agent. Write unit tests You should write and maintain unit tests for your agent. This will ensure a high quality bar and also allow you to test all edge cases in your agent. Include both negative (i.e. when alerts should not be created) and positive (i.e. when alerts should be created) test cases for completeness. When writing tests that involve log events, you can mock out the filterLog SDK method instead of having to fiddle around with event topics and signatures. See here for an example. You can similarly mock out the filterFunction SDK method when writing tests that involve function calls. See here for an example. Conduct code reviews It is strongly recommended to conduct code reviews within your team. This will help ensure that any bugs are identified and all edge cases are covered by your agent. Include documentation Ensure that your project documentation README.md is complete, clear and concise. Briefly describe what your agent does, as well as each type of alert it can produce under which conditions. You should also include real test data that someone could use to verify the agent's behaviour. See the example README.md included with the starter projects for an example. Use the initialize handler Your agent may need to do some asynchronous initialization when it starts, for example, by fetching data from some external API. You should use the initialize handler function for such logic. Limit number of network calls Your agent may need to make network calls to fetch data from external sources e.g. token prices. Be sure to make only the necessary network calls in order to respond in a timely manner. Another useful strategy for this could be to use caching. Also, if querying lots of on-chain data (e.g. token balances for a list of accounts), consider using the ethers-multicall package listed in the Useful libraries section to fetch all the data in a single http request. Use caching where possible Caching is a great way to improve performance. If you need to store the result of a network call or some other calculation, try to use an in-memory cache. The lru-cache package listed in the Useful libraries section is a great option. Use concurrency where possible Try to make use of concurrency to maximize performance. For example, if you are firing multiple http requests to fetch on-chain data, you can use the ethers-multicall package to fetch all the data in a single http request. Also, if firing multiple network calls, you can fire all the requests at the same time using something like Promise.all in Javascript. Obfuscate sensitive information Be sure to obfuscate sensitive information, such as API keys, in your code. Agent images are stored in a public repository where anyone can access and inspect the code. See the pattern for hiding sensitive data . Beware of case-sensitivity When comparing addresses in your code, be mindful of case-sensitivity. The SDK will return addresses in the BlockEvent and TransactionEvent as lowercase, but if you are comparing to a checksum address it will not be equal.","title":"Best practices"},{"location":"best-practices/#best-practices","text":"This page describes some of the best practices observed for agent development.","title":"Best practices"},{"location":"best-practices/#target-specific-conditions","text":"Write your agent to target a specific condition so that it does not generate findings for every other block/transaction. Verbose agents can make it hard to distinguish the signal from the noise i.e. if an agent alerts on more than 5% of transactions, the usefulness of those alerts would not be very high as it is difficult to know what to pay attention to.","title":"Target specific conditions"},{"location":"best-practices/#return-findings-in-a-timely-manner","text":"Ensure that your agent returns findings in a timely manner as requests will timeout after 30 seconds. If your agent needs to execute for longer than 30 seconds, check out the pattern for long running tasks .","title":"Return findings in a timely manner"},{"location":"best-practices/#break-down-large-agents-into-smaller-files","text":"Your agent may be looking for multiple conditions that you could write in a single file. We recommend keeping each condition in its own file. This will make testing your agent easier and keep the code more maintainable. You would then combine all the agents in the top-level entrypoint file (i.e. agent.js). See here for an example.","title":"Break down large agents into smaller files"},{"location":"best-practices/#keep-findings-lean","text":"There is a metadata field in the Finding object that you can use to store any extra information that is useful. Try to keep the data here as lean as possible i.e. don't throw the whole TransactionEvent into the metadata since that information is already available on Etherscan.","title":"Keep findings lean"},{"location":"best-practices/#create-useful-alertids","text":"You are required to populate the alertId field of the Finding object. Ideally, you would want it to be unique so that when you search for your alertId in Forta Explorer it only shows your agent's alerts. Typically, an alertId has a string component (describing either the protocol or project) and a numeric component (to distinguish between different types of alerts about the same protocol or project) e.g. TETHER-1 . It is left to the agent developer to choose what makes sense for their agent.","title":"Create useful alertIds"},{"location":"best-practices/#write-unit-tests","text":"You should write and maintain unit tests for your agent. This will ensure a high quality bar and also allow you to test all edge cases in your agent. Include both negative (i.e. when alerts should not be created) and positive (i.e. when alerts should be created) test cases for completeness. When writing tests that involve log events, you can mock out the filterLog SDK method instead of having to fiddle around with event topics and signatures. See here for an example. You can similarly mock out the filterFunction SDK method when writing tests that involve function calls. See here for an example.","title":"Write unit tests"},{"location":"best-practices/#conduct-code-reviews","text":"It is strongly recommended to conduct code reviews within your team. This will help ensure that any bugs are identified and all edge cases are covered by your agent.","title":"Conduct code reviews"},{"location":"best-practices/#include-documentation","text":"Ensure that your project documentation README.md is complete, clear and concise. Briefly describe what your agent does, as well as each type of alert it can produce under which conditions. You should also include real test data that someone could use to verify the agent's behaviour. See the example README.md included with the starter projects for an example.","title":"Include documentation"},{"location":"best-practices/#use-the-initialize-handler","text":"Your agent may need to do some asynchronous initialization when it starts, for example, by fetching data from some external API. You should use the initialize handler function for such logic.","title":"Use the initialize handler"},{"location":"best-practices/#limit-number-of-network-calls","text":"Your agent may need to make network calls to fetch data from external sources e.g. token prices. Be sure to make only the necessary network calls in order to respond in a timely manner. Another useful strategy for this could be to use caching. Also, if querying lots of on-chain data (e.g. token balances for a list of accounts), consider using the ethers-multicall package listed in the Useful libraries section to fetch all the data in a single http request.","title":"Limit number of network calls"},{"location":"best-practices/#use-caching-where-possible","text":"Caching is a great way to improve performance. If you need to store the result of a network call or some other calculation, try to use an in-memory cache. The lru-cache package listed in the Useful libraries section is a great option.","title":"Use caching where possible"},{"location":"best-practices/#use-concurrency-where-possible","text":"Try to make use of concurrency to maximize performance. For example, if you are firing multiple http requests to fetch on-chain data, you can use the ethers-multicall package to fetch all the data in a single http request. Also, if firing multiple network calls, you can fire all the requests at the same time using something like Promise.all in Javascript.","title":"Use concurrency where possible"},{"location":"best-practices/#obfuscate-sensitive-information","text":"Be sure to obfuscate sensitive information, such as API keys, in your code. Agent images are stored in a public repository where anyone can access and inspect the code. See the pattern for hiding sensitive data .","title":"Obfuscate sensitive information"},{"location":"best-practices/#beware-of-case-sensitivity","text":"When comparing addresses in your code, be mindful of case-sensitivity. The SDK will return addresses in the BlockEvent and TransactionEvent as lowercase, but if you are comparing to a checksum address it will not be equal.","title":"Beware of case-sensitivity"},{"location":"cli/","text":"CLI Commands The following sections describe the CLI commands available to agent developers. You can always use forta-agent help to get a quick overview of these commands, as well as details about specific commands e.g. forta-agent run help . Invoke commands programmatically You can invoke the available CLI commands programmatically in NodeJS using the exported configureContainer method. This method returns a dependency injection container that can be used to access different commands. It accepts an optional object of arguments that will configure its behaviour, the most important of which is contextPath which points to the agent directory that you are running commands for (defaults to current working directory if not specified). For example, if you wanted to invoke the init command it would look like the following: const { configureContainer } = require(\"forta-agent\"); const pathToAgentDirectory = \"/Desktop/my-agent\"; const container = configureContainer({ contextPath: pathToAgentDirectory }); const init = container.resolve(\"init\"); await init(); The above code snippet will initialize a Forta Agent project at the specified contextPath (creating the folder if it does not exist). All the CLI commands are asynchronous so you will need to await them. Similarly, you can resolve other commands that are listed below. Exposing the CLI functionality enables developers to integrate with other tools. The first example of such an integration is the Forta Hardhat plugin . We look forward to seeing the new and creative ways developers will integrate this functionality into their own toolset! init Using the npx forta-agent@latest init command, you can quickly initialize a Forta Agent Javascript project inside of the current working directory. The starter project includes some default configuration files as well as an example agent implementation. A keyfile and forta.config.json file will also be generated for you and placed in the ~/.forta folder if they do not already exist. You will be prompted to enter a password that will be used to encrypt the keyfile. This keyfile will be used later when publishing your agent. Options: --typescript - initialize Typescript project --python - initialize Python project Example: Initialize a Typescript Project $ npx forta-agent@latest init --typescript run Easily verify the behaviour of your agent during local development using the forta-agent run command. The default behaviour (i.e. without any options) is to subscribe to a JSON-RPC endpoint and listen for the latest blocks and transactions. A stream of the latest data will be passed to your agent with any findings printed to your output console. The endpoint is specified by the jsonRpcUrl property in the forta.config.json file. Options: --tx - run your agent with a specific transaction hash --block - run your agent against a specific block number/hash, including the transactions in the block --range - run your agent against a specific range of block numbers --file - run your agent against a JSON file of test data --prod - used for running the agent inside of a production environment i.e. you probably won\u2019t need this during development --config - specify a config file to use (default: forta.config.json) --nocache - disables writing block/tx data to local disk cache (but reads are still enabled) Example: Run for a specific transaction $ forta-agent run --tx 0xf9c43e15ef2abfec163ec3b1165f18a5119ba119b6e059fc924903e5251e3543 or if using locally installed package $ npm run tx 0xf9c43e15ef2abfec163ec3b1165f18a5119ba119b6e059fc924903e5251e3543 Example: Run for a specific block (by number) $ forta-agent run --block 12821978 or if using locally installed package $ npm run block 12821978 Example: Run for a specific block (by hash) $ forta-agent run --block 0x9e052eb02a3849b650e8b9e0a47b1fae194b928c930168ef19e311dbd7886172 or if using locally installed package $ npm run block 0x9e052eb02a3849b650e8b9e0a47b1fae194b928c930168ef19e311dbd7886172 Example: Run for a specific block range $ forta-agent run --range 12821978..12821980 or if using locally installed package $ npm run range 12821978..12821980 Example: Run for an input file $ forta-agent run --file ./test.data.json or if using locally installed package $ npm run file ./test.data.json publish Deploy your agent to the Forta protocol using the forta-agent publish command. This will build a Docker image for your agent and publish it to the image repository. Also, it will create an agent manifest which includes the Docker image reference, sign the manifest using your keyfile (you will be prompted for password), store it on IPFS and publish the IPFS reference to the Agent Registry contract. Options: --config - specify a config file to use (default: forta.config.json) push Push your agent image to a repository where scan nodes can find it. This will build and push your Docker agent image (but will not add it to the agent registry). Intended to be used as part of the Forta App agent deployment flow. Options: --config - specify a config file to use (default: forta.config.json) disable Disable your deployed agent and stop it from running on the Forta protocol by using forta-agent disable . Your Docker image will still be publicly available, but scan nodes will know not to run your agent. enable Enable your agent and start execution on the Forta protocol by using forta-agent enable . By default, your agent is enabled when you deploy to the Forta protocol. Only use this command if your agent is currently disabled. keyfile You can print out information about your keyfile, including its absolute path and address, using the forta-agent keyfile command.","title":"CLI commands"},{"location":"cli/#cli-commands","text":"The following sections describe the CLI commands available to agent developers. You can always use forta-agent help to get a quick overview of these commands, as well as details about specific commands e.g. forta-agent run help .","title":"CLI Commands"},{"location":"cli/#invoke-commands-programmatically","text":"You can invoke the available CLI commands programmatically in NodeJS using the exported configureContainer method. This method returns a dependency injection container that can be used to access different commands. It accepts an optional object of arguments that will configure its behaviour, the most important of which is contextPath which points to the agent directory that you are running commands for (defaults to current working directory if not specified). For example, if you wanted to invoke the init command it would look like the following: const { configureContainer } = require(\"forta-agent\"); const pathToAgentDirectory = \"/Desktop/my-agent\"; const container = configureContainer({ contextPath: pathToAgentDirectory }); const init = container.resolve(\"init\"); await init(); The above code snippet will initialize a Forta Agent project at the specified contextPath (creating the folder if it does not exist). All the CLI commands are asynchronous so you will need to await them. Similarly, you can resolve other commands that are listed below. Exposing the CLI functionality enables developers to integrate with other tools. The first example of such an integration is the Forta Hardhat plugin . We look forward to seeing the new and creative ways developers will integrate this functionality into their own toolset!","title":"Invoke commands programmatically"},{"location":"cli/#init","text":"Using the npx forta-agent@latest init command, you can quickly initialize a Forta Agent Javascript project inside of the current working directory. The starter project includes some default configuration files as well as an example agent implementation. A keyfile and forta.config.json file will also be generated for you and placed in the ~/.forta folder if they do not already exist. You will be prompted to enter a password that will be used to encrypt the keyfile. This keyfile will be used later when publishing your agent. Options: --typescript - initialize Typescript project --python - initialize Python project Example: Initialize a Typescript Project $ npx forta-agent@latest init --typescript","title":"init"},{"location":"cli/#run","text":"Easily verify the behaviour of your agent during local development using the forta-agent run command. The default behaviour (i.e. without any options) is to subscribe to a JSON-RPC endpoint and listen for the latest blocks and transactions. A stream of the latest data will be passed to your agent with any findings printed to your output console. The endpoint is specified by the jsonRpcUrl property in the forta.config.json file. Options: --tx - run your agent with a specific transaction hash --block - run your agent against a specific block number/hash, including the transactions in the block --range - run your agent against a specific range of block numbers --file - run your agent against a JSON file of test data --prod - used for running the agent inside of a production environment i.e. you probably won\u2019t need this during development --config - specify a config file to use (default: forta.config.json) --nocache - disables writing block/tx data to local disk cache (but reads are still enabled) Example: Run for a specific transaction $ forta-agent run --tx 0xf9c43e15ef2abfec163ec3b1165f18a5119ba119b6e059fc924903e5251e3543 or if using locally installed package $ npm run tx 0xf9c43e15ef2abfec163ec3b1165f18a5119ba119b6e059fc924903e5251e3543 Example: Run for a specific block (by number) $ forta-agent run --block 12821978 or if using locally installed package $ npm run block 12821978 Example: Run for a specific block (by hash) $ forta-agent run --block 0x9e052eb02a3849b650e8b9e0a47b1fae194b928c930168ef19e311dbd7886172 or if using locally installed package $ npm run block 0x9e052eb02a3849b650e8b9e0a47b1fae194b928c930168ef19e311dbd7886172 Example: Run for a specific block range $ forta-agent run --range 12821978..12821980 or if using locally installed package $ npm run range 12821978..12821980 Example: Run for an input file $ forta-agent run --file ./test.data.json or if using locally installed package $ npm run file ./test.data.json","title":"run"},{"location":"cli/#publish","text":"Deploy your agent to the Forta protocol using the forta-agent publish command. This will build a Docker image for your agent and publish it to the image repository. Also, it will create an agent manifest which includes the Docker image reference, sign the manifest using your keyfile (you will be prompted for password), store it on IPFS and publish the IPFS reference to the Agent Registry contract. Options: --config - specify a config file to use (default: forta.config.json)","title":"publish"},{"location":"cli/#push","text":"Push your agent image to a repository where scan nodes can find it. This will build and push your Docker agent image (but will not add it to the agent registry). Intended to be used as part of the Forta App agent deployment flow. Options: --config - specify a config file to use (default: forta.config.json)","title":"push"},{"location":"cli/#disable","text":"Disable your deployed agent and stop it from running on the Forta protocol by using forta-agent disable . Your Docker image will still be publicly available, but scan nodes will know not to run your agent.","title":"disable"},{"location":"cli/#enable","text":"Enable your agent and start execution on the Forta protocol by using forta-agent enable . By default, your agent is enabled when you deploy to the Forta protocol. Only use this command if your agent is currently disabled.","title":"enable"},{"location":"cli/#keyfile","text":"You can print out information about your keyfile, including its absolute path and address, using the forta-agent keyfile command.","title":"keyfile"},{"location":"concepts/","text":"Core Concepts Forta Protocol The Forta Protocol refers to the distributed and decentralized nodes collaborating to provide threat detection and prevention for smart contract transactions on supported blockchains, coordinated through a set of smart contracts deployed across multiple blockchains. One specific type of node is the scan node. The collection of all nodes and smart contracts is referred to as the Forta Protocol. Scan Nodes A scan node is a specific type of Forta node that executes agents for every transaction and every new block on a specific blockchain network (may also be mempool or simulated network). The scan node manages and coordinates agents (e.g. by instantiating and running agents, and restarting agents that become unresponsive). The scan node ferries blockchain data to agents to process the transaction/block and then consolidates the report of findings to a public Forta smart contract. To learn more about scan nodes, see our FAQ section. Agents Agents refer to a set of code scripts within a Docker container that process some blockchain data (i.e. a block or transaction) and detect specific threat conditions (e.g. whether a flash loan attack occured, or whether a particular account balance fell below some threshold). Agents emit alerts for their findings. Agents are executed by scan nodes. To learn more about agents, see our FAQ section. Agent Registry The Agent Registry refers to a smart contract (currently deployed on the Polygon public mainnet) that records the existence of all agent containers. Developers publish their agent manifests to this registry, and scan nodes listen for events from this contract to know how to manage the agents they are running. Agent Manifest An agent manifest refers to a signed JSON document that describes the contents of an agent container. Specifically, it provides information like the agent version as well as an IPFS reference to the agent container image. Manifests are stored on the IPFS network, with their IPFS references stored in the Agent Registry. Disco Disco is an open-source, decentralized and distributed container registry. This registry is used to store and distribute agent container images. Scan nodes request agent images from a Disco repository.","title":"Core concepts"},{"location":"concepts/#core-concepts","text":"","title":"Core Concepts"},{"location":"concepts/#forta-protocol","text":"The Forta Protocol refers to the distributed and decentralized nodes collaborating to provide threat detection and prevention for smart contract transactions on supported blockchains, coordinated through a set of smart contracts deployed across multiple blockchains. One specific type of node is the scan node. The collection of all nodes and smart contracts is referred to as the Forta Protocol.","title":"Forta Protocol"},{"location":"concepts/#scan-nodes","text":"A scan node is a specific type of Forta node that executes agents for every transaction and every new block on a specific blockchain network (may also be mempool or simulated network). The scan node manages and coordinates agents (e.g. by instantiating and running agents, and restarting agents that become unresponsive). The scan node ferries blockchain data to agents to process the transaction/block and then consolidates the report of findings to a public Forta smart contract. To learn more about scan nodes, see our FAQ section.","title":"Scan Nodes"},{"location":"concepts/#agents","text":"Agents refer to a set of code scripts within a Docker container that process some blockchain data (i.e. a block or transaction) and detect specific threat conditions (e.g. whether a flash loan attack occured, or whether a particular account balance fell below some threshold). Agents emit alerts for their findings. Agents are executed by scan nodes. To learn more about agents, see our FAQ section.","title":"Agents"},{"location":"concepts/#agent-registry","text":"The Agent Registry refers to a smart contract (currently deployed on the Polygon public mainnet) that records the existence of all agent containers. Developers publish their agent manifests to this registry, and scan nodes listen for events from this contract to know how to manage the agents they are running.","title":"Agent Registry"},{"location":"concepts/#agent-manifest","text":"An agent manifest refers to a signed JSON document that describes the contents of an agent container. Specifically, it provides information like the agent version as well as an IPFS reference to the agent container image. Manifests are stored on the IPFS network, with their IPFS references stored in the Agent Registry.","title":"Agent Manifest"},{"location":"concepts/#disco","text":"Disco is an open-source, decentralized and distributed container registry. This registry is used to store and distribute agent container images. Scan nodes request agent images from a Disco repository.","title":"Disco"},{"location":"config/","text":"forta.config.json The forta.config.json file is a shared global config located in ~/.forta that provides configuration for your agent projects. You can optionally override any value for a specific agent project by providing a forta.config.json file in your project folder. Also, if you want to use a specific config file during local development, you can do so using the --config CLI flag. Securing sensitive information Since the config file can contain sensitive information (e.g. Infura API keys), you should not commit it into version control. Here are the following supported configuration properties: jsonRpcUrl - for local development only; allows you to run your agent against data from a specific JSON-RPC endpoint traceRpcUrl - for local development only; allows you to retrieve trace data from the specified JSON-RPC endpoint ipfsGatewayUrl - optional; used to specify a IPFS gateway to upload your agent manifest when publishing ipfsGatewayAuth - optional; provide an authorization header if your IPFS gateway requires one agentRegistryJsonRpcUrl - optional; used to access the network where the Agent Registry is deployed (i.e. Polygon) imageRepositoryUsername - optional; provide authorization username when pushing to an image repository imageRepositoryPassword - optional; provide authorization password when pushing to an image repository keyfile - optional; specify the name of a keyfile in ~/.forta to use for publishing (by default we assume there is only one keyfile) keyfilePassword - optional; specify the password to decrypt the keyfile, useful for CI/CD pipelines agentId - optional; specify the agentId of this agent, to be used for agents deployed with Forta App Migrating to v0.0.19+ The forta.config.json file became a globally shared config stored at ~/.forta in SDK v0.0.19. Before v0.0.19, forta.config.json was stored in each project's folder. The motivation for this change was to prevent repeating configuration values across multiple agent projects. You may still provide a local config file in your project which will override any global config values. If migrating from pre-v0.0.19, you should make the following changes in your project config file: remove the agentId value (instead, copy this value to the name attribute in package.json) remove the version value (instead, copy this value to the version attribute in package.json) remove the documentation value (this is always hardcoded to README.md) copy all remaining values to the global forta.config.json in ~/.forta","title":"forta.config.json"},{"location":"config/#fortaconfigjson","text":"The forta.config.json file is a shared global config located in ~/.forta that provides configuration for your agent projects. You can optionally override any value for a specific agent project by providing a forta.config.json file in your project folder. Also, if you want to use a specific config file during local development, you can do so using the --config CLI flag. Securing sensitive information Since the config file can contain sensitive information (e.g. Infura API keys), you should not commit it into version control. Here are the following supported configuration properties: jsonRpcUrl - for local development only; allows you to run your agent against data from a specific JSON-RPC endpoint traceRpcUrl - for local development only; allows you to retrieve trace data from the specified JSON-RPC endpoint ipfsGatewayUrl - optional; used to specify a IPFS gateway to upload your agent manifest when publishing ipfsGatewayAuth - optional; provide an authorization header if your IPFS gateway requires one agentRegistryJsonRpcUrl - optional; used to access the network where the Agent Registry is deployed (i.e. Polygon) imageRepositoryUsername - optional; provide authorization username when pushing to an image repository imageRepositoryPassword - optional; provide authorization password when pushing to an image repository keyfile - optional; specify the name of a keyfile in ~/.forta to use for publishing (by default we assume there is only one keyfile) keyfilePassword - optional; specify the password to decrypt the keyfile, useful for CI/CD pipelines agentId - optional; specify the agentId of this agent, to be used for agents deployed with Forta App","title":"forta.config.json"},{"location":"config/#migrating-to-v0019","text":"The forta.config.json file became a globally shared config stored at ~/.forta in SDK v0.0.19. Before v0.0.19, forta.config.json was stored in each project's folder. The motivation for this change was to prevent repeating configuration values across multiple agent projects. You may still provide a local config file in your project which will override any global config values. If migrating from pre-v0.0.19, you should make the following changes in your project config file: remove the agentId value (instead, copy this value to the name attribute in package.json) remove the version value (instead, copy this value to the version attribute in package.json) remove the documentation value (this is always hardcoded to README.md) copy all remaining values to the global forta.config.json in ~/.forta","title":"Migrating to v0.0.19+"},{"location":"contest1-compound/","text":"Forta is thrilled to announce that we\u2019ve partnered with Compound Grants to bring you our first Agent Development contest! Below you will find five challenges. Each challenge has a specific security concern that a Forta Agent can solve, provided by Compound. Next to each challenge is a link to a Google Form, which you may use to submit an Agent you develop that meets the challenge requirements to the contest judges. Only the first ten (10) submissions to each challenge that meet the challenge requirements below will be considered. After ten valid submissions are received, the Google Form will be closed and you will be unable to submit any further agents, so work fast! As long as submissions are still open, you are welcome to build agents for as many of these challenges as you can! Each winning agent will receive $1500 in COMP tokens, and a unique Forta NFT which will be provided at a later date when our NFT\u2019s become available. To be eligible for a prize, you will be asked to submit a valid email and discord username through the google form, along with your agent. This contest will run from Oct. 20th through Oct. 27th, after which no further submissions will be considered. Winners will be chosen by a panel of agent reviewers from Forta community member Nethermind, and will be announced on Oct. 29th. For any questions, please contact a Forta Moderator on Discord . Check out Compound docs for more information on Compound Protocol: https://compound.finance/docs Challenges & Winners Provide alert if cToken exchange rate goes down. https://forms.gle/aTpwYWHA15YfdhLeA Winner: @jmederos Winning Agent: https://github.com/jmederosalvarado/compound-ctoken-exrate-down Provide alert for large/unusual transfers out of Comptroller Contract. https://forms.gle/uuSTj6Wd7xCBR21W6 Winner: @kovart Winning Agent: https://github.com/kovart/challenge-2 Provide alert for blacklisted address interacting with Compound Protocol. https://forms.gle/B9dwaAYvddUsnDBV6 Winner: @kovart Winning Agent: https://github.com/kovart/challenge-3 Provide alert for governance proposal advancing through approval process and implementation. https://forms.gle/izaXz2KRRDUe4bkQA Winner: @kovart Winning Agent: https://github.com/kovart/challenge-4 Provide alert for 10% or more change in Utilization Rate within a 60 minute window in a given pool. https://forms.gle/WKhGJmJDHYJJzNe68 Winner: @rsproule Winning Agent: https://github.com/BlockchainCapitalLLC/forta-agent-challenge/tree/main/utilization-rate","title":"Compound Contest (10/20/2021)"},{"location":"contest1-compound/#challenges-winners","text":"Provide alert if cToken exchange rate goes down. https://forms.gle/aTpwYWHA15YfdhLeA Winner: @jmederos Winning Agent: https://github.com/jmederosalvarado/compound-ctoken-exrate-down Provide alert for large/unusual transfers out of Comptroller Contract. https://forms.gle/uuSTj6Wd7xCBR21W6 Winner: @kovart Winning Agent: https://github.com/kovart/challenge-2 Provide alert for blacklisted address interacting with Compound Protocol. https://forms.gle/B9dwaAYvddUsnDBV6 Winner: @kovart Winning Agent: https://github.com/kovart/challenge-3 Provide alert for governance proposal advancing through approval process and implementation. https://forms.gle/izaXz2KRRDUe4bkQA Winner: @kovart Winning Agent: https://github.com/kovart/challenge-4 Provide alert for 10% or more change in Utilization Rate within a 60 minute window in a given pool. https://forms.gle/WKhGJmJDHYJJzNe68 Winner: @rsproule Winning Agent: https://github.com/BlockchainCapitalLLC/forta-agent-challenge/tree/main/utilization-rate","title":"Challenges &amp; Winners"},{"location":"contest2-aave/","text":"Forta is thrilled to announce that we\u2019ve partnered with Aave Grants DAO to bring you our second Agent Development contest! Below you will find five challenges. Each challenge has a specific security concern that a Forta Agent can solve, provided by Aave. Next to each challenge is a link to a Google Form, which you may use to submit an Agent you develop that meets the challenge requirements to the contest judges. Only the first ten (10) submissions to each challenge that meet the challenge requirements below will be considered. After ten valid submissions are received, the Google Form will be closed and you will be unable to submit any further agents, so work fast! As long as submissions are still open, you are welcome to build agents for as many of these challenges as you can! Each winning agent will receive $1000 in AAVE tokens, and a unique Forta NFT which will be provided at a later date when our NFT\u2019s become available. To be eligible for a prize, you will be asked to submit a valid email and discord username through the google form, along with your agent. This contest will run from Nov 3rd through Nov 10th, after which no further submissions will be considered. Winners will be chosen by a panel of agent reviewers from Forta community member Arbitrary Execution, and will be announced on Nov 12th. For any questions, please contact a Forta Moderator on Discord . Check out the Aave liquidity protocol and the Aave Grants DAO for more information: https://governance.aave.com/ Challenges Alert if getFallbackOracle() function is called. https://forms.gle/oxM2zPVJdfWziuPA6 Winner: @kovart Winning Agent: https://github.com/kovart2/challenge-1 Alert if getFallbackOracle() returns a price that deviates more than 10% from last price delivered by getAssetPrice(). https://forms.gle/jN1K43GYd6SjfJL99 Winner: @kovart Winning Agent: https://github.com/kovart2/challenge-2 Alert if aUSDC / aDAI exchange rate goes down. https://forms.gle/yNyu5rfsDm8PHkNaA Winner: @vvlovsky Winning Agent: https://github.com/VVlovsky/forta-aave-agents/tree/main/exchange_rate_goes_down Alert if flash loan transaction value \u2265 $10m. https://forms.gle/eAeB9zziRDw99ssS8 Winner: @kovart Winning Agent: https://github.com/kovart2/challenge-5 Alert if governance proposal is EXECUTED. https://forms.gle/TnhhwTyG7FNoNBdh9 Winner: @vvlovsky Winning Agent: https://github.com/VVlovsky/forta-aave-agents/tree/main/governance","title":"Aave Contest (11/3/2021)"},{"location":"contest2-aave/#challenges","text":"Alert if getFallbackOracle() function is called. https://forms.gle/oxM2zPVJdfWziuPA6 Winner: @kovart Winning Agent: https://github.com/kovart2/challenge-1 Alert if getFallbackOracle() returns a price that deviates more than 10% from last price delivered by getAssetPrice(). https://forms.gle/jN1K43GYd6SjfJL99 Winner: @kovart Winning Agent: https://github.com/kovart2/challenge-2 Alert if aUSDC / aDAI exchange rate goes down. https://forms.gle/yNyu5rfsDm8PHkNaA Winner: @vvlovsky Winning Agent: https://github.com/VVlovsky/forta-aave-agents/tree/main/exchange_rate_goes_down Alert if flash loan transaction value \u2265 $10m. https://forms.gle/eAeB9zziRDw99ssS8 Winner: @kovart Winning Agent: https://github.com/kovart2/challenge-5 Alert if governance proposal is EXECUTED. https://forms.gle/TnhhwTyG7FNoNBdh9 Winner: @vvlovsky Winning Agent: https://github.com/VVlovsky/forta-aave-agents/tree/main/governance","title":"Challenges"},{"location":"contest3-oz/","text":"Forta is thrilled to announce that we\u2019ve partnered with OpenZeppelin to bring you our third Agent Development contest! Submit your entries for this contest HERE . Forta Agents are code scripts written in Python or Javascript that trigger alerts when certain conditions are met. The best Agents trigger alerts when specific conditions indicate that a potential hack or exploit may be taking place and help end users prevent them. For more information on creating your first Agent, check out our Quickstart Guide . Forta Agent Developer Contests are mini-hackathons where anyone is able to submit an Agent and be rewarded in NFTs, and crypto! Contest discussion group and announcements are available on our Discord here . You will find two challenges listed below. Each challenge has a specific security concern that a Forta Agent monitors for. Please submit your completed agents to the contest judges through the Google form linked above and on connect.forta.network . Only the first twenty five (25) QUALIFIED submissions to each challenge that meet the challenge requirements below will be considered. After twenty five qualified submissions are received for an individual challenge, we will close the challenge and announce it in the #agent-development-contest channel in Discord! As long as submissions are still open, you are welcome to build and submit Agents for both challenges! All developers that submit a qualifying agent will receive a Forta NFT. Cash prizes will be awarded to the 1st, 2nd, and 3rd place Agents in each challenge. 1st place will receive $1500 in USDC and a unique Winners Forta NFT. 2nd place will receive $750 in USDC and a unique Winners Forta NFT. 3rd place will receive $250 in USDC and a unique Winners Forta NFT. To be eligible for a prize, you will be asked to submit a valid email and discord username through the Google form, along with your Agent. This contest will run from November 18th through December 2nd, after which no further submissions will be considered. Winners will be chosen by a panel of agent reviewers from Forta community member Nethermind, and will be announced on December 4th. For any questions, please contact a Forta Moderator on Discord . Assessment Criteria Agent implementation Does the code correctly alert according to the challenge description? Does the code make appropriate use of Forta SDK and built-in functions? Does the code contain comments? Is the code well-formatted and easy to read? Testing Do all tests run and pass? Are there negative test cases? i.e. when alerts should not be created Are there positive test cases? i.e. when alerts should be created Documentation Does the README.md have a concise description of agent functionality? Does the README.md contain well-formatted descriptions of each alert? (If Applicable) Does the README.md contain real blocks/transactions that will trigger alerts? Does the package.json contain an appropriate name and description? Check out OpenZeppelin.com for more information on our sponsor! Challenges TimelockController The first vulnerability concerns the TimelockController contract. By exploiting this vulnerability, someone with the executor role could escalate privileges and become admin of the timelock. In the worst scenario, if the executor role was not granted to a set of trusted accounts but left \"open\" unrestricted, an arbitrary attacker could take full control of the timelock. For a detailed description of the issue refer to the post-mortem . The basic way that the exploit can be detected using a Forta agent is based on the particular sequence of events (logs) that it emits. As part of the execution of a batch proposal, at least the following things need to happen in this order: first the timelock delay is set to 0 emitting the events MinDelayChange(\\_, 0) and CallExecuted(id, ...) , then this proposal is scheduled emitting the event CallScheduled(id, ...) where the id is the same as seen in the previous event. Observe that for the same proposal id Executed is seen before Scheduled , which is a violation of the expected lifecycle of a proposal. If this is observed, an alert should be generated. The above rules identify this particular exploit, but as a bonus challenge it would be interesting to alert more generally on a potential privilege escalation situation by monitoring for batch proposals where an executor becomes a proposer or admin, all but one of the proposers and executors are removed, etcetera. Other ideas are welcome. Note: This attack has not, as far as we know, been executed on chain. Winner: @kovart#3924 Winning Agent: https://github.com/kovart3/contest-3-1 2nd Place: @vvlovsky#6572 2nd Place Agent: https://github.com/VVlovsky/TimelockController-Exploit-Agent 3rd Place: @Roderick#4932 3rd Place Agent: https://github.com/rodrigo-pino/timelock-agent-ts UUPSUpgradeable The second vulnerability concerns the UUPSUpgradeable contract. By exploiting this vulnerability, an attacker could trigger a selfdestruct of a UUPS implementation contract, leaving a proxy contract permanently broken. For a detailed description of the issue refer to the post-mortem . In order to detect an attack, an agent needs to find Upgraded(address) events and then retrieve the code of the contract that emitted the event. If the code is empty, this means that the contract was selfdestructed, and an alert should be emitted. Winner: @karmacoma#4155 Winning Agent: https://github.com/karmacoma-eth/forta-uups-agent 2nd Place: @kovart#3924 2nd Place Agent: https://github.com/kovart3/contest-3-2 3rd Place: @nfmelendez#2069 3rd Place Agent: https://github.com/nfmelendez/oz-uupsupgradeable-contract-agent","title":"OpenZeppelin Contest (11/18/2021)"},{"location":"contest3-oz/#assessment-criteria","text":"Agent implementation Does the code correctly alert according to the challenge description? Does the code make appropriate use of Forta SDK and built-in functions? Does the code contain comments? Is the code well-formatted and easy to read? Testing Do all tests run and pass? Are there negative test cases? i.e. when alerts should not be created Are there positive test cases? i.e. when alerts should be created Documentation Does the README.md have a concise description of agent functionality? Does the README.md contain well-formatted descriptions of each alert? (If Applicable) Does the README.md contain real blocks/transactions that will trigger alerts? Does the package.json contain an appropriate name and description? Check out OpenZeppelin.com for more information on our sponsor!","title":"Assessment Criteria"},{"location":"contest3-oz/#challenges","text":"TimelockController The first vulnerability concerns the TimelockController contract. By exploiting this vulnerability, someone with the executor role could escalate privileges and become admin of the timelock. In the worst scenario, if the executor role was not granted to a set of trusted accounts but left \"open\" unrestricted, an arbitrary attacker could take full control of the timelock. For a detailed description of the issue refer to the post-mortem . The basic way that the exploit can be detected using a Forta agent is based on the particular sequence of events (logs) that it emits. As part of the execution of a batch proposal, at least the following things need to happen in this order: first the timelock delay is set to 0 emitting the events MinDelayChange(\\_, 0) and CallExecuted(id, ...) , then this proposal is scheduled emitting the event CallScheduled(id, ...) where the id is the same as seen in the previous event. Observe that for the same proposal id Executed is seen before Scheduled , which is a violation of the expected lifecycle of a proposal. If this is observed, an alert should be generated. The above rules identify this particular exploit, but as a bonus challenge it would be interesting to alert more generally on a potential privilege escalation situation by monitoring for batch proposals where an executor becomes a proposer or admin, all but one of the proposers and executors are removed, etcetera. Other ideas are welcome. Note: This attack has not, as far as we know, been executed on chain. Winner: @kovart#3924 Winning Agent: https://github.com/kovart3/contest-3-1 2nd Place: @vvlovsky#6572 2nd Place Agent: https://github.com/VVlovsky/TimelockController-Exploit-Agent 3rd Place: @Roderick#4932 3rd Place Agent: https://github.com/rodrigo-pino/timelock-agent-ts UUPSUpgradeable The second vulnerability concerns the UUPSUpgradeable contract. By exploiting this vulnerability, an attacker could trigger a selfdestruct of a UUPS implementation contract, leaving a proxy contract permanently broken. For a detailed description of the issue refer to the post-mortem . In order to detect an attack, an agent needs to find Upgraded(address) events and then retrieve the code of the contract that emitted the event. If the code is empty, this means that the contract was selfdestructed, and an alert should be emitted. Winner: @karmacoma#4155 Winning Agent: https://github.com/karmacoma-eth/forta-uups-agent 2nd Place: @kovart#3924 2nd Place Agent: https://github.com/kovart3/contest-3-2 3rd Place: @nfmelendez#2069 3rd Place Agent: https://github.com/nfmelendez/oz-uupsupgradeable-contract-agent","title":"Challenges"},{"location":"contest4-forta/","text":"Forta is thrilled to announce the last Agent Development Contest of 2021! Submit your entries for this contest HERE . Forta Agents are code scripts written in Python, Javascript and Typescript that trigger alerts when certain conditions are met. The best Agents trigger alerts when specific conditions indicate that a potential hack or exploit may be taking place and help end users prevent them. For more information on creating your first Agent, check out our quickstart guide and video tutorials . Forta Agent Developer Contests are mini-hackathons where anyone is able to submit an Agent and be rewarded in NFTs, and Crypto! Contest discussion group and announcements are available on our Discord . Rules You will find two challenges listed below. Each challenge has a specific security concern that a Forta Agent monitors for. Please submit your completed agents to the contest judges through the Google form linked above and on connect.forta.network. Only the first twenty five (25) QUALIFIED submissions to each challenge that meet the challenge requirements below will be considered. After twenty five qualified submissions are received for a challenge, we will close the challenge and announce it in the #agent-dev-contests channel in Discord. As long as submissions are open, you are welcome to build and submit Agents for both challenges! All developers that submit a qualifying agent will receive a Forta NFT. Cash prizes will be awarded to the 1st, 2nd, and 3rd place Agents in each challenge. 1st place will receive $1,500 in USDC and a unique Forta NFT. 2nd place will receive $750 in USDC and a unique Forta NFT. 3rd place will receive $250 in USDC and a unique Forta NFT. To be eligible for a prize, you will be asked to submit a valid email and Discord username through the Google form, along with your Agent. This contest will run from December 17th through December 31st, after which no further submissions will be considered. Winners will be chosen by a panel of agent reviewers from Forta community member Arbitrary Execution, and will be announced on January 7th. For any questions, please contact a Forta Moderator on Discord . Assessment Criteria Agent implementation Does the code correctly alert according to the challenge description? Does the code make appropriate use of Forta SDK and built-in functions? Does the code contain comments? Is the code well-formatted and easy to read? Testing Do all tests run and pass? Are there negative test cases? i.e. when alerts should not be created Are there positive test cases? i.e. when alerts should be created Documentation Does the README.md have a concise description of agent functionality? Does the README.md contain well-formatted descriptions of each alert? (If Applicable) Does the README.md contain real blocks/transactions that will trigger alerts? Does the package.json contain an appropriate name and description? Challenges Influencing Governance Proposals Governance proposals allow protocols to change to meet the evolving requirements of the DeFi ecosystem. Voting on these proposals occurs over a limited period of time where only those accounts that have been delegated votes may cast those votes in favor of or against the proposal. There is also a check to determine whether the delegated votes existed in the block number when the proposal was submitted. This challenge is to create an agent that will monitor proposals to the Uniswap Governance and the votes cast on those proposals. A finding should be created if an address casting a vote had a significant change in UNI balance in the 100 blocks leading up to the proposal starting block number. Optional, but recommended: Tracking balances in the 100 blocks after the vote is cast and creating a finding if the balance decreases. GovernorBravo Contract Github Deployed Contract (Proxy) Uni Token Contract Github Deployed Winner: vvlovsky Winning Agent: https://github.com/VVlovsky/Influencing-Governance-Proposals-Agent 2nd Place: Miguel Martinez 2nd Place Agent: https://github.com/miguelmtzinf/forta-uniswap-governance-influence 3rd Place: kovart 3rd Place Agent: https://github.com/kovart/forta-agents/tree/main/uniswap/governance-votes Evidence of Phishing Users approving token transfers to an externally owned address (EOA) may be a behavior indicative of a phishing attack. This challenge is to create an agent that will detect when a high number (e.g. 10 or more) of EOAs call the approve() or increaseAllowance() methods for the same target EOA over an extend period of time (e.g. 6 hours ~ 1600 blocks). The finding should include the affected addresses, the alleged attacker's address, and the addresses and amounts of tokens involved. Be certain to filter out smart contracts (i.e. approve() called by a smart contract or a smart contract that is the designated spender for an approve() call) and EOAs for any centralized exchanges (e.g. FTX exchange: 0x2FAF487A4414Fe77e2327F0bf4AE2a264a776AD2). The agent should trigger when run against the following block range: 13650638 to 13652198 ERC20 Reference approve() increaseAllowance() Example phishing attacks BadgerDAO Winner: kovart Winning Agent: https://github.com/kovart/forta-agents/tree/main/common/erc20-approve 2nd Place: vvlovsky 2nd Place Agent: https://github.com/VVlovsky/Evidence-of-Phishing-Agent 3rd Place: Rodrigo Pino 3rd Place Agent: https://github.com/rodrigo-pino/forta-phishing-agent-ts","title":"Forta Contest (12/17/2021)"},{"location":"contest4-forta/#rules","text":"You will find two challenges listed below. Each challenge has a specific security concern that a Forta Agent monitors for. Please submit your completed agents to the contest judges through the Google form linked above and on connect.forta.network. Only the first twenty five (25) QUALIFIED submissions to each challenge that meet the challenge requirements below will be considered. After twenty five qualified submissions are received for a challenge, we will close the challenge and announce it in the #agent-dev-contests channel in Discord. As long as submissions are open, you are welcome to build and submit Agents for both challenges! All developers that submit a qualifying agent will receive a Forta NFT. Cash prizes will be awarded to the 1st, 2nd, and 3rd place Agents in each challenge. 1st place will receive $1,500 in USDC and a unique Forta NFT. 2nd place will receive $750 in USDC and a unique Forta NFT. 3rd place will receive $250 in USDC and a unique Forta NFT. To be eligible for a prize, you will be asked to submit a valid email and Discord username through the Google form, along with your Agent. This contest will run from December 17th through December 31st, after which no further submissions will be considered. Winners will be chosen by a panel of agent reviewers from Forta community member Arbitrary Execution, and will be announced on January 7th. For any questions, please contact a Forta Moderator on Discord .","title":"Rules"},{"location":"contest4-forta/#assessment-criteria","text":"Agent implementation Does the code correctly alert according to the challenge description? Does the code make appropriate use of Forta SDK and built-in functions? Does the code contain comments? Is the code well-formatted and easy to read? Testing Do all tests run and pass? Are there negative test cases? i.e. when alerts should not be created Are there positive test cases? i.e. when alerts should be created Documentation Does the README.md have a concise description of agent functionality? Does the README.md contain well-formatted descriptions of each alert? (If Applicable) Does the README.md contain real blocks/transactions that will trigger alerts? Does the package.json contain an appropriate name and description?","title":"Assessment Criteria"},{"location":"contest4-forta/#challenges","text":"Influencing Governance Proposals Governance proposals allow protocols to change to meet the evolving requirements of the DeFi ecosystem. Voting on these proposals occurs over a limited period of time where only those accounts that have been delegated votes may cast those votes in favor of or against the proposal. There is also a check to determine whether the delegated votes existed in the block number when the proposal was submitted. This challenge is to create an agent that will monitor proposals to the Uniswap Governance and the votes cast on those proposals. A finding should be created if an address casting a vote had a significant change in UNI balance in the 100 blocks leading up to the proposal starting block number. Optional, but recommended: Tracking balances in the 100 blocks after the vote is cast and creating a finding if the balance decreases. GovernorBravo Contract Github Deployed Contract (Proxy) Uni Token Contract Github Deployed Winner: vvlovsky Winning Agent: https://github.com/VVlovsky/Influencing-Governance-Proposals-Agent 2nd Place: Miguel Martinez 2nd Place Agent: https://github.com/miguelmtzinf/forta-uniswap-governance-influence 3rd Place: kovart 3rd Place Agent: https://github.com/kovart/forta-agents/tree/main/uniswap/governance-votes Evidence of Phishing Users approving token transfers to an externally owned address (EOA) may be a behavior indicative of a phishing attack. This challenge is to create an agent that will detect when a high number (e.g. 10 or more) of EOAs call the approve() or increaseAllowance() methods for the same target EOA over an extend period of time (e.g. 6 hours ~ 1600 blocks). The finding should include the affected addresses, the alleged attacker's address, and the addresses and amounts of tokens involved. Be certain to filter out smart contracts (i.e. approve() called by a smart contract or a smart contract that is the designated spender for an approve() call) and EOAs for any centralized exchanges (e.g. FTX exchange: 0x2FAF487A4414Fe77e2327F0bf4AE2a264a776AD2). The agent should trigger when run against the following block range: 13650638 to 13652198 ERC20 Reference approve() increaseAllowance() Example phishing attacks BadgerDAO Winner: kovart Winning Agent: https://github.com/kovart/forta-agents/tree/main/common/erc20-approve 2nd Place: vvlovsky 2nd Place Agent: https://github.com/VVlovsky/Evidence-of-Phishing-Agent 3rd Place: Rodrigo Pino 3rd Place Agent: https://github.com/rodrigo-pino/forta-phishing-agent-ts","title":"Challenges"},{"location":"contest5-solace/","text":"Forta is thrilled to announce the first Agent Development Contest of 2022, co-sponsored by Solace! Submit your entries for this contest HERE . Forta Agents are code scripts written in Python, Javascript and Typescript that trigger alerts when certain conditions are met. The best Agents trigger alerts when specific conditions indicate that a potential hack or exploit may be taking place and help end users prevent them. For more information on creating your first Agent, check out our quickstart guide and video tutorials . Forta Agent Developer Contests are mini-hackathons where anyone is able to submit an Agent and be rewarded in NFTs, stablecoins, and crypto. Contest discussion, support, and announcements are available on Forta\u2019s Discord . Rules You will find five challenges listed below. Each challenge has a specific security concern that a Forta Agent monitors for. Please submit your completed agents to the contest judges through the Google form linked above and on Forta Explorer . Only the first ten (10) QUALIFIED submissions to each challenge that meet the challenge requirements below will be considered. After ten qualified submissions are received for a challenge, we will close the challenge and announce it in the #agent-dev-contests channel in Discord. As long as submissions are open, you are welcome to build and submit Agents for all challenges! All developers that submit a qualifying agent will receive a Forta NFT. Cash prizes will be awarded to the winner of each of the 5 challenges - win or go home! 1st place will receive $1,000 in $SOLACE and a unique Forta NFT. To be eligible for a prize, you will be asked to submit a valid email and Discord username through the Google form, along with your Agent. This contest will run from March 1st through March 8th, after which no further submissions will be considered. Winners will be chosen by a panel of agent reviewers from Forta community member Limechain, and will be announced on March 12th. For any questions, please contact a Forta Moderator on Discord . Assessment Criteria Agent implementation Does the code correctly alert according to the challenge description? Does the code make appropriate use of Forta SDK and built-in functions? Does the code contain comments? Is the code well-formatted and easy to read? Testing Do all tests run and pass? Are there negative test cases? i.e. when alerts should not be created Are there positive test cases? i.e. when alerts should be created Documentation Does the README.md have a concise description of agent functionality? Does the README.md contain well-formatted descriptions of each alert? (If Applicable) Does the README.md contain real blocks/transactions that will trigger alerts? Does the package.json contain an appropriate name and description? See Forta\u2019s Code Review checklist for a detailed description of how to develop a high quality agent. Challenges Monitoring Whales on Solace Listen for large Transfer events (>= 1M SOLACE) (on the ETH blockchain) SOLACE Contract: 0x9c051f8a6648a51ef324d30c235da74d060153ac (ETH) SOLACE Docs: https://docs.solace.fi/docs/dev-docs/intro Winner: vvlovsky Winning Agent: https://explorer.forta.network/agent/0x7d63...1f07 ( source code ) BondTeller Monitoring for Basic Functions Monitor when pause() , unpause() , setTerms() , setFees() , or setAddresses() are called on BondTeller contracts (important governance functions). Also listen for Paused , Unpaused , TermsSet , FeesSet , AddressesSet events. Tip: You should monitor all BondTeller contracts DAI BondTeller Contract: 0x501ACe677634Fd09A876E88126076933b686967a (ETH) BondTeller Docs: https://docs.solace.fi/docs/dev-docs/contracts/bonds/BondTellerErc20 Winner: hyodar Winning Agent: https://explorer.forta.network/agent/0x022e...aee9 ( source code ) BondTeller Monitoring Whale Alert Listen for large deposits (>= 1M SOLACE tokens created). Tip: You should monitor all BondTeller contracts DAI BondTeller Contract: 0x501ACe677634Fd09A876E88126076933b686967a (ETH) BondTeller Docs: https://docs.solace.fi/docs/dev-docs/contracts/bonds/BondTellerErc20 Winner: karmacoma Winning Agent: https://explorer.forta.network/agent/0x407c...c276 ( source code ) StakingRewards Monitoring Report when setRewards() or setTimes() are called (important governance functions). Also listen for RewardsSet and FarmTimesSet events. StakingRewards Contract: 0x501ace3D42f9c8723B108D4fBE29989060a91411 (ETH) StakingRewards Docs: https://docs.solace.fi/docs/dev-docs/contracts/staking/StakingRewards Winner: miguelmtzinf Winning Agent: https://explorer.forta.network/agent/0xda27...e6ee ( source code ) BondDepository Monitoring Report when Teller added or removed by listening for TellerAdded and TellerRemoved events BondDepository Contract: 0x501ACe2f00EC599D4FDeA408680e192f88D94D0D (ETH) BondDepository Docs: https://docs.solace.fi/docs/dev-docs/contracts/bonds/BondDepository Winner: vvlovsky Winning Agent: https://explorer.forta.network/agent/0x143f...c15d ( source code )","title":"Solace Contest (3/1/2022)"},{"location":"contest5-solace/#rules","text":"You will find five challenges listed below. Each challenge has a specific security concern that a Forta Agent monitors for. Please submit your completed agents to the contest judges through the Google form linked above and on Forta Explorer . Only the first ten (10) QUALIFIED submissions to each challenge that meet the challenge requirements below will be considered. After ten qualified submissions are received for a challenge, we will close the challenge and announce it in the #agent-dev-contests channel in Discord. As long as submissions are open, you are welcome to build and submit Agents for all challenges! All developers that submit a qualifying agent will receive a Forta NFT. Cash prizes will be awarded to the winner of each of the 5 challenges - win or go home! 1st place will receive $1,000 in $SOLACE and a unique Forta NFT. To be eligible for a prize, you will be asked to submit a valid email and Discord username through the Google form, along with your Agent. This contest will run from March 1st through March 8th, after which no further submissions will be considered. Winners will be chosen by a panel of agent reviewers from Forta community member Limechain, and will be announced on March 12th. For any questions, please contact a Forta Moderator on Discord .","title":"Rules"},{"location":"contest5-solace/#assessment-criteria","text":"Agent implementation Does the code correctly alert according to the challenge description? Does the code make appropriate use of Forta SDK and built-in functions? Does the code contain comments? Is the code well-formatted and easy to read? Testing Do all tests run and pass? Are there negative test cases? i.e. when alerts should not be created Are there positive test cases? i.e. when alerts should be created Documentation Does the README.md have a concise description of agent functionality? Does the README.md contain well-formatted descriptions of each alert? (If Applicable) Does the README.md contain real blocks/transactions that will trigger alerts? Does the package.json contain an appropriate name and description? See Forta\u2019s Code Review checklist for a detailed description of how to develop a high quality agent.","title":"Assessment Criteria"},{"location":"contest5-solace/#challenges","text":"Monitoring Whales on Solace Listen for large Transfer events (>= 1M SOLACE) (on the ETH blockchain) SOLACE Contract: 0x9c051f8a6648a51ef324d30c235da74d060153ac (ETH) SOLACE Docs: https://docs.solace.fi/docs/dev-docs/intro Winner: vvlovsky Winning Agent: https://explorer.forta.network/agent/0x7d63...1f07 ( source code ) BondTeller Monitoring for Basic Functions Monitor when pause() , unpause() , setTerms() , setFees() , or setAddresses() are called on BondTeller contracts (important governance functions). Also listen for Paused , Unpaused , TermsSet , FeesSet , AddressesSet events. Tip: You should monitor all BondTeller contracts DAI BondTeller Contract: 0x501ACe677634Fd09A876E88126076933b686967a (ETH) BondTeller Docs: https://docs.solace.fi/docs/dev-docs/contracts/bonds/BondTellerErc20 Winner: hyodar Winning Agent: https://explorer.forta.network/agent/0x022e...aee9 ( source code ) BondTeller Monitoring Whale Alert Listen for large deposits (>= 1M SOLACE tokens created). Tip: You should monitor all BondTeller contracts DAI BondTeller Contract: 0x501ACe677634Fd09A876E88126076933b686967a (ETH) BondTeller Docs: https://docs.solace.fi/docs/dev-docs/contracts/bonds/BondTellerErc20 Winner: karmacoma Winning Agent: https://explorer.forta.network/agent/0x407c...c276 ( source code ) StakingRewards Monitoring Report when setRewards() or setTimes() are called (important governance functions). Also listen for RewardsSet and FarmTimesSet events. StakingRewards Contract: 0x501ace3D42f9c8723B108D4fBE29989060a91411 (ETH) StakingRewards Docs: https://docs.solace.fi/docs/dev-docs/contracts/staking/StakingRewards Winner: miguelmtzinf Winning Agent: https://explorer.forta.network/agent/0xda27...e6ee ( source code ) BondDepository Monitoring Report when Teller added or removed by listening for TellerAdded and TellerRemoved events BondDepository Contract: 0x501ACe2f00EC599D4FDeA408680e192f88D94D0D (ETH) BondDepository Docs: https://docs.solace.fi/docs/dev-docs/contracts/bonds/BondDepository Winner: vvlovsky Winning Agent: https://explorer.forta.network/agent/0x143f...c15d ( source code )","title":"Challenges"},{"location":"contributing/","text":"How to contribute Thank you for being a part of the Forta Protocol! All contributions from the community are valuable and encouraged. Getting the community involved is essential to Forta's success and there are many ways to contribute even without having to write any code. Here are just a few ideas, but you're welcome to submit any more you think of! Join the Forta Discord One of the best ways to contribute is to just be a positive and helpful member of the Forta Discord community. Participating in the conversation to help answer questions or contribute ideas/advice is extremely valuable, including feedback on how to improve the product and UX. If you have a good understanding of Forta, helping others when they have a question or get stuck is an excellent way to grow the community. Spread the word Runtime blockchain security is a relatively new concept and many people do not know that such a tool is available. If you are aware of a project that is looking to improve their security, has suffered a recent exploit or just needs to build a first line of defense, let them know about Forta! You can also share the Forta Agent development contests on your social media to spread awareness, get people involved and earn crypto prizes. Use the tools Helping test the following tools by simply using them is a great way to contribute: Forta App : Deploy new agents and subscribe to alerts. Forta Explorer : Monitor agents and alerts. Forta API : Integrate alerts into your monitoring tools or dApps. See a bug or have an idea for improvement? Share it in Discord! Improve the documentation Documentation is one of the most important parts of the Forta ecosystem as it onboards new community members and helps users when troubleshooting. Going through the tutorials and reporting typos or parts that are confusing is a helpful way to contribute. This documentation site is opensource and available on Github . See something missing? You can add to the docs by submitting a pull request against the repository (by forking it). Develop the SDK Are you a skilled Javascript, Typescript or Python developer? You can help build out the Forta SDK and developer tools. The SDK and CLI are opensource and available on Github . Got an idea to improve the developer workflow? You can submit a pull request against the repository (by forking it). Reporting or fixing bugs and making suggestions for code improvements are also fantastic ways to contribute. Share useful libraries Have you written an awesome library to help you develop agents? Sharing such tools and libraries helps the community also improve their agents. If you have identified a common pattern when writing your agents, you could share a set of templates that others can use to speed up their agent development process. Check out the useful libaries page to see what is currently recommended. Run a scan node (coming soon) Scan nodes are a key piece of Forta infrastructure as they help run agents and share any alerts. A great way to expand the network is to run your own scan node and create bandwidth for more agents to run. Analyze historical alerts There\u2019s a unique opportunity for the community to take advantage of the open data and collaborate on new data science and machine learning solutions together. For example, the community can begin to extract trends and insights from historical alerts that may be helpful to improving blockchain security. And with the right tools and data, Forta can also begin to detect threats and exploits before they happen with increasing accuracy over time. Do you need access to historical alerts soon for data analysis or for your agent? If so, check out Forta API .","title":"How to contribute"},{"location":"contributing/#how-to-contribute","text":"Thank you for being a part of the Forta Protocol! All contributions from the community are valuable and encouraged. Getting the community involved is essential to Forta's success and there are many ways to contribute even without having to write any code. Here are just a few ideas, but you're welcome to submit any more you think of!","title":"How to contribute"},{"location":"contributing/#join-the-forta-discord","text":"One of the best ways to contribute is to just be a positive and helpful member of the Forta Discord community. Participating in the conversation to help answer questions or contribute ideas/advice is extremely valuable, including feedback on how to improve the product and UX. If you have a good understanding of Forta, helping others when they have a question or get stuck is an excellent way to grow the community.","title":"Join the Forta Discord"},{"location":"contributing/#spread-the-word","text":"Runtime blockchain security is a relatively new concept and many people do not know that such a tool is available. If you are aware of a project that is looking to improve their security, has suffered a recent exploit or just needs to build a first line of defense, let them know about Forta! You can also share the Forta Agent development contests on your social media to spread awareness, get people involved and earn crypto prizes.","title":"Spread the word"},{"location":"contributing/#use-the-tools","text":"Helping test the following tools by simply using them is a great way to contribute: Forta App : Deploy new agents and subscribe to alerts. Forta Explorer : Monitor agents and alerts. Forta API : Integrate alerts into your monitoring tools or dApps. See a bug or have an idea for improvement? Share it in Discord!","title":"Use the tools"},{"location":"contributing/#improve-the-documentation","text":"Documentation is one of the most important parts of the Forta ecosystem as it onboards new community members and helps users when troubleshooting. Going through the tutorials and reporting typos or parts that are confusing is a helpful way to contribute. This documentation site is opensource and available on Github . See something missing? You can add to the docs by submitting a pull request against the repository (by forking it).","title":"Improve the documentation"},{"location":"contributing/#develop-the-sdk","text":"Are you a skilled Javascript, Typescript or Python developer? You can help build out the Forta SDK and developer tools. The SDK and CLI are opensource and available on Github . Got an idea to improve the developer workflow? You can submit a pull request against the repository (by forking it). Reporting or fixing bugs and making suggestions for code improvements are also fantastic ways to contribute.","title":"Develop the SDK"},{"location":"contributing/#share-useful-libraries","text":"Have you written an awesome library to help you develop agents? Sharing such tools and libraries helps the community also improve their agents. If you have identified a common pattern when writing your agents, you could share a set of templates that others can use to speed up their agent development process. Check out the useful libaries page to see what is currently recommended.","title":"Share useful libraries"},{"location":"contributing/#run-a-scan-node-coming-soon","text":"Scan nodes are a key piece of Forta infrastructure as they help run agents and share any alerts. A great way to expand the network is to run your own scan node and create bandwidth for more agents to run.","title":"Run a scan node (coming soon)"},{"location":"contributing/#analyze-historical-alerts","text":"There\u2019s a unique opportunity for the community to take advantage of the open data and collaborate on new data science and machine learning solutions together. For example, the community can begin to extract trends and insights from historical alerts that may be helpful to improving blockchain security. And with the right tools and data, Forta can also begin to detect threats and exploits before they happen with increasing accuracy over time. Do you need access to historical alerts soon for data analysis or for your agent? If so, check out Forta API .","title":"Analyze historical alerts"},{"location":"deploying-app/","text":"Deploying your agent with Forta App This page covers how to deploy your agent using Forta App . Pushing your agent image Before you head over to Forta App, you will need one piece of information: your agent's image reference. You can get the image reference by running the following command ( make sure your Docker is running before proceeding ): npm run push This will build your agent image and push it to a repository where scan nodes can find it. Once completed, you should see a message in your output similar to: successfully pushed image with reference bafybeifutbdhewyz7lfl4z7bfry6xfscaewwhe4n3uqi2gdj67js6plwre@sha256:3904d36d3527ae4135e479dd223c37dde1e6052ae47fdbf3305ebd506d4e34d2 Copy the image reference (i.e. bafybeifutbdhewyz7lfl4z7bfry6xfscaewwhe4n3uqi2gdj67js6plwre@sha256:3904d36d3527ae4135e479dd223c37dde1e6052ae47fdbf3305ebd506d4e34d2 ) to your clipboard and head over to Forta App . Import your keyfile into Metamask Forta App will use your Metamask to send the deployment transaction. You can import your keyfile (located in ~/.forta) with the following steps: In Metamask, click the Accounts dropdown and then click on Import Account Select the JSON File option from the Type dropdown Click on Choose File and navigate to your keyfile (in ~/.forta) and select it Enter the password for your keyfile in the Password box Click the Import button Your keyfile should now be in Metamask. Connect your Metamask to Forta App You will need to connect your Metamask to Forta App with the following steps: On the Forta App website, click the \"Log in with wallet\" button on the top right A Metamask dialog will appear asking you to select which account to connect. Select your imported account, click Next and then click Connect Another Metamask dialog will ask you to sign a message to login. Click the Sign button Your Metamask should now be connected to Forta App. You should see your wallet address appear on the menu at the top right of the page. Deploying In order to deploy your agent, you will need to complete a short form by navigating to the My Agents page (from the menu at the top right): Click the Deploy Agent button to bring up the form. The agent ID will be automatically generated for you Fill in the rest of the fields with your agent's information like name, description, version and which blockchains you want to scan For the Documentation field, select the README.md from your project folder. This will be uploaded to IPFS For the Docker Image field, paste in the image reference you copied earlier from the npm run push command If your code repository is public, fill in the Repository field Click the \"Sign to proceed\" button A Metamask dialog will appear asking you to sign the agent metadata. Click the Sign button A confirmation form will display your agent metadata, including the IPFS hash of the agent metadata and documentation. If these look good, click the Deploy Agent button to initiate the deployment transaction A Metamask dialog will appear asking you to confirm the deployment transaction. Review the details and click the Confirm button When successfully deployed, you should see the agent status as Enabled on the My Agents page. Congratulations! You have successfully deployed your first Forta Agent! Great job getting this far! You have created a project, developed an agent, written and run a test, and deployed it to the Forta protocol. We encourage you to share your agents with the Discord community as a way to showcase your ideas or receive general feedback! For any questions or feedback you may have, you can find us in the Forta Discord server as well. Continue to the next page where you can learn more about subscribing to alerts .","title":"Deploying your agent with Forta App"},{"location":"deploying-app/#deploying-your-agent-with-forta-app","text":"This page covers how to deploy your agent using Forta App .","title":"Deploying your agent with Forta App"},{"location":"deploying-app/#pushing-your-agent-image","text":"Before you head over to Forta App, you will need one piece of information: your agent's image reference. You can get the image reference by running the following command ( make sure your Docker is running before proceeding ): npm run push This will build your agent image and push it to a repository where scan nodes can find it. Once completed, you should see a message in your output similar to: successfully pushed image with reference bafybeifutbdhewyz7lfl4z7bfry6xfscaewwhe4n3uqi2gdj67js6plwre@sha256:3904d36d3527ae4135e479dd223c37dde1e6052ae47fdbf3305ebd506d4e34d2 Copy the image reference (i.e. bafybeifutbdhewyz7lfl4z7bfry6xfscaewwhe4n3uqi2gdj67js6plwre@sha256:3904d36d3527ae4135e479dd223c37dde1e6052ae47fdbf3305ebd506d4e34d2 ) to your clipboard and head over to Forta App .","title":"Pushing your agent image"},{"location":"deploying-app/#import-your-keyfile-into-metamask","text":"Forta App will use your Metamask to send the deployment transaction. You can import your keyfile (located in ~/.forta) with the following steps: In Metamask, click the Accounts dropdown and then click on Import Account Select the JSON File option from the Type dropdown Click on Choose File and navigate to your keyfile (in ~/.forta) and select it Enter the password for your keyfile in the Password box Click the Import button Your keyfile should now be in Metamask.","title":"Import your keyfile into Metamask"},{"location":"deploying-app/#connect-your-metamask-to-forta-app","text":"You will need to connect your Metamask to Forta App with the following steps: On the Forta App website, click the \"Log in with wallet\" button on the top right A Metamask dialog will appear asking you to select which account to connect. Select your imported account, click Next and then click Connect Another Metamask dialog will ask you to sign a message to login. Click the Sign button Your Metamask should now be connected to Forta App. You should see your wallet address appear on the menu at the top right of the page.","title":"Connect your Metamask to Forta App"},{"location":"deploying-app/#deploying","text":"In order to deploy your agent, you will need to complete a short form by navigating to the My Agents page (from the menu at the top right): Click the Deploy Agent button to bring up the form. The agent ID will be automatically generated for you Fill in the rest of the fields with your agent's information like name, description, version and which blockchains you want to scan For the Documentation field, select the README.md from your project folder. This will be uploaded to IPFS For the Docker Image field, paste in the image reference you copied earlier from the npm run push command If your code repository is public, fill in the Repository field Click the \"Sign to proceed\" button A Metamask dialog will appear asking you to sign the agent metadata. Click the Sign button A confirmation form will display your agent metadata, including the IPFS hash of the agent metadata and documentation. If these look good, click the Deploy Agent button to initiate the deployment transaction A Metamask dialog will appear asking you to confirm the deployment transaction. Review the details and click the Confirm button When successfully deployed, you should see the agent status as Enabled on the My Agents page. Congratulations! You have successfully deployed your first Forta Agent! Great job getting this far! You have created a project, developed an agent, written and run a test, and deployed it to the Forta protocol. We encourage you to share your agents with the Discord community as a way to showcase your ideas or receive general feedback! For any questions or feedback you may have, you can find us in the Forta Discord server as well. Continue to the next page where you can learn more about subscribing to alerts .","title":"Deploying"},{"location":"deploying-cli/","text":"Deploying your agent with the CLI This page covers how to deploy your agent using the forta-agent CLI tool. Documentation Documentation for your agent is required in order to deploy. It should let others know what conditions your agent is detecting and what sort of alerts it will fire. Documentation will always be in the README.md file in your project folder (we have provided example documentation to help you get started). Please update the README.md for your specific agent. Configuration A few configuration values must be set in your package.json in order to deploy: name of your agent project should be specified and should be globally unique , so add some unique modifiers description should be a short human-readable description of what your agent does version of your agent should also be set as well chainIds of the blockchains that your agent will be scanning should be specified as an array of integers. You must specify at least one and up to as many as you need. The supported chain IDs are: 1 (Ethereum) 137 (Polygon) 56 (Binance Smart Chain) 43114 (Avalanche) 42161 (Arbitrum) 10 (Optimism) 250 (Fantom) repository is optional , but providing a link to your code helps build trust in your agent Deploying Make sure your Docker is running before proceeding . You can now run the following command from your project folder to deploy your agent: npm run publish This will build a Docker image for your agent using the Dockerfile in your project folder and push it to an image repository where scan nodes can find it. A manifest will be generated for your agent (which includes a reference to the Docker image) and be published to the Agent Registry contract. Signing the manifest The agent manifest will need to be signed using your keyfile (located in ~/.forta), so you will be prompted for the password (unless you specified keyfilePassword in forta.config.json). When successfully deployed, you should see a message in your output similar to successfully added agent id 0x855b1556a45637abf05c63407437f6f305b4627c4361fb965a78e5731999c0c7 with manifest bafybeifutbdhewyz7lfl4z7bfry6xfscaewwhe4n3uqi2gdj67js6plwre@sha256:3904d36d3527ae4135e479dd223c37dde1e6052ae47fdbf3305ebd506d4e34d2 This message contains your agent ID (i.e. 0x855b1556a45637abf05c63407437f6f305b4627c4361fb965a78e5731999c0c7 ) as well as your Docker image reference (i.e. bafybeifutbdhewyz7lfl4z7bfry6xfscaewwhe4n3uqi2gdj67js6plwre@sha256:3904d36d3527ae4135e479dd223c37dde1e6052ae47fdbf3305ebd506d4e34d2 ) Congratulations! You have successfully deployed your first Forta Agent! Great job getting this far! You have created a project, developed an agent, written and run a test, and deployed it to the Forta protocol. We encourage you to share your agents with the Discord community as a way to showcase your ideas or receive general feedback! For any questions or feedback you may have, you can find us in the Forta Discord server as well. Continue to the next page where you can learn more about subscribing to alerts .","title":"Deploying your agent with the CLI"},{"location":"deploying-cli/#deploying-your-agent-with-the-cli","text":"This page covers how to deploy your agent using the forta-agent CLI tool.","title":"Deploying your agent with the CLI"},{"location":"deploying-cli/#documentation","text":"Documentation for your agent is required in order to deploy. It should let others know what conditions your agent is detecting and what sort of alerts it will fire. Documentation will always be in the README.md file in your project folder (we have provided example documentation to help you get started). Please update the README.md for your specific agent.","title":"Documentation"},{"location":"deploying-cli/#configuration","text":"A few configuration values must be set in your package.json in order to deploy: name of your agent project should be specified and should be globally unique , so add some unique modifiers description should be a short human-readable description of what your agent does version of your agent should also be set as well chainIds of the blockchains that your agent will be scanning should be specified as an array of integers. You must specify at least one and up to as many as you need. The supported chain IDs are: 1 (Ethereum) 137 (Polygon) 56 (Binance Smart Chain) 43114 (Avalanche) 42161 (Arbitrum) 10 (Optimism) 250 (Fantom) repository is optional , but providing a link to your code helps build trust in your agent","title":"Configuration"},{"location":"deploying-cli/#deploying","text":"Make sure your Docker is running before proceeding . You can now run the following command from your project folder to deploy your agent: npm run publish This will build a Docker image for your agent using the Dockerfile in your project folder and push it to an image repository where scan nodes can find it. A manifest will be generated for your agent (which includes a reference to the Docker image) and be published to the Agent Registry contract. Signing the manifest The agent manifest will need to be signed using your keyfile (located in ~/.forta), so you will be prompted for the password (unless you specified keyfilePassword in forta.config.json). When successfully deployed, you should see a message in your output similar to successfully added agent id 0x855b1556a45637abf05c63407437f6f305b4627c4361fb965a78e5731999c0c7 with manifest bafybeifutbdhewyz7lfl4z7bfry6xfscaewwhe4n3uqi2gdj67js6plwre@sha256:3904d36d3527ae4135e479dd223c37dde1e6052ae47fdbf3305ebd506d4e34d2 This message contains your agent ID (i.e. 0x855b1556a45637abf05c63407437f6f305b4627c4361fb965a78e5731999c0c7 ) as well as your Docker image reference (i.e. bafybeifutbdhewyz7lfl4z7bfry6xfscaewwhe4n3uqi2gdj67js6plwre@sha256:3904d36d3527ae4135e479dd223c37dde1e6052ae47fdbf3305ebd506d4e34d2 ) Congratulations! You have successfully deployed your first Forta Agent! Great job getting this far! You have created a project, developed an agent, written and run a test, and deployed it to the Forta protocol. We encourage you to share your agents with the Discord community as a way to showcase your ideas or receive general feedback! For any questions or feedback you may have, you can find us in the Forta Discord server as well. Continue to the next page where you can learn more about subscribing to alerts .","title":"Deploying"},{"location":"deploying-connect/","text":"Deploying your agent with Forta Connect This page covers how to deploy your agent using Forta Connect . You can also check out this short video tutorial: Pushing your agent image Before you head over to Forta Connect, you will need one piece of information: your agent's image reference. You can get the image reference by running the following command ( make sure your Docker is running before proceeding ): npm run push This will build your agent image and push it to a repository where scan nodes can find it. Once completed, you should see a message in your output similar to: successfully pushed image with reference bafybeifutbdhewyz7lfl4z7bfry6xfscaewwhe4n3uqi2gdj67js6plwre@sha256:3904d36d3527ae4135e479dd223c37dde1e6052ae47fdbf3305ebd506d4e34d2 Copy the image reference (i.e. bafybeifutbdhewyz7lfl4z7bfry6xfscaewwhe4n3uqi2gdj67js6plwre@sha256:3904d36d3527ae4135e479dd223c37dde1e6052ae47fdbf3305ebd506d4e34d2 ) to your clipboard and head over to Forta Connect . Import your keyfile into Metamask Forta Connect will use your Metamask to send the deployment transaction. You can import your keyfile (located in ~/.forta) with the following steps: In Metamask, click the Accounts dropdown and then click on Import Account Select the JSON File option from the Type dropdown Click on Choose File and navigate to your keyfile (in ~/.forta) and select it Enter the password for your keyfile in the Password box Click the Import button Your keyfile should now be in Metamask. Connect your Metamask to Forta Connect You will need to connect your Metamask to Forta Connect with the following steps: On the Forta Connect website, click the Connect Wallet button on the top right A Metamask dialog will appear asking you to select which account to connect. Select your imported account, click Next and then click Connect In another Metamask dialog you will be asked to switch to the Polygon network. Click the Switch Network button Another Metamask dialog will ask you to sign a message to login. Click the Sign button Your Metamask should now be connected to Forta Connect. You should see a Create Agent button on the top right of the page Deploying In order to deploy your agent, you will need to complete a short form: Click the Create Agent button to bring up the form. The agent ID will be automatically generated for you Fill in the rest of the fields with your agent's information like name, description and version For the Documentation field, select the README.md from your project folder. This will be uploaded to IPFS and the hash will be shown For the Image field, paste in the image reference you copied earlier from the npm run push command If your code repository is public, fill in the Repository field Click the Create button A Metamask dialog will appear asking you to sign the metadata of your agent. Click the Sign button Another Metamask dialog will appear asking you to sign the deployment transaction. Note: the transaction will be gasless (i.e. it won't cost you anything). Click the Sign button When successfully deployed, you should see a dialog on Forta Connect saying your agent was created. Congratulations! You have successfully deployed your first Forta Agent! Great job getting this far! You have created a project, developed an agent, written and run a test, and deployed it to the Forta protocol. We encourage you to share your agents with the Discord community as a way to showcase your ideas or receive general feedback! For any questions or feedback you may have, you can find us in the Forta Discord server as well. Continue to the next page where you can learn more about subscribing to alerts .","title":"Deploying your agent with Forta Connect"},{"location":"deploying-connect/#deploying-your-agent-with-forta-connect","text":"This page covers how to deploy your agent using Forta Connect . You can also check out this short video tutorial:","title":"Deploying your agent with Forta Connect"},{"location":"deploying-connect/#pushing-your-agent-image","text":"Before you head over to Forta Connect, you will need one piece of information: your agent's image reference. You can get the image reference by running the following command ( make sure your Docker is running before proceeding ): npm run push This will build your agent image and push it to a repository where scan nodes can find it. Once completed, you should see a message in your output similar to: successfully pushed image with reference bafybeifutbdhewyz7lfl4z7bfry6xfscaewwhe4n3uqi2gdj67js6plwre@sha256:3904d36d3527ae4135e479dd223c37dde1e6052ae47fdbf3305ebd506d4e34d2 Copy the image reference (i.e. bafybeifutbdhewyz7lfl4z7bfry6xfscaewwhe4n3uqi2gdj67js6plwre@sha256:3904d36d3527ae4135e479dd223c37dde1e6052ae47fdbf3305ebd506d4e34d2 ) to your clipboard and head over to Forta Connect .","title":"Pushing your agent image"},{"location":"deploying-connect/#import-your-keyfile-into-metamask","text":"Forta Connect will use your Metamask to send the deployment transaction. You can import your keyfile (located in ~/.forta) with the following steps: In Metamask, click the Accounts dropdown and then click on Import Account Select the JSON File option from the Type dropdown Click on Choose File and navigate to your keyfile (in ~/.forta) and select it Enter the password for your keyfile in the Password box Click the Import button Your keyfile should now be in Metamask.","title":"Import your keyfile into Metamask"},{"location":"deploying-connect/#connect-your-metamask-to-forta-connect","text":"You will need to connect your Metamask to Forta Connect with the following steps: On the Forta Connect website, click the Connect Wallet button on the top right A Metamask dialog will appear asking you to select which account to connect. Select your imported account, click Next and then click Connect In another Metamask dialog you will be asked to switch to the Polygon network. Click the Switch Network button Another Metamask dialog will ask you to sign a message to login. Click the Sign button Your Metamask should now be connected to Forta Connect. You should see a Create Agent button on the top right of the page","title":"Connect your Metamask to Forta Connect"},{"location":"deploying-connect/#deploying","text":"In order to deploy your agent, you will need to complete a short form: Click the Create Agent button to bring up the form. The agent ID will be automatically generated for you Fill in the rest of the fields with your agent's information like name, description and version For the Documentation field, select the README.md from your project folder. This will be uploaded to IPFS and the hash will be shown For the Image field, paste in the image reference you copied earlier from the npm run push command If your code repository is public, fill in the Repository field Click the Create button A Metamask dialog will appear asking you to sign the metadata of your agent. Click the Sign button Another Metamask dialog will appear asking you to sign the deployment transaction. Note: the transaction will be gasless (i.e. it won't cost you anything). Click the Sign button When successfully deployed, you should see a dialog on Forta Connect saying your agent was created. Congratulations! You have successfully deployed your first Forta Agent! Great job getting this far! You have created a project, developed an agent, written and run a test, and deployed it to the Forta protocol. We encourage you to share your agents with the Discord community as a way to showcase your ideas or receive general feedback! For any questions or feedback you may have, you can find us in the Forta Discord server as well. Continue to the next page where you can learn more about subscribing to alerts .","title":"Deploying"},{"location":"deploying/","text":"Deploying your agent Once you have tested your agent locally, you are ready to deploy it to the Forta protocol production environment! Deploying your agent involves 2 key steps: publishing a Docker image, and registering it in the Agent Registry smart contract. Acquiring Polygon MATIC tokens The Agent Registry smart contract currently lives on Polygon mainnet, so you will need MATIC tokens on Polygon mainnet in order to deploy your agent. You can acquire some MATIC tokens by following this guide . Enable logging (optional) Forta provides a logging feature that can be used to see what's happening inside of your agent across multiple scan nodes. To enable this feature, you need to add/uncomment the following line in the agent Dockerfile : LABEL \"network.forta.settings.agent-logs.enable\"=\"true\" After deploying, you can view agent logs using the Forta API. Publishing your agent image You can choose to deploy using Forta App (recommended), or deploy using the CLI tool . With Forta App, less configuration is required. You may still want to use the CLI tool, for example, in your CI/CD pipeline.","title":"3) Deploying your agent"},{"location":"deploying/#deploying-your-agent","text":"Once you have tested your agent locally, you are ready to deploy it to the Forta protocol production environment! Deploying your agent involves 2 key steps: publishing a Docker image, and registering it in the Agent Registry smart contract.","title":"Deploying your agent"},{"location":"deploying/#acquiring-polygon-matic-tokens","text":"The Agent Registry smart contract currently lives on Polygon mainnet, so you will need MATIC tokens on Polygon mainnet in order to deploy your agent. You can acquire some MATIC tokens by following this guide .","title":"Acquiring Polygon MATIC tokens"},{"location":"deploying/#enable-logging-optional","text":"Forta provides a logging feature that can be used to see what's happening inside of your agent across multiple scan nodes. To enable this feature, you need to add/uncomment the following line in the agent Dockerfile : LABEL \"network.forta.settings.agent-logs.enable\"=\"true\" After deploying, you can view agent logs using the Forta API.","title":"Enable logging (optional)"},{"location":"deploying/#publishing-your-agent-image","text":"You can choose to deploy using Forta App (recommended), or deploy using the CLI tool . With Forta App, less configuration is required. You may still want to use the CLI tool, for example, in your CI/CD pipeline.","title":"Publishing your agent image"},{"location":"ds-and-ml/","text":"Data science and machine learning on Forta Forta API (beta) (February 2022) We recently launched API access to alerts. For more details, please check out the API docs . Check out this short clip below to learn more about how the open-source data on Forta can be used by the community to create next-generation security solutions. Historical Alerts There\u2019s a unique opportunity for the community to take advantage of the open data and collaborate on new data science and machine learning solutions together. For example, the community can begin to extract trends and insights from historical alerts that may be helpful to improving blockchain security. And with the right tools and data, Forta can also begin to detect threats and exploits before they happen with increasing accuracy over time. Do you need access to historical alerts soon for data analysis or for your agent? If so, check out Forta API . Improving Alerts Quality with Machine Learning Forta has been disabling redundant agents to improve the alerts quality. The video below will explain in more detail why Forta did that and give you some insight into the disabling process.","title":"Data science and machine learning on Forta"},{"location":"ds-and-ml/#data-science-and-machine-learning-on-forta","text":"Forta API (beta) (February 2022) We recently launched API access to alerts. For more details, please check out the API docs . Check out this short clip below to learn more about how the open-source data on Forta can be used by the community to create next-generation security solutions.","title":"Data science and machine learning on Forta"},{"location":"ds-and-ml/#historical-alerts","text":"There\u2019s a unique opportunity for the community to take advantage of the open data and collaborate on new data science and machine learning solutions together. For example, the community can begin to extract trends and insights from historical alerts that may be helpful to improving blockchain security. And with the right tools and data, Forta can also begin to detect threats and exploits before they happen with increasing accuracy over time. Do you need access to historical alerts soon for data analysis or for your agent? If so, check out Forta API .","title":"Historical Alerts"},{"location":"ds-and-ml/#improving-alerts-quality-with-machine-learning","text":"Forta has been disabling redundant agents to improve the alerts quality. The video below will explain in more detail why Forta did that and give you some insight into the disabling process.","title":"Improving Alerts Quality with Machine Learning"},{"location":"error-monitoring/","text":"Error monitoring You can verify the health of your agent from the status dashboard on Forta Explorer (i.e. https://explorer.forta.network/agent/YOUR_AGENT_ID ). This will give you information like how many transactions the agent has processed or the latency of its responses. You can also use Forta's logging feature to view agent logs . While this is useful information, agent developers may want to integrate their agent into an existing error monitoring solution (e.g. Sentry ). Initialization Whatever 3rd party error monitoring tool you decide to use, there will probably be some sort of initialization method you need to invoke, possibly using some API key. A good place to do this would be inside the initialize handler of the agent. Also, when placing API keys in your code you probably want to use obfuscation as described in the pattern for hiding sensitive data . Catching errors The simplest approach would be to wrap the logic in your handler functions with a try / catch statement. Upon catching any unexpected errors, you can simply log it using your tool of choice. This will allow you to gain more insights into errors and patch your agent if needed. Keep in mind that there can be multiple instances of your agent running across Forta scan nodes. As such, you may want to assign some generated ID in the agent to distinguish between errors from different instances.","title":"Error monitoring"},{"location":"error-monitoring/#error-monitoring","text":"You can verify the health of your agent from the status dashboard on Forta Explorer (i.e. https://explorer.forta.network/agent/YOUR_AGENT_ID ). This will give you information like how many transactions the agent has processed or the latency of its responses. You can also use Forta's logging feature to view agent logs . While this is useful information, agent developers may want to integrate their agent into an existing error monitoring solution (e.g. Sentry ).","title":"Error monitoring"},{"location":"error-monitoring/#initialization","text":"Whatever 3rd party error monitoring tool you decide to use, there will probably be some sort of initialization method you need to invoke, possibly using some API key. A good place to do this would be inside the initialize handler of the agent. Also, when placing API keys in your code you probably want to use obfuscation as described in the pattern for hiding sensitive data .","title":"Initialization"},{"location":"error-monitoring/#catching-errors","text":"The simplest approach would be to wrap the logic in your handler functions with a try / catch statement. Upon catching any unexpected errors, you can simply log it using your tool of choice. This will allow you to gain more insights into errors and patch your agent if needed. Keep in mind that there can be multiple instances of your agent running across Forta scan nodes. As such, you may want to assign some generated ID in the agent to distinguish between errors from different instances.","title":"Catching errors"},{"location":"faq/","text":"Frequently asked questions Is Forta a blockchain? Short answer: no. Forta is not a blockchain in the sense that it does not maintain shared state between nodes, but it has similar characteristics to a blockchain in that it is a decentralized network of nodes. Forta is more similar to The Graph protocol in that it runs on top of a blockchain. Forta uses a blockchain (i.e. Polygon) to coordinate scan nodes and store IPFS references to alerts generated by agents. How can I consume alerts from agents? You can subscribe to alerts from specific agents or contracts using Forta App . If you connect your wallet and click on \"My Alert Subscriptions\", you can setup notifications for alerts. Currently, email and Slack notifications are supported with more options coming in the near future. How do I run a scan node? Currently, several scan nodes are maintained by OpenZeppelin that scan Ethereum mainnet. Forta will release the scan node to the public in the near future, which will enable others to run scan nodes as well. Stay tuned! Can I scan other blockchains like BSC? Yes! Forta supports scanning on several blockchains including Ethereum, Polygon, BSC, Avalanche, Arbitrum, Optimism and Fantom. Scan nodes are able to scan any EVM-compatible blockchain. In the future, more blockchains will be supported. Do I need special hardware to run scan nodes? The expected profile for a scan node is dual or quad core, 8-16GB memory. More specific hardware requirements will be provided once scan nodes are released to the public in the near future. What makes a good agent? Good agents are ones that detect real-world exploits as they occur, or provide warning of suspicious or unexpected conditions. A good agent is one that is targeting a specific condition i.e. if an agent alerts on more than 5% of transactions, the usefulness of those alerts would not be very high as it is difficult to know what to pay attention to. Where can I get ideas for agents? The best ideas for agents are actual exploits that occur in the real world. As the DeFi space grows rapidly, exploits are occurring almost on a daily basis. To stay up-to-date on these exploits, you can check out the rekt.news website or subscribe to the Blockchain Threat Intelligence newsletter. Also, if you are writing agents for your own protocol it can be useful to think about the types of conditions you want to be made aware of, either in your own protocol or upstream/downstream protocols. Do I need special hardware to build agents? The average consumer laptop is more than sufficient to build agents. If you are using your existing developer machine, you will do great. How can I create alerts that only I can see? You can write a \"private agent\" to generate alerts that can only be understood by you. See the documentation on writing private agents . Can I include sensitive information like API keys in my agent? Agents are stored as Docker images in a public repository i.e. anyone can access and inspect the image and its contents. Currently, there is no supported mechanism for storing secrets on agents. We do not recommend storing sensitive information like private keys or API keys on the agent. Where is my keyfile? The forta-agent CLI will generate a keyfile for you the first time you initialize an agent project. It can be found in the ~/.forta folder. To get the absolute path and address of your keyfile, use the npm run keyfile command from your project folder. Can I use my existing Metamask key to publish agents? You can use any key you prefer for publishing agents. My Infura consumption is high during development. What can I do? If the free tier of services like Infura is not meeting your local development requirements, you can consider running a light Geth node locally. To do this, you would install Geth and then run the command geth --syncmode light --http . This will expose a JSON-RPC endpoint (defaults to http://127.0.0.1:8545 ) that you can point your agent to using the jsonRpcUrl config property in forta.config.json.","title":"FAQ"},{"location":"faq/#frequently-asked-questions","text":"","title":"Frequently asked questions"},{"location":"faq/#is-forta-a-blockchain","text":"Short answer: no. Forta is not a blockchain in the sense that it does not maintain shared state between nodes, but it has similar characteristics to a blockchain in that it is a decentralized network of nodes. Forta is more similar to The Graph protocol in that it runs on top of a blockchain. Forta uses a blockchain (i.e. Polygon) to coordinate scan nodes and store IPFS references to alerts generated by agents.","title":"Is Forta a blockchain?"},{"location":"faq/#how-can-i-consume-alerts-from-agents","text":"You can subscribe to alerts from specific agents or contracts using Forta App . If you connect your wallet and click on \"My Alert Subscriptions\", you can setup notifications for alerts. Currently, email and Slack notifications are supported with more options coming in the near future.","title":"How can I consume alerts from agents?"},{"location":"faq/#how-do-i-run-a-scan-node","text":"Currently, several scan nodes are maintained by OpenZeppelin that scan Ethereum mainnet. Forta will release the scan node to the public in the near future, which will enable others to run scan nodes as well. Stay tuned!","title":"How do I run a scan node?"},{"location":"faq/#can-i-scan-other-blockchains-like-bsc","text":"Yes! Forta supports scanning on several blockchains including Ethereum, Polygon, BSC, Avalanche, Arbitrum, Optimism and Fantom. Scan nodes are able to scan any EVM-compatible blockchain. In the future, more blockchains will be supported.","title":"Can I scan other blockchains like BSC?"},{"location":"faq/#do-i-need-special-hardware-to-run-scan-nodes","text":"The expected profile for a scan node is dual or quad core, 8-16GB memory. More specific hardware requirements will be provided once scan nodes are released to the public in the near future.","title":"Do I need special hardware to run scan nodes?"},{"location":"faq/#what-makes-a-good-agent","text":"Good agents are ones that detect real-world exploits as they occur, or provide warning of suspicious or unexpected conditions. A good agent is one that is targeting a specific condition i.e. if an agent alerts on more than 5% of transactions, the usefulness of those alerts would not be very high as it is difficult to know what to pay attention to.","title":"What makes a good agent?"},{"location":"faq/#where-can-i-get-ideas-for-agents","text":"The best ideas for agents are actual exploits that occur in the real world. As the DeFi space grows rapidly, exploits are occurring almost on a daily basis. To stay up-to-date on these exploits, you can check out the rekt.news website or subscribe to the Blockchain Threat Intelligence newsletter. Also, if you are writing agents for your own protocol it can be useful to think about the types of conditions you want to be made aware of, either in your own protocol or upstream/downstream protocols.","title":"Where can I get ideas for agents?"},{"location":"faq/#do-i-need-special-hardware-to-build-agents","text":"The average consumer laptop is more than sufficient to build agents. If you are using your existing developer machine, you will do great.","title":"Do I need special hardware to build agents?"},{"location":"faq/#how-can-i-create-alerts-that-only-i-can-see","text":"You can write a \"private agent\" to generate alerts that can only be understood by you. See the documentation on writing private agents .","title":"How can I create alerts that only I can see?"},{"location":"faq/#can-i-include-sensitive-information-like-api-keys-in-my-agent","text":"Agents are stored as Docker images in a public repository i.e. anyone can access and inspect the image and its contents. Currently, there is no supported mechanism for storing secrets on agents. We do not recommend storing sensitive information like private keys or API keys on the agent.","title":"Can I include sensitive information like API keys in my agent?"},{"location":"faq/#where-is-my-keyfile","text":"The forta-agent CLI will generate a keyfile for you the first time you initialize an agent project. It can be found in the ~/.forta folder. To get the absolute path and address of your keyfile, use the npm run keyfile command from your project folder.","title":"Where is my keyfile?"},{"location":"faq/#can-i-use-my-existing-metamask-key-to-publish-agents","text":"You can use any key you prefer for publishing agents.","title":"Can I use my existing Metamask key to publish agents?"},{"location":"faq/#my-infura-consumption-is-high-during-development-what-can-i-do","text":"If the free tier of services like Infura is not meeting your local development requirements, you can consider running a light Geth node locally. To do this, you would install Geth and then run the command geth --syncmode light --http . This will expose a JSON-RPC endpoint (defaults to http://127.0.0.1:8545 ) that you can point your agent to using the jsonRpcUrl config property in forta.config.json.","title":"My Infura consumption is high during development. What can I do?"},{"location":"hardhat/","text":"Integrating with Hardhat Integrating Forta in your existing Hardhat project is easier than ever with the Forta Hardhat plugin . You can now keep your security/operational monitoring logic right next to the smart contracts they will be monitoring. The plugin provides convenient access to the Forta Agent development tools to manage the agent lifecycle using Hardhard tasks. This plugin uses the forta-agent package to programmatically invoke commands . For a more comprehensive walkthrough of agent development, we recommend going through the build your first agent guide as well. Installation You can install the Forta Hardhat plugin with the following command: npm install -D hardhat-forta Remember to import the plugin in your hardhat.config.js with the line: require(\"hardhat-forta\"); Or if you are using Typescript, then update your hardhat.config.ts instead: import \"hardhat-forta\"; To verify the installation, run npx hardhat to see the available tasks. You should see the following tasks: forta:init - initialize a sample agent project forta:init:template - initialize an agent project from existing templates forta:run - run an agent project with blockchain data forta:test - execute unit tests for an agent project forta:publish - publish an agent to the Forta network forta:push - build an agent Docker image and push it to the repository forta:disable - disable an agent on the Forta network forta:enable - enable an agent on the Forta network forta:keyfile - print out keyfile information Getting started You can initialize a sample project using the forta:init task, but to create something more useful you can use the forta:init:template task: npx hardhat forta:init:template This will prompt you with a list of templates (i.e. low-code agents) to choose from. Some examples include monitoring whether an account's ETH balance has fallen below a threshold, or if an address that recently interacted with Tornado Cash is now interacting with your contracts. You can select one or more templates from the list. They will be unpacked into a folder called agents in your Hardhat project. Each template comes with a SETUP.md file that you should use to configure the agent's behaviour. All you need to do is modify a single JSON config file. If this is your first time initializing a Forta Agent project on your machine, a keyfile and a forta.config.json file will be generated for you. You will be prompted to enter a password for the keyfile (to be used later for agent deployment). Testing your agent You can now run the agent against real blockchain data using the command: npx hardhat forta:run If you have multiple agents, you will be prompted to select which one to run. By default, the agent will point to Ethereum mainnet using the public Cloudflare RPC endpoint (you can change this by setting the jsonRpcUrl value in the forta.config.json file located at ~/.forta). Once running, you should see output printed to the console showing the agent scanning blocks and transactions. Awesome! You can also use this command to run the agent against specific blocks and transactions using commandline args . There is also a command to run unit tests of the agent project: npx hardhat forta:test Again, you may be prompted to select a specific agent. This command will run any unit tests present in the agent folder. To learn more about testing agents, check out this section . Deploying your agent Once you are happy with the agent behaviour, you can deploy this agent to the production Forta network using the command: npx hardhat forta:publish You may be prompted to select a specific agent if you have multiple. This command builds a Docker image for the agent and pushes it to a public repository. The image will then be registered in an agent registry smart contract. This step requires having MATIC tokens on Polygon mainnet (see here on how to acquire MATIC tokens). Another way to deploy your agent is using the Forta App . To learn more about deploying agents (including how to enable logging), check out this section . Subscribing to alerts After your agent is deployed, you can view the alerts it generates using Forta Explorer . You can search by your agent's ID or a contract address. Alternatively, you can query for alerts programmatically using the Forta API . To learn more about subscribing to alerts, check out this section . Maintaining your agent You may need to update your agent code at some point in the future, or even disable it. This can all be done using the provided Hardhat tasks as well e.g npx hardhat forta:disable . To learn more about maintaining your agent, check out this section .","title":"Integrating with Hardhat"},{"location":"hardhat/#integrating-with-hardhat","text":"Integrating Forta in your existing Hardhat project is easier than ever with the Forta Hardhat plugin . You can now keep your security/operational monitoring logic right next to the smart contracts they will be monitoring. The plugin provides convenient access to the Forta Agent development tools to manage the agent lifecycle using Hardhard tasks. This plugin uses the forta-agent package to programmatically invoke commands . For a more comprehensive walkthrough of agent development, we recommend going through the build your first agent guide as well.","title":"Integrating with Hardhat"},{"location":"hardhat/#installation","text":"You can install the Forta Hardhat plugin with the following command: npm install -D hardhat-forta Remember to import the plugin in your hardhat.config.js with the line: require(\"hardhat-forta\"); Or if you are using Typescript, then update your hardhat.config.ts instead: import \"hardhat-forta\"; To verify the installation, run npx hardhat to see the available tasks. You should see the following tasks: forta:init - initialize a sample agent project forta:init:template - initialize an agent project from existing templates forta:run - run an agent project with blockchain data forta:test - execute unit tests for an agent project forta:publish - publish an agent to the Forta network forta:push - build an agent Docker image and push it to the repository forta:disable - disable an agent on the Forta network forta:enable - enable an agent on the Forta network forta:keyfile - print out keyfile information","title":"Installation"},{"location":"hardhat/#getting-started","text":"You can initialize a sample project using the forta:init task, but to create something more useful you can use the forta:init:template task: npx hardhat forta:init:template This will prompt you with a list of templates (i.e. low-code agents) to choose from. Some examples include monitoring whether an account's ETH balance has fallen below a threshold, or if an address that recently interacted with Tornado Cash is now interacting with your contracts. You can select one or more templates from the list. They will be unpacked into a folder called agents in your Hardhat project. Each template comes with a SETUP.md file that you should use to configure the agent's behaviour. All you need to do is modify a single JSON config file. If this is your first time initializing a Forta Agent project on your machine, a keyfile and a forta.config.json file will be generated for you. You will be prompted to enter a password for the keyfile (to be used later for agent deployment).","title":"Getting started"},{"location":"hardhat/#testing-your-agent","text":"You can now run the agent against real blockchain data using the command: npx hardhat forta:run If you have multiple agents, you will be prompted to select which one to run. By default, the agent will point to Ethereum mainnet using the public Cloudflare RPC endpoint (you can change this by setting the jsonRpcUrl value in the forta.config.json file located at ~/.forta). Once running, you should see output printed to the console showing the agent scanning blocks and transactions. Awesome! You can also use this command to run the agent against specific blocks and transactions using commandline args . There is also a command to run unit tests of the agent project: npx hardhat forta:test Again, you may be prompted to select a specific agent. This command will run any unit tests present in the agent folder. To learn more about testing agents, check out this section .","title":"Testing your agent"},{"location":"hardhat/#deploying-your-agent","text":"Once you are happy with the agent behaviour, you can deploy this agent to the production Forta network using the command: npx hardhat forta:publish You may be prompted to select a specific agent if you have multiple. This command builds a Docker image for the agent and pushes it to a public repository. The image will then be registered in an agent registry smart contract. This step requires having MATIC tokens on Polygon mainnet (see here on how to acquire MATIC tokens). Another way to deploy your agent is using the Forta App . To learn more about deploying agents (including how to enable logging), check out this section .","title":"Deploying your agent"},{"location":"hardhat/#subscribing-to-alerts","text":"After your agent is deployed, you can view the alerts it generates using Forta Explorer . You can search by your agent's ID or a contract address. Alternatively, you can query for alerts programmatically using the Forta API . To learn more about subscribing to alerts, check out this section .","title":"Subscribing to alerts"},{"location":"hardhat/#maintaining-your-agent","text":"You may need to update your agent code at some point in the future, or even disable it. This can all be done using the provided Hardhat tasks as well e.g npx hardhat forta:disable . To learn more about maintaining your agent, check out this section .","title":"Maintaining your agent"},{"location":"help/","text":"Getting help For any questions or feedback you may have, you can find us in the Forta Discord server .","title":"Getting help"},{"location":"help/#getting-help","text":"For any questions or feedback you may have, you can find us in the Forta Discord server .","title":"Getting help"},{"location":"long-running-tasks/","text":"Long running tasks Both handleBlock and handleTransaction functions are required to return within a timeout specified by the protocol (currently 30 seconds). This should be enough time for most agents to complete, but if you need longer for your agent (e.g. you need to execute many network calls) you can still return findings asynchronously. This page covers how to execute long running tasks using a Javascript example agent. The code for this example can be found here . Triggering an asynchronous task The main concept behind this technique is to fire an asynchronous function inside of the handleBlock handler and cache any generated findings in-memory. Each time handleBlock is called, we check whether our long running task should be triggered and also whether there are any findings in our cache to return: let findingsCache = []; let isTaskRunning = false; async function runLongTask(blockNumber) { isTaskRunning = true; // long-running code goes here and adds any findings to findingsCache isTaskRunning = false; } async function handleBlock(blockEvent) { // make sure only one task is running at a time if (!isTaskRunning) { runLongTask(blockEvent.blockNumber); } let findings = []; // check if we have any findings cached if (findingsCache.length > 0) { findings = findingsCache; findingsCache = []; } return findings; } The runLongTask function above is declared as async and is where the long running code would be placed. Note that when it is invoked in handleBlock , we are not await ing it (so that it runs in the background). The isTaskRunning flag also ensures that there is only ever one long running task executing. Other considerations Since the finding may be returned at a later point in time, it will not be associated with the block that triggered it. To get around this, you can store all the information you need from the block inside the metadata of the finding The long running task is being triggered from handleBlock in the example, which should fire on average every 15 seconds for Ethereum mainnet. You may want more regular fixed intervals to trigger your task, in which case you can use the Node.js setInterval function and invoke it from the agent's initialize handler The above example uses a simple flag (i.e. isTaskRunning ) to ensure only one task is running, but based on your requirements you may customize this logic further e.g. making sure a minimum amount of time has passed before triggering the next task Great! You now have an agent that can execute tasks longer than Forta's specified timeout and return findings.","title":"Long running tasks"},{"location":"long-running-tasks/#long-running-tasks","text":"Both handleBlock and handleTransaction functions are required to return within a timeout specified by the protocol (currently 30 seconds). This should be enough time for most agents to complete, but if you need longer for your agent (e.g. you need to execute many network calls) you can still return findings asynchronously. This page covers how to execute long running tasks using a Javascript example agent. The code for this example can be found here .","title":"Long running tasks"},{"location":"long-running-tasks/#triggering-an-asynchronous-task","text":"The main concept behind this technique is to fire an asynchronous function inside of the handleBlock handler and cache any generated findings in-memory. Each time handleBlock is called, we check whether our long running task should be triggered and also whether there are any findings in our cache to return: let findingsCache = []; let isTaskRunning = false; async function runLongTask(blockNumber) { isTaskRunning = true; // long-running code goes here and adds any findings to findingsCache isTaskRunning = false; } async function handleBlock(blockEvent) { // make sure only one task is running at a time if (!isTaskRunning) { runLongTask(blockEvent.blockNumber); } let findings = []; // check if we have any findings cached if (findingsCache.length > 0) { findings = findingsCache; findingsCache = []; } return findings; } The runLongTask function above is declared as async and is where the long running code would be placed. Note that when it is invoked in handleBlock , we are not await ing it (so that it runs in the background). The isTaskRunning flag also ensures that there is only ever one long running task executing.","title":"Triggering an asynchronous task"},{"location":"long-running-tasks/#other-considerations","text":"Since the finding may be returned at a later point in time, it will not be associated with the block that triggered it. To get around this, you can store all the information you need from the block inside the metadata of the finding The long running task is being triggered from handleBlock in the example, which should fire on average every 15 seconds for Ethereum mainnet. You may want more regular fixed intervals to trigger your task, in which case you can use the Node.js setInterval function and invoke it from the agent's initialize handler The above example uses a simple flag (i.e. isTaskRunning ) to ensure only one task is running, but based on your requirements you may customize this logic further e.g. making sure a minimum amount of time has passed before triggering the next task Great! You now have an agent that can execute tasks longer than Forta's specified timeout and return findings.","title":"Other considerations"},{"location":"maintaining/","text":"Maintaining your agent Verifying agent health When your agent is published and picked up by a scan node , you can view the findings it generates using Forta Explorer . You can filter findings using your agent ID (which looks like a SHA-256 hash e.g. 0x855b1556a45637abf05c63407437f6f305b4627c4361fb965a78e5731999c0c7 ) using the search bar near the top of the page. Also, you can verify that your agent is healthy by visiting the agent status page on Forta Explorer. The URL for this page looks like https://explorer.forta.network/agent/YOUR_AGENT_ID . You can see various information about the agent including how many transactions it processed, the different severities of alerts it produced and how long it took to respond to requests. Viewing agent logs If logging is enabled , agent logs are updated by scan nodes every minute. You can fetch the latest logs from https://api.forta.network/logs/agents/YOUR_AGENT_ID . Only logs from the past 30 days are stored. To enable JSON format responses, you can specify the Accept: application/json header in your request. If you would like to integrate an existing error monitoring tool, check out the error monitoring pattern . Disabling/enabling your agent If you will not be using the alerts your agent generates (i.e. you were just testing out Forta, which we encourage), we ask that you please disable the agent. You can use Forta App or the CLI to enable or disable your agent. In Forta App, go to the My Agents page (from the menu at the top right) and click on the options menu to the right of your agent. From the options menu, you can choose to disable or enable your agent. You can also use the CLI command npm run disable . Just make sure to set the agentId property in your project folder's forta.config.json before running the command (you should create the forta.config.json if it doesn't exist). You will also need to ensure you have Polygon MATIC tokens in your keyfile address to execute the disable transaction (you can get the keyfile address using npm run keyfile ). See this guide on how to acquire Polygon MATIC tokens. Similarly, you can re-enable a disabled agent using npm run enable . Updating your agent You may want to update the code for your agent from time to time (e.g. if you found a bug, or there is a new scenario you want to detect). You can use Forta App or the CLI to update your agent. In Forta App, go to the My Agents page (from the menu at the top right) and click on the options menu to the right of your agent. From the options menu, you can choose to edit your agent. You can also use the CLI command npm run publish to update your agent. If you have already deployed an agent, the CLI will know to update the existing agent. Ensure that the keyfile used for updating is the same one you used for creating the agent. Make sure to set the agentId property in your project folder's forta.config.json before running the command (you should create the forta.config.json if it doesn't exist). You will also need to ensure you have Polygon MATIC tokens in your keyfile address to execute the update transaction (you can get the keyfile address using npm run keyfile ). See this guide on how to acquire Polygon MATIC tokens.","title":"5) Maintaining your agent"},{"location":"maintaining/#maintaining-your-agent","text":"","title":"Maintaining your agent"},{"location":"maintaining/#verifying-agent-health","text":"When your agent is published and picked up by a scan node , you can view the findings it generates using Forta Explorer . You can filter findings using your agent ID (which looks like a SHA-256 hash e.g. 0x855b1556a45637abf05c63407437f6f305b4627c4361fb965a78e5731999c0c7 ) using the search bar near the top of the page. Also, you can verify that your agent is healthy by visiting the agent status page on Forta Explorer. The URL for this page looks like https://explorer.forta.network/agent/YOUR_AGENT_ID . You can see various information about the agent including how many transactions it processed, the different severities of alerts it produced and how long it took to respond to requests.","title":"Verifying agent health"},{"location":"maintaining/#viewing-agent-logs","text":"If logging is enabled , agent logs are updated by scan nodes every minute. You can fetch the latest logs from https://api.forta.network/logs/agents/YOUR_AGENT_ID . Only logs from the past 30 days are stored. To enable JSON format responses, you can specify the Accept: application/json header in your request. If you would like to integrate an existing error monitoring tool, check out the error monitoring pattern .","title":"Viewing agent logs"},{"location":"maintaining/#disablingenabling-your-agent","text":"If you will not be using the alerts your agent generates (i.e. you were just testing out Forta, which we encourage), we ask that you please disable the agent. You can use Forta App or the CLI to enable or disable your agent. In Forta App, go to the My Agents page (from the menu at the top right) and click on the options menu to the right of your agent. From the options menu, you can choose to disable or enable your agent. You can also use the CLI command npm run disable . Just make sure to set the agentId property in your project folder's forta.config.json before running the command (you should create the forta.config.json if it doesn't exist). You will also need to ensure you have Polygon MATIC tokens in your keyfile address to execute the disable transaction (you can get the keyfile address using npm run keyfile ). See this guide on how to acquire Polygon MATIC tokens. Similarly, you can re-enable a disabled agent using npm run enable .","title":"Disabling/enabling your agent"},{"location":"maintaining/#updating-your-agent","text":"You may want to update the code for your agent from time to time (e.g. if you found a bug, or there is a new scenario you want to detect). You can use Forta App or the CLI to update your agent. In Forta App, go to the My Agents page (from the menu at the top right) and click on the options menu to the right of your agent. From the options menu, you can choose to edit your agent. You can also use the CLI command npm run publish to update your agent. If you have already deployed an agent, the CLI will know to update the existing agent. Ensure that the keyfile used for updating is the same one you used for creating the agent. Make sure to set the agentId property in your project folder's forta.config.json before running the command (you should create the forta.config.json if it doesn't exist). You will also need to ensure you have Polygon MATIC tokens in your keyfile address to execute the update transaction (you can get the keyfile address using npm run keyfile ). See this guide on how to acquire Polygon MATIC tokens.","title":"Updating your agent"},{"location":"matic/","text":"Acquiring Polygon MATIC As of October 18th 2021, Forta smart contracts (including the Agent Registry) have been moved to Polygon, a blockchain scaling solution that enables faster and cheaper transactions. You will need MATIC tokens in order to pay gas fees on Polygon when deploying your agent. This guide will walk you through converting your ETH (on Ethereum mainnet) to MATIC (on Polygon mainnet). To learn more about Polygon, visit their website . If you already have MATIC tokens on Ethereum mainnet, you can transfer them over to Polygon using the bridge in step 3. 1. Import your keyfile into Metamask In Metamask, click the Accounts dropdown and then click on Import Account Select the JSON File option from the Type dropdown Click on Choose File and navigate to your keyfile (in ~/.forta) and select it Enter the password for your keyfile in the Password box Click the Import button Your keyfile should now be in Metamask. Make sure there is some ETH in this account. 2. Add Polygon network to your Metamask In Metamask, click the Network dropdown and then click on Custom RPC Fill in the following fields: Network Name: Polygon Mainnet RPC URL: https://polygon-rpc.com/ Chain ID: 137 Currency Symbol: MATIC Explorer URL: https://polygonscan.com/ Click the Save button You can now interact with the Polygon network using your Metamask. 3. Move ETH to Polygon using the bridge Navigate to the Polygon bridge Connect your Metamask wallet if needed (you will be prompted to sign a message) Select Ether from the dropdown as the token to transfer Enter how much ETH you want to transfer (for reference, 1 MATIC will allow you to publish ~80 agents) Click the Transfer button, then click Continue on the following dialogs In the Metamask transaction dialog, review the gas fees and click Confirm Wait for the transaction to complete on Ethereum mainnet Verify your account balance on Polygon mainnet using the Polygon block explorer . You should have received WETH as an ERC-20 transfer (may take a few minutes to complete) You have now transferred ETH from Ethereum mainnet over to Polygon mainnet. 4. Swap ETH for MATIC using the swap tool Navigate to the Polygon swap tool Connect your Metamask wallet if needed (you will be prompted to sign a message) Select how much MATIC you want to receive (for reference, 1 MATIC will allow you to publish ~80 agents) Select WETH as the token to swap (will be labelled \"Ether (PoS-WETH)\") Click the Approve button Click the Swap button Wait for the transaction to complete on Polyon mainnet Verify your account balance on Polygon mainnet using the Polygon block explorer . You should have received the specified amount of MATIC You should now have MATIC tokens on Polygon mainnet in order to pay gas fees! You can now continue deploying your agent .","title":"Acquiring Polygon MATIC"},{"location":"matic/#acquiring-polygon-matic","text":"As of October 18th 2021, Forta smart contracts (including the Agent Registry) have been moved to Polygon, a blockchain scaling solution that enables faster and cheaper transactions. You will need MATIC tokens in order to pay gas fees on Polygon when deploying your agent. This guide will walk you through converting your ETH (on Ethereum mainnet) to MATIC (on Polygon mainnet). To learn more about Polygon, visit their website . If you already have MATIC tokens on Ethereum mainnet, you can transfer them over to Polygon using the bridge in step 3.","title":"Acquiring Polygon MATIC"},{"location":"matic/#1-import-your-keyfile-into-metamask","text":"In Metamask, click the Accounts dropdown and then click on Import Account Select the JSON File option from the Type dropdown Click on Choose File and navigate to your keyfile (in ~/.forta) and select it Enter the password for your keyfile in the Password box Click the Import button Your keyfile should now be in Metamask. Make sure there is some ETH in this account.","title":"1. Import your keyfile into Metamask"},{"location":"matic/#2-add-polygon-network-to-your-metamask","text":"In Metamask, click the Network dropdown and then click on Custom RPC Fill in the following fields: Network Name: Polygon Mainnet RPC URL: https://polygon-rpc.com/ Chain ID: 137 Currency Symbol: MATIC Explorer URL: https://polygonscan.com/ Click the Save button You can now interact with the Polygon network using your Metamask.","title":"2. Add Polygon network to your Metamask"},{"location":"matic/#3-move-eth-to-polygon-using-the-bridge","text":"Navigate to the Polygon bridge Connect your Metamask wallet if needed (you will be prompted to sign a message) Select Ether from the dropdown as the token to transfer Enter how much ETH you want to transfer (for reference, 1 MATIC will allow you to publish ~80 agents) Click the Transfer button, then click Continue on the following dialogs In the Metamask transaction dialog, review the gas fees and click Confirm Wait for the transaction to complete on Ethereum mainnet Verify your account balance on Polygon mainnet using the Polygon block explorer . You should have received WETH as an ERC-20 transfer (may take a few minutes to complete) You have now transferred ETH from Ethereum mainnet over to Polygon mainnet.","title":"3. Move ETH to Polygon using the bridge"},{"location":"matic/#4-swap-eth-for-matic-using-the-swap-tool","text":"Navigate to the Polygon swap tool Connect your Metamask wallet if needed (you will be prompted to sign a message) Select how much MATIC you want to receive (for reference, 1 MATIC will allow you to publish ~80 agents) Select WETH as the token to swap (will be labelled \"Ether (PoS-WETH)\") Click the Approve button Click the Swap button Wait for the transaction to complete on Polyon mainnet Verify your account balance on Polygon mainnet using the Polygon block explorer . You should have received the specified amount of MATIC You should now have MATIC tokens on Polygon mainnet in order to pay gas fees! You can now continue deploying your agent .","title":"4. Swap ETH for MATIC using the swap tool"},{"location":"private-alerts/","text":"Private alerts In certain usecases agent developers may want to keep their generated alerts private. Using encryption, agent developers can publish alerts that are unreadable to anyone but themselves. An alternative to encryption is obscurity i.e. use some sort of error code in the finding, like \"42\", which only the agent developer would understand. In addition to encrypting the alerts, you likely also want to obfuscate the agent logic (as done in the example code). Agent images are stored in a public repository where anyone can inspect the contents of the image as well as the agent logic to see what is being scanned for. Check out the pattern for hiding sensitive data to understand how this is implemented. This page describes how to write a Javascript agent that emits private alerts using encryption. You can find the code for this example here . Generating keys OpenPGP public key encryption will be used in this example, but you can use any public key encryption algorithm you prefer (just make sure you understand the tradeoffs). The first step is to generate the keypair you will use for encryption. This example uses the OpenPGP.js library, but you can use any library you prefer. The project has an npm script to generate public and private keys: npm run keygen . This will run the generate-keys.js file and output a public and private key file in the project folder: public.pem and private.pem, respectively. The public key can be distributed with the agent, so let's copy paste it into agent.js (be careful with formatting as there should be no spaces at the beginning of each line). The private key should be secured and kept in a secret place i.e. do not commit private.pem into version control. If you view the agent code in agent.js, you will see that the public key is setup inside the initialize handler function: let publicKey; const publicKeyString = `-----BEGIN PGP PUBLIC KEY BLOCK----- xjMEYaX/KBYJKwYBBAHaRw8BAQdAS373U8tIP2ZjYfzY2tBVzmXgl8UWafEW ... Ei3R2xv3QQEA3Luc1EhUZGuSdvjWhg7YZXJVTOCISdTNrdnodw99kQI= =YYoH -----END PGP PUBLIC KEY BLOCK----- `; async function initialize() { publicKey = await openpgp.readKey({ armoredKey: publicKeyString, }); } Encrypting findings In this example, a regular finding is created the way you normally would in handleTransaction , and then passed through the encryptFindings function. This will return a list of new encrypted findings with most attributes set to \"omitted\". The original finding will be encrypted using the public key and then stored in the metadata field of the encrypted finding as a base64 string: async function encryptFindings(findings) { return Promise.all( findings.map(async (finding) => { // encrypt the original finding const originalFindingString = JSON.stringify(finding); const message = await openpgp.createMessage({ text: originalFindingString, }); const encryptedOriginalFinding = await openpgp.encrypt({ message, encryptionKeys: publicKey, }); // create a new finding with most fields replaced with the string 'omitted' const omittedString = \"omitted\"; const encryptedFinding = Finding.fromObject({ name: omittedString, description: omittedString, alertId: omittedString, protocol: omittedString, severity: FindingSeverity.Unknown, type: FindingType.Unknown, metadata: { data: encryptedOriginalFinding.toString(\"base64\"), // nest the original finding into the metadata }, }); return encryptedFinding; }) ); } Try and run this agent using npm start and verify that the findings are printed. The data field will look like a gibberish string e.g. \"metadata\": { \"data\": \"-----BEGIN PGP MESSAGE-----\\n\\nwV4DnxOp2TR9DQISAQdAu9EkgSitn74NvrbYS6bCLUt0wzEgSY3ttXBVo/cF\\ntE0w34HroEIRL4CjIrDJnZxaKoQXTIHw5zFqUHKcROwX8g27IDfilxg2i21B\\nq2780NHy0sAJAQQtXuyjo7r+oN/H1Kl/KgB+OzBg1Jd5M0Bjx5brBXOMt30j\\n52KB+4Q68VnqO5tUFc4+Cc35+ZfYzxwpNWQy7JH0q+iHuVNwk8HpU+jmR98q\\nfqEIKTN1IDUM1zbZRsogPBbgjjT/kR5RnQS+Vw66TItV8ciGtSUYSF/UJBN4\\nnskwMYxL/3NZzwlEw+NxplsYAu9W5AJXZiEYfDTJ6OJq9jCGWDWLIi9DsjL+\\n0Nf1qwByGhuLAMdsFkLNIDhOe9vUdNFZs14umrK6\\n=8WDC\\n-----END PGP MESSAGE-----\\n\" } Great! Now that you have an agent generating encrypted findings, let's go over how to decrypt the data and use it. Decrypting findings In order to decrypt the finding, you would make use of the private key in private.pem. In practice, you would subscribe to findings from your particular agent using the Forta App and receive its contents via some webhook. Upon receiving the finding, you can decrypt the data using the private key. For this example's sake, the project has a decrypt.js file to help you decrypt your finding data and verify that it's what you expect. If you open a node console from your project folder, you can decrypt the data string from your finding: $ node > const { decrypt } = require(\"./decrypt\") > decrypt(\"-----BEGIN PGP MESSAGE-----\\n\\nwV4DnxOp2TR...s14umrK6\\n=8WDC\\n-----END PGP MESSAGE-----\\n\").then(r => console.log(r)) The above code should print out the finding that was passed into the encryptFindings function. setPrivateFindings As an added layer of security, agents can indicate that they do not want their findings indexed by Forta Explorer. An adversary could potentially look for alerts that use encryption and with enough alerts could infer what condition the agent is looking for. To avoid this, simply invoke setPrivateFindings(true) in the initialize handler: const { setPrivateFindings } = require(\"forta-agent\") async function initialize() { ... setPrivateFindings(true) } This will tell the Forta protocol not to display the emitted alerts in Forta Explorer, as well as not to associate the alert with any block/transaction. If you would like to reference the block/transaction, you would need to set the data yourself in the finding metadata . Other considerations Make sure to modify the README.md documentation to not reveal anything about the agent since it will be published in the agent manifest. You can keep a separate file (e.g. README_private.md) for your own internal documentation Be careful when populating the package.json name and description fields as these will get published in the agent manifest. You may not want these to reveal anything about the agent For agents with several files, you can encrypt all findings in the top-level agent.js file. This way you don't need to repeat encryption code across multiple files Do not read the public key from the public.pem file as this would make your agent vulnerable to an exploit where an attacker can replace the public.pem file with their own public key and decrypt your agent's findings on their own machine Make sure that unit tests are also obfuscated, or better yet, just not included in the final image. This could easily reveal what the agent is doing Awesome! You now have an agent that encrypts findings which do not appear in Forta Explorer.","title":"Private alerts"},{"location":"private-alerts/#private-alerts","text":"In certain usecases agent developers may want to keep their generated alerts private. Using encryption, agent developers can publish alerts that are unreadable to anyone but themselves. An alternative to encryption is obscurity i.e. use some sort of error code in the finding, like \"42\", which only the agent developer would understand. In addition to encrypting the alerts, you likely also want to obfuscate the agent logic (as done in the example code). Agent images are stored in a public repository where anyone can inspect the contents of the image as well as the agent logic to see what is being scanned for. Check out the pattern for hiding sensitive data to understand how this is implemented. This page describes how to write a Javascript agent that emits private alerts using encryption. You can find the code for this example here .","title":"Private alerts"},{"location":"private-alerts/#generating-keys","text":"OpenPGP public key encryption will be used in this example, but you can use any public key encryption algorithm you prefer (just make sure you understand the tradeoffs). The first step is to generate the keypair you will use for encryption. This example uses the OpenPGP.js library, but you can use any library you prefer. The project has an npm script to generate public and private keys: npm run keygen . This will run the generate-keys.js file and output a public and private key file in the project folder: public.pem and private.pem, respectively. The public key can be distributed with the agent, so let's copy paste it into agent.js (be careful with formatting as there should be no spaces at the beginning of each line). The private key should be secured and kept in a secret place i.e. do not commit private.pem into version control. If you view the agent code in agent.js, you will see that the public key is setup inside the initialize handler function: let publicKey; const publicKeyString = `-----BEGIN PGP PUBLIC KEY BLOCK----- xjMEYaX/KBYJKwYBBAHaRw8BAQdAS373U8tIP2ZjYfzY2tBVzmXgl8UWafEW ... Ei3R2xv3QQEA3Luc1EhUZGuSdvjWhg7YZXJVTOCISdTNrdnodw99kQI= =YYoH -----END PGP PUBLIC KEY BLOCK----- `; async function initialize() { publicKey = await openpgp.readKey({ armoredKey: publicKeyString, }); }","title":"Generating keys"},{"location":"private-alerts/#encrypting-findings","text":"In this example, a regular finding is created the way you normally would in handleTransaction , and then passed through the encryptFindings function. This will return a list of new encrypted findings with most attributes set to \"omitted\". The original finding will be encrypted using the public key and then stored in the metadata field of the encrypted finding as a base64 string: async function encryptFindings(findings) { return Promise.all( findings.map(async (finding) => { // encrypt the original finding const originalFindingString = JSON.stringify(finding); const message = await openpgp.createMessage({ text: originalFindingString, }); const encryptedOriginalFinding = await openpgp.encrypt({ message, encryptionKeys: publicKey, }); // create a new finding with most fields replaced with the string 'omitted' const omittedString = \"omitted\"; const encryptedFinding = Finding.fromObject({ name: omittedString, description: omittedString, alertId: omittedString, protocol: omittedString, severity: FindingSeverity.Unknown, type: FindingType.Unknown, metadata: { data: encryptedOriginalFinding.toString(\"base64\"), // nest the original finding into the metadata }, }); return encryptedFinding; }) ); } Try and run this agent using npm start and verify that the findings are printed. The data field will look like a gibberish string e.g. \"metadata\": { \"data\": \"-----BEGIN PGP MESSAGE-----\\n\\nwV4DnxOp2TR9DQISAQdAu9EkgSitn74NvrbYS6bCLUt0wzEgSY3ttXBVo/cF\\ntE0w34HroEIRL4CjIrDJnZxaKoQXTIHw5zFqUHKcROwX8g27IDfilxg2i21B\\nq2780NHy0sAJAQQtXuyjo7r+oN/H1Kl/KgB+OzBg1Jd5M0Bjx5brBXOMt30j\\n52KB+4Q68VnqO5tUFc4+Cc35+ZfYzxwpNWQy7JH0q+iHuVNwk8HpU+jmR98q\\nfqEIKTN1IDUM1zbZRsogPBbgjjT/kR5RnQS+Vw66TItV8ciGtSUYSF/UJBN4\\nnskwMYxL/3NZzwlEw+NxplsYAu9W5AJXZiEYfDTJ6OJq9jCGWDWLIi9DsjL+\\n0Nf1qwByGhuLAMdsFkLNIDhOe9vUdNFZs14umrK6\\n=8WDC\\n-----END PGP MESSAGE-----\\n\" } Great! Now that you have an agent generating encrypted findings, let's go over how to decrypt the data and use it.","title":"Encrypting findings"},{"location":"private-alerts/#decrypting-findings","text":"In order to decrypt the finding, you would make use of the private key in private.pem. In practice, you would subscribe to findings from your particular agent using the Forta App and receive its contents via some webhook. Upon receiving the finding, you can decrypt the data using the private key. For this example's sake, the project has a decrypt.js file to help you decrypt your finding data and verify that it's what you expect. If you open a node console from your project folder, you can decrypt the data string from your finding: $ node > const { decrypt } = require(\"./decrypt\") > decrypt(\"-----BEGIN PGP MESSAGE-----\\n\\nwV4DnxOp2TR...s14umrK6\\n=8WDC\\n-----END PGP MESSAGE-----\\n\").then(r => console.log(r)) The above code should print out the finding that was passed into the encryptFindings function.","title":"Decrypting findings"},{"location":"private-alerts/#setprivatefindings","text":"As an added layer of security, agents can indicate that they do not want their findings indexed by Forta Explorer. An adversary could potentially look for alerts that use encryption and with enough alerts could infer what condition the agent is looking for. To avoid this, simply invoke setPrivateFindings(true) in the initialize handler: const { setPrivateFindings } = require(\"forta-agent\") async function initialize() { ... setPrivateFindings(true) } This will tell the Forta protocol not to display the emitted alerts in Forta Explorer, as well as not to associate the alert with any block/transaction. If you would like to reference the block/transaction, you would need to set the data yourself in the finding metadata .","title":"setPrivateFindings"},{"location":"private-alerts/#other-considerations","text":"Make sure to modify the README.md documentation to not reveal anything about the agent since it will be published in the agent manifest. You can keep a separate file (e.g. README_private.md) for your own internal documentation Be careful when populating the package.json name and description fields as these will get published in the agent manifest. You may not want these to reveal anything about the agent For agents with several files, you can encrypt all findings in the top-level agent.js file. This way you don't need to repeat encryption code across multiple files Do not read the public key from the public.pem file as this would make your agent vulnerable to an exploit where an attacker can replace the public.pem file with their own public key and decrypt your agent's findings on their own machine Make sure that unit tests are also obfuscated, or better yet, just not included in the final image. This could easily reveal what the agent is doing Awesome! You now have an agent that encrypts findings which do not appear in Forta Explorer.","title":"Other considerations"},{"location":"python/","text":"Python SDK The Forta Agent Python SDK comes with a set of classes to provide a consistent interface for developers to write their agents. There are also some utility functions available for your convenience to do common operations like searching for an event in a transaction receipt. Check out the Python agents in our examples repo to learn more. NOTE : while you can write agents in Python, you would still use the Node.js forta-agent CLI tool to run the agent Handlers The most relevant functions for agent developers are the handler functions: initialize , handle_block and handle_transaction . Your agent.py file must declare a handle_block and/or handle_transaction function. You can implement one or both of these depending on your use case, but at least one must be provided. These functions take a BlockEvent or TransactionEvent as their input, respectively, and return an array of zero or more Finding objects. You can also optionally declare an initialize function that will be executed on agent startup. This is useful for fetching some data from the network or parsing some file before your agent begins. BlockEvent When a block is mined and detected by a Forta scan node, it will generate a BlockEvent containing information such as the block hash and block number. It contains the following fields: type - specifies whether this was a block reorg or a regular block network - specifies which network the block was mined on (e.g. mainnet, ropsten, rinkeby, etc) block_hash - alias for block.hash block_number - alias for block.number block - data object containing the following fields: difficulty extra_data gas_limit gas_used hash logs_bloom miner mix_hash nonce number parent_hash receipts_root sha3_uncles size state_root timestamp total_difficulty transactions transactions_root uncles TransactionEvent When a transaction is mined and detected by a Forta scan node, it will generate a TransactionEvent containing various information about the transaction. It contains the following fields: type - specifies whether this was from a block reorg or a regular block network - specifies which network the transaction was mined on (e.g. mainnet, ropsten, rinkeby, etc) hash - alias for transaction.hash from_ - alias for transaction.from_ to - alias for transaction.to gas_price - alias for transaction.gas_price gas_used - alias for receipt.gas_used status - alias for receipt.status logs - alias for receipt.logs timestamp - alias for block.timestamp block_number - alias for block.number block_hash - alias for block.hash addresses - map of addresses involved in the transaction (generated from transaction to/from address, any event log address and trace data address if available) block - data object containing following fields: hash number timestamp transaction - data object containing the following fields: hash from_ to nonce gas gas_price value data r s v receipt - receipt object containing the following fields: status root gasUsed cumulative_gas_used logs_bloom contract_address block_number block_hash transaction_index transaction_hash logs - list of log objects with following fields: address topics data log_index block_number block_hash transaction_index transaction_hash removed traces - only with tracing enabled; list of trace objects with following fields: block_hash block_number subtraces trace_address transaction_hash transaction_position type error action - object with following fields: call_type to from_ input value init address balance refund_address result - object with following fields: gas_used address code output filter_log filter_log is a convenience function on TransactionEvent to filter and decode transaction logs. For example, you can use it to get all of the Transfer logs in a transaction from a particular ERC-20 token: erc20_token_address = '0x123abc' transfer_event_abi = '{\"name\":\"Transfer\",\"type\":\"event\",\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}]}' transfers = transaction_event.filter_log(transfer_event_abi, erc20_token_address) print(f'found {transfers.length} transfer events') The underlying library used for decoding event logs is web3.py . The Python SDK uses the web3.py processLog method and returns an array of Event Log objects. To better understand usage, see the Python filtering example agent. filter_function filter_function is a convenience function on TransactionEvent to filter and decode function calls in the transaction or traces. For example, you can use it to get all of the transferFrom function calls on a particular ERC-20 token: erc20_token_address = '0x123abc' transferFrom_function_abi = '{\"name\":\"transferFrom\",\"type\":\"function\",\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\"}' transfers = transaction_event.filter_function(transferFrom_function_abi, erc20_token_address) print(f'found {transfers.length} function calls') The underlying library used for decoding function calls is web3.py . The Python SDK uses the web3.py decode_function_input method and returns an array of ( ContractFunction , dict ) tuples. To better understand usage, see the Python filtering example agent. Finding If an agent wants to flag a transaction/block because it meets some condition (e.g. flash loan attack), the handler function would return a Finding object. This object would detail the results of the finding and provide metadata such as the severity of the finding. A Finding object accepts the following properties: name - required ; human-readable name of finding e.g. \"High Gas\" description - required ; brief description e.g. \"High gas used: 1,000,000\" alert_id - required ; unique string to identify this class of finding, primarily used to group similar findings for the end user protocol - required ; name of protocol being reported on e.g. \"aave\", defaults to \"ethereum\" if left blank type - required ; indicates type of finding: Exploit Suspicious Degraded Info severity - required ; indicates impact level of finding: Critical - exploitable vulnerabilities, massive impact on users/funds High - exploitable under more specific conditions, significant impact on users/funds Medium - notable unexpected behaviours, moderate to low impact on users/funds Low - minor oversights, negligible impact on users/funds Info - miscellaneous behaviours worth describing metadata - optional; dict (both keys and values as strings) for providing extra information get_json_rpc_url A convenience function called get_json_rpc_url can be used to load a JSON-RPC URL for your agent. When running in production, this function will return a URL injected by the scan node that is running the agent. When running locally in development, this function will return the jsonRpcUrl property specified in your forta.config.json file. get_web3_provider get_web3_provider is a convenience function that returns a web3.py Provider which can be used to interact with the blockchain. The value from get_json_rpc_url will be used as the JSON-RPC endpoint to connect to. create_block_event A utility function for writing tests. You can use create_block_event to easily generate a mock BlockEvent object when writing unit tests for your handle_block handler. To better understand usage, see the Python unit test example . create_transaction_event A utility function for writing tests. You can use create_transaction_event to easily generate a mock TransactionEvent object when writing unit tests for your handle_transaction handler. To better understand usage, see the Python unit test example .","title":"Python SDK"},{"location":"python/#python-sdk","text":"The Forta Agent Python SDK comes with a set of classes to provide a consistent interface for developers to write their agents. There are also some utility functions available for your convenience to do common operations like searching for an event in a transaction receipt. Check out the Python agents in our examples repo to learn more. NOTE : while you can write agents in Python, you would still use the Node.js forta-agent CLI tool to run the agent","title":"Python SDK"},{"location":"python/#handlers","text":"The most relevant functions for agent developers are the handler functions: initialize , handle_block and handle_transaction . Your agent.py file must declare a handle_block and/or handle_transaction function. You can implement one or both of these depending on your use case, but at least one must be provided. These functions take a BlockEvent or TransactionEvent as their input, respectively, and return an array of zero or more Finding objects. You can also optionally declare an initialize function that will be executed on agent startup. This is useful for fetching some data from the network or parsing some file before your agent begins.","title":"Handlers"},{"location":"python/#blockevent","text":"When a block is mined and detected by a Forta scan node, it will generate a BlockEvent containing information such as the block hash and block number. It contains the following fields: type - specifies whether this was a block reorg or a regular block network - specifies which network the block was mined on (e.g. mainnet, ropsten, rinkeby, etc) block_hash - alias for block.hash block_number - alias for block.number block - data object containing the following fields: difficulty extra_data gas_limit gas_used hash logs_bloom miner mix_hash nonce number parent_hash receipts_root sha3_uncles size state_root timestamp total_difficulty transactions transactions_root uncles","title":"BlockEvent"},{"location":"python/#transactionevent","text":"When a transaction is mined and detected by a Forta scan node, it will generate a TransactionEvent containing various information about the transaction. It contains the following fields: type - specifies whether this was from a block reorg or a regular block network - specifies which network the transaction was mined on (e.g. mainnet, ropsten, rinkeby, etc) hash - alias for transaction.hash from_ - alias for transaction.from_ to - alias for transaction.to gas_price - alias for transaction.gas_price gas_used - alias for receipt.gas_used status - alias for receipt.status logs - alias for receipt.logs timestamp - alias for block.timestamp block_number - alias for block.number block_hash - alias for block.hash addresses - map of addresses involved in the transaction (generated from transaction to/from address, any event log address and trace data address if available) block - data object containing following fields: hash number timestamp transaction - data object containing the following fields: hash from_ to nonce gas gas_price value data r s v receipt - receipt object containing the following fields: status root gasUsed cumulative_gas_used logs_bloom contract_address block_number block_hash transaction_index transaction_hash logs - list of log objects with following fields: address topics data log_index block_number block_hash transaction_index transaction_hash removed traces - only with tracing enabled; list of trace objects with following fields: block_hash block_number subtraces trace_address transaction_hash transaction_position type error action - object with following fields: call_type to from_ input value init address balance refund_address result - object with following fields: gas_used address code output","title":"TransactionEvent"},{"location":"python/#filter_log","text":"filter_log is a convenience function on TransactionEvent to filter and decode transaction logs. For example, you can use it to get all of the Transfer logs in a transaction from a particular ERC-20 token: erc20_token_address = '0x123abc' transfer_event_abi = '{\"name\":\"Transfer\",\"type\":\"event\",\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}]}' transfers = transaction_event.filter_log(transfer_event_abi, erc20_token_address) print(f'found {transfers.length} transfer events') The underlying library used for decoding event logs is web3.py . The Python SDK uses the web3.py processLog method and returns an array of Event Log objects. To better understand usage, see the Python filtering example agent.","title":"filter_log"},{"location":"python/#filter_function","text":"filter_function is a convenience function on TransactionEvent to filter and decode function calls in the transaction or traces. For example, you can use it to get all of the transferFrom function calls on a particular ERC-20 token: erc20_token_address = '0x123abc' transferFrom_function_abi = '{\"name\":\"transferFrom\",\"type\":\"function\",\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\"}' transfers = transaction_event.filter_function(transferFrom_function_abi, erc20_token_address) print(f'found {transfers.length} function calls') The underlying library used for decoding function calls is web3.py . The Python SDK uses the web3.py decode_function_input method and returns an array of ( ContractFunction , dict ) tuples. To better understand usage, see the Python filtering example agent.","title":"filter_function"},{"location":"python/#finding","text":"If an agent wants to flag a transaction/block because it meets some condition (e.g. flash loan attack), the handler function would return a Finding object. This object would detail the results of the finding and provide metadata such as the severity of the finding. A Finding object accepts the following properties: name - required ; human-readable name of finding e.g. \"High Gas\" description - required ; brief description e.g. \"High gas used: 1,000,000\" alert_id - required ; unique string to identify this class of finding, primarily used to group similar findings for the end user protocol - required ; name of protocol being reported on e.g. \"aave\", defaults to \"ethereum\" if left blank type - required ; indicates type of finding: Exploit Suspicious Degraded Info severity - required ; indicates impact level of finding: Critical - exploitable vulnerabilities, massive impact on users/funds High - exploitable under more specific conditions, significant impact on users/funds Medium - notable unexpected behaviours, moderate to low impact on users/funds Low - minor oversights, negligible impact on users/funds Info - miscellaneous behaviours worth describing metadata - optional; dict (both keys and values as strings) for providing extra information","title":"Finding"},{"location":"python/#get_json_rpc_url","text":"A convenience function called get_json_rpc_url can be used to load a JSON-RPC URL for your agent. When running in production, this function will return a URL injected by the scan node that is running the agent. When running locally in development, this function will return the jsonRpcUrl property specified in your forta.config.json file.","title":"get_json_rpc_url"},{"location":"python/#get_web3_provider","text":"get_web3_provider is a convenience function that returns a web3.py Provider which can be used to interact with the blockchain. The value from get_json_rpc_url will be used as the JSON-RPC endpoint to connect to.","title":"get_web3_provider"},{"location":"python/#create_block_event","text":"A utility function for writing tests. You can use create_block_event to easily generate a mock BlockEvent object when writing unit tests for your handle_block handler. To better understand usage, see the Python unit test example .","title":"create_block_event"},{"location":"python/#create_transaction_event","text":"A utility function for writing tests. You can use create_transaction_event to easily generate a mock TransactionEvent object when writing unit tests for your handle_transaction handler. To better understand usage, see the Python unit test example .","title":"create_transaction_event"},{"location":"querying-chains/","text":"Querying other chains Forta currently supports scanning on several chains including Ethereum, Polygon, BSC, Avalanche, Arbitrum, Optimism and Fantom. More chains will inevitably be added in the future, but some agents may need to scan data from chains that are not yet officially supported (could be mainnet or testnet). To achieve this, agents can manually read data from any other chain themselves. This page will describe how to interact with any blockchain using a Javascript example agent. This example builds on the long running task pattern to query the Rinkeby testnet and find transactions with high gas usage. The complete code for this example can be found here . Setting up the RPC endpoint We start by initializing the current Rinkeby block number using the initialize handler: const RINKEBY_RPC_URL = \"https://rinkeby.infura.io/v3/YOUR_API_KEY\"; const rinkebyProvider = new ethers.providers.JsonRpcProvider(RINKEBY_RPC_URL); let currentRinkebyBlockNumber; async function initialize() { currentRinkebyBlockNumber = await rinkebyProvider.getBlockNumber(); } Note that the RPC URL is hardcoded in the agent since it will not be passed in by the scan node. When hardcoding an API key, you probably also want to use obfuscation as shown in the pattern for hiding sensitive data . Scanning blocks Now we can manually fetch blocks from Rinkeby and scan over each one to detect whatever condition we are interested in: async function scanRinkebyBlocks() { isScanningRinkeby = true; const latestRinkebyBlockNumber = await rinkebyProvider.getBlockNumber(); // for each unprocessed block while (currentRinkebyBlockNumber <= latestRinkebyBlockNumber) { // fetch rinkeby block const rinkebyBlock = await rinkebyProvider.getBlock( currentRinkebyBlockNumber ); // fetch receipt for each transaction in block for (const tx of rinkebyBlock.transactions) { const receipt = await rinkebyProvider.getTransactionReceipt(tx); // check if gas usage is higher than 1 million if (receipt.gasUsed.gt(\"1000000\")) { findingsCache.push( Finding.fromObject({ name: \"High gas used\", description: `Transaction with high gas usage: ${receipt.gasUsed.toString()}`, alertId: \"RINK-1\", severity: FindingSeverity.Info, type: FindingType.Info, metadata: { txHash: tx, }, }) ); } } currentRinkebyBlockNumber++; } isScanningRinkeby = false; } The above code fetches block data given a block number which also includes transaction hashes. We then fetch the receipt for each transaction to get its gas usage. If gas usage is higher than 1 million, we add a finding to the findingsCache . The scanRinkebyBlocks function will be invoked by the handleBlock handler (not shown above), which will return any cached findings. Other considerations Since the findings returned will be for a different chain than what the scan node is scanning, the block hash associated to the finding will be incorrect. To get around this, you can store all the information you need from the Rinkeby block/transaction inside the metadata of the finding The cost of the RPC endpoint usage (if any) will be covered by you, the agent developer. This is not the case when consuming data passed in from the scan node itself. Also, there may be multiple instances of your agent running across Forta scan nodes. Keep this in mind when estimating costs of running such an agent The long running task (i.e. scanRinkebyBlocks ) is being triggered from handleBlock in the example, which should fire on average every 15 seconds for Ethereum mainnet. You may want more regular fixed intervals to trigger your task based on the speed of the chain you are querying, in which case you can use the Node.js setInterval function and invoke it from the agent's initialize handler The above example uses a simple flag (i.e. isScanningRinkeby ) to ensure only one task is running, but based on your requirements you may customize this logic further e.g. making sure a minimum amount of time has passed before triggering the next task A minor drawback of this approach is that the developer tools (i.e. CLI commands) are not usable. For instance, you cannot specify a transaction/block from Rinkeby using npm run tx/block . You would have to do this by manually modifying the code. Great! You now have an agent that can scan blocks and transactions from any blockchain whether or not it's officially supported by Forta.","title":"Querying other chains"},{"location":"querying-chains/#querying-other-chains","text":"Forta currently supports scanning on several chains including Ethereum, Polygon, BSC, Avalanche, Arbitrum, Optimism and Fantom. More chains will inevitably be added in the future, but some agents may need to scan data from chains that are not yet officially supported (could be mainnet or testnet). To achieve this, agents can manually read data from any other chain themselves. This page will describe how to interact with any blockchain using a Javascript example agent. This example builds on the long running task pattern to query the Rinkeby testnet and find transactions with high gas usage. The complete code for this example can be found here .","title":"Querying other chains"},{"location":"querying-chains/#setting-up-the-rpc-endpoint","text":"We start by initializing the current Rinkeby block number using the initialize handler: const RINKEBY_RPC_URL = \"https://rinkeby.infura.io/v3/YOUR_API_KEY\"; const rinkebyProvider = new ethers.providers.JsonRpcProvider(RINKEBY_RPC_URL); let currentRinkebyBlockNumber; async function initialize() { currentRinkebyBlockNumber = await rinkebyProvider.getBlockNumber(); } Note that the RPC URL is hardcoded in the agent since it will not be passed in by the scan node. When hardcoding an API key, you probably also want to use obfuscation as shown in the pattern for hiding sensitive data .","title":"Setting up the RPC endpoint"},{"location":"querying-chains/#scanning-blocks","text":"Now we can manually fetch blocks from Rinkeby and scan over each one to detect whatever condition we are interested in: async function scanRinkebyBlocks() { isScanningRinkeby = true; const latestRinkebyBlockNumber = await rinkebyProvider.getBlockNumber(); // for each unprocessed block while (currentRinkebyBlockNumber <= latestRinkebyBlockNumber) { // fetch rinkeby block const rinkebyBlock = await rinkebyProvider.getBlock( currentRinkebyBlockNumber ); // fetch receipt for each transaction in block for (const tx of rinkebyBlock.transactions) { const receipt = await rinkebyProvider.getTransactionReceipt(tx); // check if gas usage is higher than 1 million if (receipt.gasUsed.gt(\"1000000\")) { findingsCache.push( Finding.fromObject({ name: \"High gas used\", description: `Transaction with high gas usage: ${receipt.gasUsed.toString()}`, alertId: \"RINK-1\", severity: FindingSeverity.Info, type: FindingType.Info, metadata: { txHash: tx, }, }) ); } } currentRinkebyBlockNumber++; } isScanningRinkeby = false; } The above code fetches block data given a block number which also includes transaction hashes. We then fetch the receipt for each transaction to get its gas usage. If gas usage is higher than 1 million, we add a finding to the findingsCache . The scanRinkebyBlocks function will be invoked by the handleBlock handler (not shown above), which will return any cached findings.","title":"Scanning blocks"},{"location":"querying-chains/#other-considerations","text":"Since the findings returned will be for a different chain than what the scan node is scanning, the block hash associated to the finding will be incorrect. To get around this, you can store all the information you need from the Rinkeby block/transaction inside the metadata of the finding The cost of the RPC endpoint usage (if any) will be covered by you, the agent developer. This is not the case when consuming data passed in from the scan node itself. Also, there may be multiple instances of your agent running across Forta scan nodes. Keep this in mind when estimating costs of running such an agent The long running task (i.e. scanRinkebyBlocks ) is being triggered from handleBlock in the example, which should fire on average every 15 seconds for Ethereum mainnet. You may want more regular fixed intervals to trigger your task based on the speed of the chain you are querying, in which case you can use the Node.js setInterval function and invoke it from the agent's initialize handler The above example uses a simple flag (i.e. isScanningRinkeby ) to ensure only one task is running, but based on your requirements you may customize this logic further e.g. making sure a minimum amount of time has passed before triggering the next task A minor drawback of this approach is that the developer tools (i.e. CLI commands) are not usable. For instance, you cannot specify a transaction/block from Rinkeby using npm run tx/block . You would have to do this by manually modifying the code. Great! You now have an agent that can scan blocks and transactions from any blockchain whether or not it's officially supported by Forta.","title":"Other considerations"},{"location":"quickstart/","text":"Quick start This guide will explore the basics of creating a Forta Agent project. Prerequisites Before you start, please make sure you have the following: Node.js v12+ (which includes the Node package manager i.e. npm) Python v3.6+ (only if you want to use Python SDK) Docker v20+ Basic understanding of Ethereum and smart contracts Initializing a project To initialize a Forta Agent project, you can use the Forta Hardhat plugin or the forta-agent CLI tool: $ mkdir my-new-agent $ cd my-new-agent $ npx forta-agent@latest init --typescript The above snippet creates a new project directory called my-new-agent , and then uses npx (a package runner tool that is part of npm 5.2+) to invoke the init command of the forta-agent CLI tool. By passing the --typescript option, you can initialize a Typescript project (default is Javascript, and --python is also an option). Using @latest version We recommend always initializing projects with @latest version to ensure you have the latest and greatest SDK features. Otherwise, you may end up using an older previously cached version. The init command will initialize a forta.config.json and a keyfile for you in the ~/.forta folder (you will be prompted for a password for the keyfile). The forta.config.json file will be used throughout the development lifecycle of your agents. Several files will also be created inside of your project folder, including a package.json file, tsconfig.json (for Typescript) and a src folder. Dependencies of the project will also be installed by running npm install . Protecting your keyfile Make sure you do not forget the password for your keyfile as we have no way to recover it! We also recommend keeping a backup of it. The keyfile is located in the ~/.forta folder and named in the format UTC--<created_at UTC ISO8601>--<address hex> (an example name would be UTC--2021-07-12T01:37:55.270Z--577022b59d1c25623ac523fe78d2f6347b5c69f2 ). This keyfile will primarily be used for publishing your agent. You can get the absolute path to your keyfile using the npm run keyfile command from the project folder. Awesome! You have successfully completed setting up your project. See below for ideas/examples of agents, or continue to testing your agent . Ideas for agents We\u2019re excited to see what sort of innovative agents the community comes up with! A good place to start is to choose a specific protocol that you use or love to build agents for. You could also choose based on TVL ranking as listed on DeFi Pulse . If you\u2019re looking for some inspiration to get started, here are possible ideas for agents: Detect admin functions Detect high gas transactions Detect ownership transfers of contracts Detect high volume of failed transactions from an account Detect flash loan attacks Detect sandwich attacks Detect when an oracle is returning bad values Detect transactions from a known list of blacklisted addresses Be sure to check out Useful libraries for developing your agents, including a set of low-code templates you can use. To learn more about what makes a good agent, see our FAQ section. Examples You can find some example implementations of Forta Agents in our examples repo . Another great place to see real agents in action is on the Forta App Discover page.","title":"1) Quick start"},{"location":"quickstart/#quick-start","text":"This guide will explore the basics of creating a Forta Agent project.","title":"Quick start"},{"location":"quickstart/#prerequisites","text":"Before you start, please make sure you have the following: Node.js v12+ (which includes the Node package manager i.e. npm) Python v3.6+ (only if you want to use Python SDK) Docker v20+ Basic understanding of Ethereum and smart contracts","title":"Prerequisites"},{"location":"quickstart/#initializing-a-project","text":"To initialize a Forta Agent project, you can use the Forta Hardhat plugin or the forta-agent CLI tool: $ mkdir my-new-agent $ cd my-new-agent $ npx forta-agent@latest init --typescript The above snippet creates a new project directory called my-new-agent , and then uses npx (a package runner tool that is part of npm 5.2+) to invoke the init command of the forta-agent CLI tool. By passing the --typescript option, you can initialize a Typescript project (default is Javascript, and --python is also an option). Using @latest version We recommend always initializing projects with @latest version to ensure you have the latest and greatest SDK features. Otherwise, you may end up using an older previously cached version. The init command will initialize a forta.config.json and a keyfile for you in the ~/.forta folder (you will be prompted for a password for the keyfile). The forta.config.json file will be used throughout the development lifecycle of your agents. Several files will also be created inside of your project folder, including a package.json file, tsconfig.json (for Typescript) and a src folder. Dependencies of the project will also be installed by running npm install . Protecting your keyfile Make sure you do not forget the password for your keyfile as we have no way to recover it! We also recommend keeping a backup of it. The keyfile is located in the ~/.forta folder and named in the format UTC--<created_at UTC ISO8601>--<address hex> (an example name would be UTC--2021-07-12T01:37:55.270Z--577022b59d1c25623ac523fe78d2f6347b5c69f2 ). This keyfile will primarily be used for publishing your agent. You can get the absolute path to your keyfile using the npm run keyfile command from the project folder. Awesome! You have successfully completed setting up your project. See below for ideas/examples of agents, or continue to testing your agent .","title":"Initializing a project"},{"location":"quickstart/#ideas-for-agents","text":"We\u2019re excited to see what sort of innovative agents the community comes up with! A good place to start is to choose a specific protocol that you use or love to build agents for. You could also choose based on TVL ranking as listed on DeFi Pulse . If you\u2019re looking for some inspiration to get started, here are possible ideas for agents: Detect admin functions Detect high gas transactions Detect ownership transfers of contracts Detect high volume of failed transactions from an account Detect flash loan attacks Detect sandwich attacks Detect when an oracle is returning bad values Detect transactions from a known list of blacklisted addresses Be sure to check out Useful libraries for developing your agents, including a set of low-code templates you can use. To learn more about what makes a good agent, see our FAQ section.","title":"Ideas for agents"},{"location":"quickstart/#examples","text":"You can find some example implementations of Forta Agents in our examples repo . Another great place to see real agents in action is on the Forta App Discover page.","title":"Examples"},{"location":"scanner-quickstart/","text":"Run a Scan Node Early Decentralization Phase At this phase, only Forta-approved nodes are allowed onto the network. In later phases, Forta will introduce economic security measures that will allow permissionless scan nodes. Scan Node Requirements The following are the requirements for running a Forta scan node. 64-bit Linux distribution CPU with 4+ cores 16GB RAM Connection to Internet Docker v20.10+ Recommended: Ethereum Light Node Install and Configure Geth Light Node Install Geth Geth Be sure to set --http.vhosts to allow hostname access, and enable eth,net,web3 http apis. Example execution geth --http.vhosts '*' --mainnet --syncmode \"light\" --http --http.port 8545 --http.addr 0.0.0.0 --http.corsdomain '*' --http.api 'eth,net,web3' Install and Configure Docker Install Docker (at least v20.10) Add a file called daemon.json to your /etc/docker directory with the following contents: { \"default-address-pools\": [ { \"base\":\"172.17.0.0/12\", \"size\":16 }, { \"base\":\"192.168.0.0/16\", \"size\":20 }, { \"base\":\"10.99.0.0/16\", \"size\":24 } ] } Restart docker with systemctl restart docker Ensure docker is running. You can run docker ps and you should not get any errors and see a list of header columns. Run Docker as a non-root user To run docker as a non-root user, do the following: Add the docker group (it may already exist) sudo groupadd docker Add your user to that group. sudo usermod -aG docker your-user You must exit and login again to take effect Make sure Docker is running Once docker ps gives you a list of headers, continue to the next section. Install Forta The Forta scan node software is available for popular 64-bit Linux distributions using official Forta repositories. Package installation methods are verifiable (auto-verified during installation) and help you install required dependencies. Install via YUM (CentOS, Fedora, Red Hat Enterprise Linux etc.) $ sudo curl https://dist.forta.network/repositories/yum/Forta.repo -o /etc/yum.repos.d/Forta.repo -s $ sudo yum install forta Install via APT (Ubuntu, Debian etc.) $ sudo curl https://dist.forta.network/pgp.public -o /usr/share/keyrings/forta-keyring.asc -s $ echo 'deb [signed-by=/usr/share/keyrings/forta-keyring.asc] https://dist.forta.network/repositories/apt stable main' | sudo tee -a /etc/apt/sources.list.d/forta.list $ sudo apt-get update $ sudo apt-get install forta Install Manually Install Docker (at least v20.10) Download the latest x86-64 release binary and install $ sudo curl https://dist.forta.network/artifacts/forta -o /usr/local/bin/forta Make the binary executable $ sudo chmod 755 /usr/local/bin/forta Initial Setup Forta scan node's CLI allows you to set up your first Forta configuration directory along with creating and managing your scan node's private key. Initialize Forta Directory Initialization creates a private key that will sign the alerts from your scan node. You must set the $FORTA_PASSPHRASE environment variable or provide the --passphrase flag to the init command. Initialize Forta using the forta init command $ forta init --passphrase <your_passphrase> This generates a config directory, a private key, and output your address Scanner address: 0xAAA8C491232cB65a65FBf7F36b71220B3E695AAA Successfully initialized at /yourname/.forta Take note of the address. This is the value that will be registered in the scan node registry smart contract. Forta Directory By default, the forta directory is located in ~/.forta . If you would like to use a different directory, either set the $FORTA_DIR env var or provide the --dir flag to the init command. Init command will initialize your Forta configuration and key to this directory. Configure systemd If the binary ever stops, it must be restarted. If you used a package installation method, there is a Forta systemd service that can be enabled and overridden with your passphrase and config directory environment variables. To override systemd service environment, you can set the variables in /etc/systemd/system/forta.service.d/env.conf like: [Service] Environment=\"FORTA_DIR=<your_forta_config_dir>\" Environment=\"FORTA_PASSPHRASE=<your_forta_passphrase>\" Configure config.yml In your Forta directory, there now is a config.yml file. You must configure that file so that your scan node knows how to get its blockchain data. Your scan node is registered to scan a single chain. To let your scan node pull chain data, you need to provide a valid scan.jsonRpc.url . Public JSON-RPC APIs While there are public endpoints available for many chains, please note that the quality of an endpoint drives the quality of a scan node's output which in turn affects rewards and slashing. We strongly recommend providing your own blockchain node or using a paid provider when possible. If you are scanning Ethereum mainnet, trace.jsonRpc.url must also be set as an endpoint that supports trace_block method from the Parity Trace API. If you have your own Ethereum node, you can use that node. JSON-RPC APIs The scan node will request every transaction on a target chain, which can add up to a lot of requests. Ensure your endpoints can accept the appropriate level of traffic. We suggest running your own Ethereum light node for the scan.jsonRpc.url and an Alchemy Growth plan for trace.jsonRpc.url endpoint. If your node is scanning chains other than Ethereum mainnet, please checkout the final section to see options. Example configuration to scan Ethereum mainnet: chainId: 1 # The scan settings are used to retrieve the transactions that are analyzed scan: jsonRpc: url: https://mainnet.infura.io/v3/KEY # The trace endpoint must support trace_block (such as alchemy) trace: jsonRpc: url: https://eth-mainnet.alchemyapi.io/v2/KEY Register Scan Node Please contact the Forta team and provide your node address. Once approved, we will add your node to the Forta network. Early Decentralization Phase At this phase, only Forta-approved nodes are allowed onto the network. In later phases, Forta will introduce economic security measures that will allow permissionless scan nodes. Run Scan Node Start Docker Ensure Docker is running use the docker command docker ps . If it is not running, start docker before running Forta. Start Forta via systemd Run the systemd service to start Forta sudo systemctl enable forta sudo systemctl start forta Start Forta manually Run the forta run command to start processing blocks. $ forta run --passphrase <your_passphrase> Verify Execution Run forta status command to see how your scanner is doing. As more services start, this status output will be dynamically updated. If you see any yellows or reds, please check the error messages, your config and your machine's network connectivity. If you can't make any sense of it, please let us know. You can also view the forta-publisher logs for batches of alerts. $ docker logs -f forta-publisher Agent Assignments Your scan node might not have any agents assigned. This is okay. As agents are added to the network, the network will assign agents to your node. To see a list of agents that the node is running, use this command. $ docker ps | grep forta-agent Scanning other chains It's best to use your own full node for scanning. If you don't have a node, here are some API alternatives that you can use: BSC You can choose from public BSC endpoints at https://docs.binance.org/smart-chain/developer/rpc.html. chainId: 56 scan: jsonRpc: url: https://bsc-dataseed.binance.org/ trace: enabled: false Polygon chainId: 137 scan: jsonRpc: url: https://polygon-rpc.com/ trace: enabled: false Avalanche chainId: 43114 scan: jsonRpc: url: https://api.avax.network/ext/bc/C/rpc trace: enabled: false Arbitrum chainId: 42161 scan: jsonRpc: url: https://arb1.arbitrum.io/rpc trace: enabled: false Optimism chainId: 10 scan: jsonRpc: url: https://mainnet.optimism.io trace: enabled: false Monitor SLA To monitor whether your scan node is performing well, use the SLA-API","title":"Quickstart"},{"location":"scanner-quickstart/#run-a-scan-node","text":"Early Decentralization Phase At this phase, only Forta-approved nodes are allowed onto the network. In later phases, Forta will introduce economic security measures that will allow permissionless scan nodes.","title":"Run a Scan Node"},{"location":"scanner-quickstart/#scan-node-requirements","text":"The following are the requirements for running a Forta scan node. 64-bit Linux distribution CPU with 4+ cores 16GB RAM Connection to Internet Docker v20.10+ Recommended: Ethereum Light Node","title":"Scan Node Requirements"},{"location":"scanner-quickstart/#install-and-configure-geth-light-node","text":"Install Geth Geth Be sure to set --http.vhosts to allow hostname access, and enable eth,net,web3 http apis. Example execution geth --http.vhosts '*' --mainnet --syncmode \"light\" --http --http.port 8545 --http.addr 0.0.0.0 --http.corsdomain '*' --http.api 'eth,net,web3'","title":"Install and Configure Geth Light Node"},{"location":"scanner-quickstart/#install-and-configure-docker","text":"Install Docker (at least v20.10) Add a file called daemon.json to your /etc/docker directory with the following contents: { \"default-address-pools\": [ { \"base\":\"172.17.0.0/12\", \"size\":16 }, { \"base\":\"192.168.0.0/16\", \"size\":20 }, { \"base\":\"10.99.0.0/16\", \"size\":24 } ] } Restart docker with systemctl restart docker Ensure docker is running. You can run docker ps and you should not get any errors and see a list of header columns. Run Docker as a non-root user To run docker as a non-root user, do the following: Add the docker group (it may already exist) sudo groupadd docker Add your user to that group. sudo usermod -aG docker your-user You must exit and login again to take effect Make sure Docker is running Once docker ps gives you a list of headers, continue to the next section.","title":"Install and Configure Docker"},{"location":"scanner-quickstart/#install-forta","text":"The Forta scan node software is available for popular 64-bit Linux distributions using official Forta repositories. Package installation methods are verifiable (auto-verified during installation) and help you install required dependencies.","title":"Install Forta"},{"location":"scanner-quickstart/#install-via-yum-centos-fedora-red-hat-enterprise-linux-etc","text":"$ sudo curl https://dist.forta.network/repositories/yum/Forta.repo -o /etc/yum.repos.d/Forta.repo -s $ sudo yum install forta","title":"Install via YUM (CentOS, Fedora, Red Hat Enterprise Linux etc.)"},{"location":"scanner-quickstart/#install-via-apt-ubuntu-debian-etc","text":"$ sudo curl https://dist.forta.network/pgp.public -o /usr/share/keyrings/forta-keyring.asc -s $ echo 'deb [signed-by=/usr/share/keyrings/forta-keyring.asc] https://dist.forta.network/repositories/apt stable main' | sudo tee -a /etc/apt/sources.list.d/forta.list $ sudo apt-get update $ sudo apt-get install forta","title":"Install via APT (Ubuntu, Debian etc.)"},{"location":"scanner-quickstart/#install-manually","text":"Install Docker (at least v20.10) Download the latest x86-64 release binary and install $ sudo curl https://dist.forta.network/artifacts/forta -o /usr/local/bin/forta Make the binary executable $ sudo chmod 755 /usr/local/bin/forta","title":"Install Manually"},{"location":"scanner-quickstart/#initial-setup","text":"Forta scan node's CLI allows you to set up your first Forta configuration directory along with creating and managing your scan node's private key.","title":"Initial Setup"},{"location":"scanner-quickstart/#initialize-forta-directory","text":"Initialization creates a private key that will sign the alerts from your scan node. You must set the $FORTA_PASSPHRASE environment variable or provide the --passphrase flag to the init command. Initialize Forta using the forta init command $ forta init --passphrase <your_passphrase> This generates a config directory, a private key, and output your address Scanner address: 0xAAA8C491232cB65a65FBf7F36b71220B3E695AAA Successfully initialized at /yourname/.forta Take note of the address. This is the value that will be registered in the scan node registry smart contract. Forta Directory By default, the forta directory is located in ~/.forta . If you would like to use a different directory, either set the $FORTA_DIR env var or provide the --dir flag to the init command. Init command will initialize your Forta configuration and key to this directory.","title":"Initialize Forta Directory"},{"location":"scanner-quickstart/#configure-systemd","text":"If the binary ever stops, it must be restarted. If you used a package installation method, there is a Forta systemd service that can be enabled and overridden with your passphrase and config directory environment variables. To override systemd service environment, you can set the variables in /etc/systemd/system/forta.service.d/env.conf like: [Service] Environment=\"FORTA_DIR=<your_forta_config_dir>\" Environment=\"FORTA_PASSPHRASE=<your_forta_passphrase>\"","title":"Configure systemd"},{"location":"scanner-quickstart/#configure-configyml","text":"In your Forta directory, there now is a config.yml file. You must configure that file so that your scan node knows how to get its blockchain data. Your scan node is registered to scan a single chain. To let your scan node pull chain data, you need to provide a valid scan.jsonRpc.url . Public JSON-RPC APIs While there are public endpoints available for many chains, please note that the quality of an endpoint drives the quality of a scan node's output which in turn affects rewards and slashing. We strongly recommend providing your own blockchain node or using a paid provider when possible. If you are scanning Ethereum mainnet, trace.jsonRpc.url must also be set as an endpoint that supports trace_block method from the Parity Trace API. If you have your own Ethereum node, you can use that node. JSON-RPC APIs The scan node will request every transaction on a target chain, which can add up to a lot of requests. Ensure your endpoints can accept the appropriate level of traffic. We suggest running your own Ethereum light node for the scan.jsonRpc.url and an Alchemy Growth plan for trace.jsonRpc.url endpoint. If your node is scanning chains other than Ethereum mainnet, please checkout the final section to see options. Example configuration to scan Ethereum mainnet: chainId: 1 # The scan settings are used to retrieve the transactions that are analyzed scan: jsonRpc: url: https://mainnet.infura.io/v3/KEY # The trace endpoint must support trace_block (such as alchemy) trace: jsonRpc: url: https://eth-mainnet.alchemyapi.io/v2/KEY","title":"Configure config.yml"},{"location":"scanner-quickstart/#register-scan-node","text":"Please contact the Forta team and provide your node address. Once approved, we will add your node to the Forta network. Early Decentralization Phase At this phase, only Forta-approved nodes are allowed onto the network. In later phases, Forta will introduce economic security measures that will allow permissionless scan nodes.","title":"Register Scan Node"},{"location":"scanner-quickstart/#run-scan-node","text":"","title":"Run Scan Node"},{"location":"scanner-quickstart/#start-docker","text":"Ensure Docker is running use the docker command docker ps . If it is not running, start docker before running Forta.","title":"Start Docker"},{"location":"scanner-quickstart/#start-forta-via-systemd","text":"Run the systemd service to start Forta sudo systemctl enable forta sudo systemctl start forta","title":"Start Forta via systemd"},{"location":"scanner-quickstart/#start-forta-manually","text":"Run the forta run command to start processing blocks. $ forta run --passphrase <your_passphrase>","title":"Start Forta manually"},{"location":"scanner-quickstart/#verify-execution","text":"Run forta status command to see how your scanner is doing. As more services start, this status output will be dynamically updated. If you see any yellows or reds, please check the error messages, your config and your machine's network connectivity. If you can't make any sense of it, please let us know. You can also view the forta-publisher logs for batches of alerts. $ docker logs -f forta-publisher Agent Assignments Your scan node might not have any agents assigned. This is okay. As agents are added to the network, the network will assign agents to your node. To see a list of agents that the node is running, use this command. $ docker ps | grep forta-agent","title":"Verify Execution"},{"location":"scanner-quickstart/#scanning-other-chains","text":"It's best to use your own full node for scanning. If you don't have a node, here are some API alternatives that you can use:","title":"Scanning other chains"},{"location":"scanner-quickstart/#bsc","text":"You can choose from public BSC endpoints at https://docs.binance.org/smart-chain/developer/rpc.html. chainId: 56 scan: jsonRpc: url: https://bsc-dataseed.binance.org/ trace: enabled: false","title":"BSC"},{"location":"scanner-quickstart/#polygon","text":"chainId: 137 scan: jsonRpc: url: https://polygon-rpc.com/ trace: enabled: false","title":"Polygon"},{"location":"scanner-quickstart/#avalanche","text":"chainId: 43114 scan: jsonRpc: url: https://api.avax.network/ext/bc/C/rpc trace: enabled: false","title":"Avalanche"},{"location":"scanner-quickstart/#arbitrum","text":"chainId: 42161 scan: jsonRpc: url: https://arb1.arbitrum.io/rpc trace: enabled: false","title":"Arbitrum"},{"location":"scanner-quickstart/#optimism","text":"chainId: 10 scan: jsonRpc: url: https://mainnet.optimism.io trace: enabled: false","title":"Optimism"},{"location":"scanner-quickstart/#monitor-sla","text":"To monitor whether your scan node is performing well, use the SLA-API","title":"Monitor SLA"},{"location":"sdk/","text":"Javascript/Typescript SDK The Forta Agent Javascript SDK comes with a set of classes and type definitions to provide a consistent interface for developers to write their agents. There are also some utility functions available for your convenience to do common operations like searching for an event in a transaction receipt. Check out the Javascript/Typescript agents in our examples repo to learn more. Handlers The most relevant type definitions for agent developers are the handler types: Initialize , HandleBlock and HandleTransaction . They are function types with the following signatures type Initialize = () => Promise<void> type HandleTransaction = (txEvent: TransactionEvent) => Promise<Finding[]> type HandleBlock = (blockEvent: BlockEvent) => Promise<Finding[]> Your agent.js / agent.ts file must have a default export object with the handleBlock and/or handleTransaction properties that provide the handler functions. You can export one or both of these depending on your use case, but at least one must be provided. The return type of these functions is Promise<Finding[]> , meaning they are asynchronous functions that return an array of zero or more Finding objects. You can also optionally export an initialize handler that will be executed on agent startup. This is useful for fetching some data from the network or parsing some file before your agent begins. BlockEvent When a block is mined and detected by a Forta scan node, it will generate a BlockEvent containing information such as the block hash and block number. It contains the following fields: type - specifies whether this was a block reorg or a regular block network - specifies which network the block was mined on (e.g. mainnet, ropsten, rinkeby, etc) blockHash - hash of the block blockNumber - number of the block block - data object containing the following fields: difficulty extraData gasLimit gasUsed hash logsBloom miner mixHash nonce number parentHash receiptsRoot sha3Uncles size stateRoot timestamp totalDifficulty transactions transactionsRoot uncles TransactionEvent When a transaction is mined and detected by a Forta scan node, it will generate a TransactionEvent containing various information about the transaction. It contains the following fields: type - specifies whether this was from a block reorg or a regular block network - specifies which network the transaction was mined on (e.g. mainnet, ropsten, rinkeby, etc) hash - alias for transaction.hash from - alias for transaction.from to - alias for transaction.to gasPrice - alias for transaction.gasPrice gasUsed - alias for receipt.gasUsed status - alias for receipt.status logs - alias for receipt.logs timestamp - alias for block.timestamp blockNumber - alias for block.number blockHash - alias for block.hash addresses - map of addresses involved in the transaction (generated from transaction to/from address, any event log address and trace data address if available) block - data object containing following fields: hash number timestamp transaction - data object containing the following fields: hash from to nonce gas gasPrice value data r s v receipt - receipt object containing the following fields: status root gasUsed cumulativeGasUsed logsBloom contractAddress blockNumber blockHash transactionIndex transactionHash logs - list of log objects with following fields: address topics data logIndex blockNumber blockHash transactionIndex transactionHash removed traces - only with tracing enabled; list of trace objects with following fields: blockHash blockNumber subtraces traceAddress transactionHash transactionPosition type error action - object with following fields: callType to from input value init address balance refundAddress result - object with following fields: gasUsed address code output filterLog filterLog is a convenience function on TransactionEvent to filter and decode transaction logs. For example, you can use it to get all of the Transfer logs in a transaction from a particular ERC-20 token: const erc20TokenAddress = \"0x123abc\"; const transferEvent = \"event Transfer(address indexed from, address indexed to, uint256 value)\"; const transfers = transactionEvent.filterLog(transferEvent, erc20TokenAddress); console.log(`found ${transfers.length} transfer events`); The underlying library used for decoding event logs is ethers.js . The Javascript SDK uses the ethers.js parseLog method and returns an array of LogDescription objects (which we modified to also include the originating address of the log). To better understand usage, see the Javascript filtering example agent. filterFunction filterFunction is a convenience function on TransactionEvent to filter and decode function calls in the transaction or traces. For example, you can use it to get all of the transferFrom function calls on a particular ERC-20 token: const erc20TokenAddress = \"0x123abc\"; const transferFromFunction = \"function transferFrom(address from, address to, uint value)\"; const transfers = transactionEvent.filterFunction(transferFromFunction, erc20TokenAddress); console.log(`found ${transfers.length} function calls`); The underlying library used for decoding function calls is ethers.js . The Javascript SDK uses the ethers.js parseTransaction method and returns an array of TransactionDescription objects. To better understand usage, see the Javascript filtering example agent. Finding If an agent wants to flag a transaction/block because it meets some condition (e.g. flash loan attack), the handler function would return a Finding object. This object would detail the results of the finding and provide metadata such as the severity of the finding. A Finding object can only be created using the Finding.fromObject method which accepts the following properties: name - required ; human-readable name of finding e.g. \"High Gas\" description - required ; brief description e.g. \"High gas used: 1,000,000\" alertId - required ; unique string to identify this class of finding, primarily used to group similar findings for the end user protocol - required ; name of protocol being reported on e.g. \"aave\", defaults to \"ethereum\" if left blank type - required ; indicates type of finding: Exploit Suspicious Degraded Info severity - required ; indicates impact level of finding: Critical - exploitable vulnerabilities, massive impact on users/funds High - exploitable under more specific conditions, significant impact on users/funds Medium - notable unexpected behaviours, moderate to low impact on users/funds Low - minor oversights, negligible impact on users/funds Info - miscellaneous behaviours worth describing metadata - optional; key-value map (both keys and values as strings) for providing extra information getJsonRpcUrl A convenience function called getJsonRpcUrl can be used to load a JSON-RPC URL for your agent. When running in production, this function will return a URL injected by the scan node that is running the agent. When running locally in development, this function will return the jsonRpcUrl property specified in your forta.config.json file. getEthersProvider getEthersProvider is a convenience function that returns an ethers.js Provider which can be used to interact with the blockchain. The value from getJsonRpcUrl will be used as the JSON-RPC endpoint to connect to. createBlockEvent A utility function for writing tests. You can use createBlockEvent to easily generate a mock BlockEvent object when writing unit tests for your handleBlock handler. To better understand usage, see the Typescript unit test example . createTransactionEvent A utility function for writing tests. You can use createTransactionEvent to easily generate a mock TransactionEvent object when writing unit tests for your handleTransaction handler. To better understand usage, see the Javascript unit test example .","title":"Javascript/Typescript SDK"},{"location":"sdk/#javascripttypescript-sdk","text":"The Forta Agent Javascript SDK comes with a set of classes and type definitions to provide a consistent interface for developers to write their agents. There are also some utility functions available for your convenience to do common operations like searching for an event in a transaction receipt. Check out the Javascript/Typescript agents in our examples repo to learn more.","title":"Javascript/Typescript SDK"},{"location":"sdk/#handlers","text":"The most relevant type definitions for agent developers are the handler types: Initialize , HandleBlock and HandleTransaction . They are function types with the following signatures type Initialize = () => Promise<void> type HandleTransaction = (txEvent: TransactionEvent) => Promise<Finding[]> type HandleBlock = (blockEvent: BlockEvent) => Promise<Finding[]> Your agent.js / agent.ts file must have a default export object with the handleBlock and/or handleTransaction properties that provide the handler functions. You can export one or both of these depending on your use case, but at least one must be provided. The return type of these functions is Promise<Finding[]> , meaning they are asynchronous functions that return an array of zero or more Finding objects. You can also optionally export an initialize handler that will be executed on agent startup. This is useful for fetching some data from the network or parsing some file before your agent begins.","title":"Handlers"},{"location":"sdk/#blockevent","text":"When a block is mined and detected by a Forta scan node, it will generate a BlockEvent containing information such as the block hash and block number. It contains the following fields: type - specifies whether this was a block reorg or a regular block network - specifies which network the block was mined on (e.g. mainnet, ropsten, rinkeby, etc) blockHash - hash of the block blockNumber - number of the block block - data object containing the following fields: difficulty extraData gasLimit gasUsed hash logsBloom miner mixHash nonce number parentHash receiptsRoot sha3Uncles size stateRoot timestamp totalDifficulty transactions transactionsRoot uncles","title":"BlockEvent"},{"location":"sdk/#transactionevent","text":"When a transaction is mined and detected by a Forta scan node, it will generate a TransactionEvent containing various information about the transaction. It contains the following fields: type - specifies whether this was from a block reorg or a regular block network - specifies which network the transaction was mined on (e.g. mainnet, ropsten, rinkeby, etc) hash - alias for transaction.hash from - alias for transaction.from to - alias for transaction.to gasPrice - alias for transaction.gasPrice gasUsed - alias for receipt.gasUsed status - alias for receipt.status logs - alias for receipt.logs timestamp - alias for block.timestamp blockNumber - alias for block.number blockHash - alias for block.hash addresses - map of addresses involved in the transaction (generated from transaction to/from address, any event log address and trace data address if available) block - data object containing following fields: hash number timestamp transaction - data object containing the following fields: hash from to nonce gas gasPrice value data r s v receipt - receipt object containing the following fields: status root gasUsed cumulativeGasUsed logsBloom contractAddress blockNumber blockHash transactionIndex transactionHash logs - list of log objects with following fields: address topics data logIndex blockNumber blockHash transactionIndex transactionHash removed traces - only with tracing enabled; list of trace objects with following fields: blockHash blockNumber subtraces traceAddress transactionHash transactionPosition type error action - object with following fields: callType to from input value init address balance refundAddress result - object with following fields: gasUsed address code output","title":"TransactionEvent"},{"location":"sdk/#filterlog","text":"filterLog is a convenience function on TransactionEvent to filter and decode transaction logs. For example, you can use it to get all of the Transfer logs in a transaction from a particular ERC-20 token: const erc20TokenAddress = \"0x123abc\"; const transferEvent = \"event Transfer(address indexed from, address indexed to, uint256 value)\"; const transfers = transactionEvent.filterLog(transferEvent, erc20TokenAddress); console.log(`found ${transfers.length} transfer events`); The underlying library used for decoding event logs is ethers.js . The Javascript SDK uses the ethers.js parseLog method and returns an array of LogDescription objects (which we modified to also include the originating address of the log). To better understand usage, see the Javascript filtering example agent.","title":"filterLog"},{"location":"sdk/#filterfunction","text":"filterFunction is a convenience function on TransactionEvent to filter and decode function calls in the transaction or traces. For example, you can use it to get all of the transferFrom function calls on a particular ERC-20 token: const erc20TokenAddress = \"0x123abc\"; const transferFromFunction = \"function transferFrom(address from, address to, uint value)\"; const transfers = transactionEvent.filterFunction(transferFromFunction, erc20TokenAddress); console.log(`found ${transfers.length} function calls`); The underlying library used for decoding function calls is ethers.js . The Javascript SDK uses the ethers.js parseTransaction method and returns an array of TransactionDescription objects. To better understand usage, see the Javascript filtering example agent.","title":"filterFunction"},{"location":"sdk/#finding","text":"If an agent wants to flag a transaction/block because it meets some condition (e.g. flash loan attack), the handler function would return a Finding object. This object would detail the results of the finding and provide metadata such as the severity of the finding. A Finding object can only be created using the Finding.fromObject method which accepts the following properties: name - required ; human-readable name of finding e.g. \"High Gas\" description - required ; brief description e.g. \"High gas used: 1,000,000\" alertId - required ; unique string to identify this class of finding, primarily used to group similar findings for the end user protocol - required ; name of protocol being reported on e.g. \"aave\", defaults to \"ethereum\" if left blank type - required ; indicates type of finding: Exploit Suspicious Degraded Info severity - required ; indicates impact level of finding: Critical - exploitable vulnerabilities, massive impact on users/funds High - exploitable under more specific conditions, significant impact on users/funds Medium - notable unexpected behaviours, moderate to low impact on users/funds Low - minor oversights, negligible impact on users/funds Info - miscellaneous behaviours worth describing metadata - optional; key-value map (both keys and values as strings) for providing extra information","title":"Finding"},{"location":"sdk/#getjsonrpcurl","text":"A convenience function called getJsonRpcUrl can be used to load a JSON-RPC URL for your agent. When running in production, this function will return a URL injected by the scan node that is running the agent. When running locally in development, this function will return the jsonRpcUrl property specified in your forta.config.json file.","title":"getJsonRpcUrl"},{"location":"sdk/#getethersprovider","text":"getEthersProvider is a convenience function that returns an ethers.js Provider which can be used to interact with the blockchain. The value from getJsonRpcUrl will be used as the JSON-RPC endpoint to connect to.","title":"getEthersProvider"},{"location":"sdk/#createblockevent","text":"A utility function for writing tests. You can use createBlockEvent to easily generate a mock BlockEvent object when writing unit tests for your handleBlock handler. To better understand usage, see the Typescript unit test example .","title":"createBlockEvent"},{"location":"sdk/#createtransactionevent","text":"A utility function for writing tests. You can use createTransactionEvent to easily generate a mock TransactionEvent object when writing unit tests for your handleTransaction handler. To better understand usage, see the Javascript unit test example .","title":"createTransactionEvent"},{"location":"sensitive-data/","text":"Hiding sensitive data There are cases where developers need to store sensitive information in their agent (e.g. some API key) or just hide their agent code from the public. While Forta does not currently support storage of secrets (since all agent images are stored in a public repository), developers can still use code obfuscation as a way to hide sensitive data. It should be noted that obfuscation is not the same as encryption, and that obfuscation can potentially be reversed with enough effort. With this in mind, we do not recommend storing high-value secrets in your agents i.e. private keys with lots of funds. However, secrets that can be easily replaced can still be obfuscated (e.g. Etherscan API key). The goal is to deter the average person from opening up your agent image and copy/pasting your secrets. This page will demonstrate how to obfuscate your code using an example Javascript agent. You can find the code for this example here . Obfuscating code In this example, the javascript-obfuscator library is used to obfuscate the agent code, but you can use any library you prefer. An npm script is added to the project to run the obfuscator tool over the code: npm run obfuscate . The script in package.json will look like: \"scripts\": { ... \"obfuscate\": \"javascript-obfuscator ./src --output ./obfuscated --config obfuscation-config.js\" } This will take all of the Javascript files in the src folder and output obfuscated versions of each file with the same name to the obfuscated folder (if using Typescript, you should obfuscate the compiled Javascript files in the dist folder instead of the src folder). The npm script simply invokes the javascript-obfuscator tool with some obfuscation options stored in obfuscation-config.js. It is recommended to obfuscate before building your agent image so that you can verify the results of the obfuscation and make sure it meets your expectations. You can also try running the obfuscated code to verify that it still works by moving the obfuscated files over to the src folder. Please note that the javascript-obfuscator tool can output different results based on the same settings, so be sure to verify that the obfuscated result is good enough for you. If there are any json files in your agent (e.g. ABI.json), consider converting them into Javascript (.js) files so that they also get obfuscated and don't reveal anything about the agent. Make sure that unit tests are also obfuscated, or better yet, just not included in the final image. This could easily reveal what the agent is doing. Obfuscation settings The obfuscation-config.js contains a number of settings for manipulating the code. You may want to tweak these settings in order to further obfuscate your code. There are a few preset options you can experiment with to achieve your desired level of obfuscation. Keep in mind that there will be a tradeoff between obfuscation and performance when tweaking these settings. Be careful if tweaking the obfuscation-config.js settings, as some of the options could potentially break your code. For example, the selfDefending option will prevent your code from running if it is formatted in any way after being obfuscated. See the complete list of options to get a better understanding. Updating the Dockerfile The Dockerfile in the example is slightly modified to copy the obfuscated source code from the obfuscated folder instead of the src folder: ... # copy code over from obfuscated folder COPY /obfuscated ./src ... This will ensure only the obfuscated code gets published in the agent image. Awesome! You now have an obfuscated agent that can store sensitive data in a publicly available image.","title":"Hiding sensitive data"},{"location":"sensitive-data/#hiding-sensitive-data","text":"There are cases where developers need to store sensitive information in their agent (e.g. some API key) or just hide their agent code from the public. While Forta does not currently support storage of secrets (since all agent images are stored in a public repository), developers can still use code obfuscation as a way to hide sensitive data. It should be noted that obfuscation is not the same as encryption, and that obfuscation can potentially be reversed with enough effort. With this in mind, we do not recommend storing high-value secrets in your agents i.e. private keys with lots of funds. However, secrets that can be easily replaced can still be obfuscated (e.g. Etherscan API key). The goal is to deter the average person from opening up your agent image and copy/pasting your secrets. This page will demonstrate how to obfuscate your code using an example Javascript agent. You can find the code for this example here .","title":"Hiding sensitive data"},{"location":"sensitive-data/#obfuscating-code","text":"In this example, the javascript-obfuscator library is used to obfuscate the agent code, but you can use any library you prefer. An npm script is added to the project to run the obfuscator tool over the code: npm run obfuscate . The script in package.json will look like: \"scripts\": { ... \"obfuscate\": \"javascript-obfuscator ./src --output ./obfuscated --config obfuscation-config.js\" } This will take all of the Javascript files in the src folder and output obfuscated versions of each file with the same name to the obfuscated folder (if using Typescript, you should obfuscate the compiled Javascript files in the dist folder instead of the src folder). The npm script simply invokes the javascript-obfuscator tool with some obfuscation options stored in obfuscation-config.js. It is recommended to obfuscate before building your agent image so that you can verify the results of the obfuscation and make sure it meets your expectations. You can also try running the obfuscated code to verify that it still works by moving the obfuscated files over to the src folder. Please note that the javascript-obfuscator tool can output different results based on the same settings, so be sure to verify that the obfuscated result is good enough for you. If there are any json files in your agent (e.g. ABI.json), consider converting them into Javascript (.js) files so that they also get obfuscated and don't reveal anything about the agent. Make sure that unit tests are also obfuscated, or better yet, just not included in the final image. This could easily reveal what the agent is doing.","title":"Obfuscating code"},{"location":"sensitive-data/#obfuscation-settings","text":"The obfuscation-config.js contains a number of settings for manipulating the code. You may want to tweak these settings in order to further obfuscate your code. There are a few preset options you can experiment with to achieve your desired level of obfuscation. Keep in mind that there will be a tradeoff between obfuscation and performance when tweaking these settings. Be careful if tweaking the obfuscation-config.js settings, as some of the options could potentially break your code. For example, the selfDefending option will prevent your code from running if it is formatted in any way after being obfuscated. See the complete list of options to get a better understanding.","title":"Obfuscation settings"},{"location":"sensitive-data/#updating-the-dockerfile","text":"The Dockerfile in the example is slightly modified to copy the obfuscated source code from the obfuscated folder instead of the src folder: ... # copy code over from obfuscated folder COPY /obfuscated ./src ... This will ensure only the obfuscated code gets published in the agent image. Awesome! You now have an obfuscated agent that can store sensitive data in a publicly available image.","title":"Updating the Dockerfile"},{"location":"sla-api/","text":"Scan Node SLA API To evaluate health of nodes in the network, Forta calculates a score (SLA) based on node activity. This score is a 0-1 score where higher is better. This calculation will evolve as more factors are considered. SLA Calculation Scan nodes are expected to continuously scan the latest blocks and submit results (batches). At this time, \"uptime\" is the only factor in SLA. The calculation involves a weighted average of two components: number of batches per minute (weighted x1), and whether the latest evaluated block is falling behind (weighted x5). SLA is calculated periodically for each minute. This means each minute will be assigned a score. At this time, scores are only available for times older than one hour. What's a good score? The score is a fairly raw score, and does not mean a % of time up. A score >90% is generally good. A score of .90 does not mean 10% of the time the node was down. The score is subject to change as the network considers other criteria. Higher is better. API To make this score visible, we now have an API that anyone can call for a given scanner address. Simply curl the API to get a summary report for the period you are interested in. Request URL GET https://api.forta.network/stats/sla/scanner/{scannerAddress} Request Parameters startTime - Start of date range to consider, in RFC3339 (YYYY-MM-DDTHH:MM:SSZ) (Default: 2 hours ago) endTime - End of date range to consider, in RFC3339 (YYYY-MM-DDTHH:MM:SSZ) (Default: 1 hour ago) Example (Most Recent available Hour) https://api.forta.network/stats/sla/scanner/0x58ee631aaef6882a392da1c25486ee181ff1b7d5 Example (The day of 2022-03-06) https://api.forta.network/stats/sla/scanner/0x58ee631aaef6882a392da1c25486ee181ff1b7d5?startTime=2022-03-06T00:00:00Z&endTime=2022-03-07T00:00:00Z Response Fields scannerId - ID of scanner requested startTime - Start time considered for SLA calculations endTime - End time considered for SLA calculations statistics - Score statistics for the period min - Minimum minute-level score for the period max - Maximum minute-level score for the period p50 - 50th Percentile minute-level score for the period avg - Average minute-level score for the period lowestScores - 10 lowest scores for the period (sorted by score ASC) minute - Minute for this minute-level score score - Score for this minute inputs - Inputs considered in the subscores batch_count - Number of batches sent in this minute expected_batch_count - Expected number of batches for the minute latest_block - Latest block sent by scan node in this minute expected_latest_block - 75th Percentile block for all peers for this network scores - Subscores that led to overall score for this minute name - Name of score value - Value of score (0-1) weight - Weight towards overall score Subscores batch_score - 0-1 score for batch_count vs expected_batch_count Score is proportional (4 = 1, 3 = 0.75, 2 = 0.50, 1 = 0.25, 0 = 0) Exceeding also decreases score (4 = 1, 5 = 0.75, 6 = 0.50, 7 = 0.25, 8 = 0) latest_block - 0-1 score for latest_block vs expected_latest_block Full credit for being at or above expected_latest_block (within 100 blocks) Decreases from 1 to 0 if latest_block is below expected_latest_block , until 100 blocks behind (score = 0) Example Response { \"scannerId\": \"0x58ee631aaef6882a392da1c25486ee181ff1b7d5\", \"startTime\": \"2022-03-09T11:05:05.459518321Z\", \"endTime\": \"2022-03-09T12:05:05.459518321Z\", \"statistics\": { \"min\": 1, \"max\": 1, \"p50\": 1, \"avg\": 1 }, \"lowestScores\": [ { \"minute\": \"2022-03-09T11:15:00Z\", \"score\": 1, \"inputs\": { \"batch_count\": 4, \"expected_batch_count\": 4, \"latest_block\": 14352229, \"expected_latest_block\": 14352229 }, \"scores\": [ { \"name\": \"batch_count\", \"value\": 1, \"weight\": 1 }, { \"name\": \"latest_block\", \"value\": 1, \"weight\": 5 } ] }, x 10 ] }","title":"Scan Node SLA API"},{"location":"sla-api/#scan-node-sla-api","text":"To evaluate health of nodes in the network, Forta calculates a score (SLA) based on node activity. This score is a 0-1 score where higher is better. This calculation will evolve as more factors are considered.","title":"Scan Node SLA API"},{"location":"sla-api/#sla-calculation","text":"Scan nodes are expected to continuously scan the latest blocks and submit results (batches). At this time, \"uptime\" is the only factor in SLA. The calculation involves a weighted average of two components: number of batches per minute (weighted x1), and whether the latest evaluated block is falling behind (weighted x5). SLA is calculated periodically for each minute. This means each minute will be assigned a score. At this time, scores are only available for times older than one hour. What's a good score? The score is a fairly raw score, and does not mean a % of time up. A score >90% is generally good. A score of .90 does not mean 10% of the time the node was down. The score is subject to change as the network considers other criteria. Higher is better.","title":"SLA Calculation"},{"location":"sla-api/#api","text":"To make this score visible, we now have an API that anyone can call for a given scanner address. Simply curl the API to get a summary report for the period you are interested in.","title":"API"},{"location":"sla-api/#request","text":"URL GET https://api.forta.network/stats/sla/scanner/{scannerAddress} Request Parameters startTime - Start of date range to consider, in RFC3339 (YYYY-MM-DDTHH:MM:SSZ) (Default: 2 hours ago) endTime - End of date range to consider, in RFC3339 (YYYY-MM-DDTHH:MM:SSZ) (Default: 1 hour ago) Example (Most Recent available Hour) https://api.forta.network/stats/sla/scanner/0x58ee631aaef6882a392da1c25486ee181ff1b7d5 Example (The day of 2022-03-06) https://api.forta.network/stats/sla/scanner/0x58ee631aaef6882a392da1c25486ee181ff1b7d5?startTime=2022-03-06T00:00:00Z&endTime=2022-03-07T00:00:00Z","title":"Request"},{"location":"sla-api/#response","text":"Fields scannerId - ID of scanner requested startTime - Start time considered for SLA calculations endTime - End time considered for SLA calculations statistics - Score statistics for the period min - Minimum minute-level score for the period max - Maximum minute-level score for the period p50 - 50th Percentile minute-level score for the period avg - Average minute-level score for the period lowestScores - 10 lowest scores for the period (sorted by score ASC) minute - Minute for this minute-level score score - Score for this minute inputs - Inputs considered in the subscores batch_count - Number of batches sent in this minute expected_batch_count - Expected number of batches for the minute latest_block - Latest block sent by scan node in this minute expected_latest_block - 75th Percentile block for all peers for this network scores - Subscores that led to overall score for this minute name - Name of score value - Value of score (0-1) weight - Weight towards overall score Subscores batch_score - 0-1 score for batch_count vs expected_batch_count Score is proportional (4 = 1, 3 = 0.75, 2 = 0.50, 1 = 0.25, 0 = 0) Exceeding also decreases score (4 = 1, 5 = 0.75, 6 = 0.50, 7 = 0.25, 8 = 0) latest_block - 0-1 score for latest_block vs expected_latest_block Full credit for being at or above expected_latest_block (within 100 blocks) Decreases from 1 to 0 if latest_block is below expected_latest_block , until 100 blocks behind (score = 0) Example Response { \"scannerId\": \"0x58ee631aaef6882a392da1c25486ee181ff1b7d5\", \"startTime\": \"2022-03-09T11:05:05.459518321Z\", \"endTime\": \"2022-03-09T12:05:05.459518321Z\", \"statistics\": { \"min\": 1, \"max\": 1, \"p50\": 1, \"avg\": 1 }, \"lowestScores\": [ { \"minute\": \"2022-03-09T11:15:00Z\", \"score\": 1, \"inputs\": { \"batch_count\": 4, \"expected_batch_count\": 4, \"latest_block\": 14352229, \"expected_latest_block\": 14352229 }, \"scores\": [ { \"name\": \"batch_count\", \"value\": 1, \"weight\": 1 }, { \"name\": \"latest_block\", \"value\": 1, \"weight\": 5 } ] }, x 10 ] }","title":"Response"},{"location":"subscribing/","text":"Subscribing to alerts Using Forta App You can subscribe to alerts generated by your agent using the Forta App subscriptions page . You will first need to connect your Metamask wallet and sign a message to authenticate. Then you can create subscriptions to an agent ID or a contract address. Forta App currently supports Slack and email notifications with more types of notifications coming in the near future. Check out this quick video tutorial on subscribing to alerts: Once subscribed, this is what a Slack notification would look like: And here is what an email notification would look like: Using OpenZeppelin Defender Alternatively, you could receive alerts using OpenZeppelin Defender , a security operations platform for Ethereum, which has even more types of notifications including email, Slack, Telegram and Discord. Check out their Forta integration docs to learn more. Once you have your alert subscriptions set up, you are ready to learn about maintaining your agent .","title":"4) Subscribing to alerts"},{"location":"subscribing/#subscribing-to-alerts","text":"","title":"Subscribing to alerts"},{"location":"subscribing/#using-forta-app","text":"You can subscribe to alerts generated by your agent using the Forta App subscriptions page . You will first need to connect your Metamask wallet and sign a message to authenticate. Then you can create subscriptions to an agent ID or a contract address. Forta App currently supports Slack and email notifications with more types of notifications coming in the near future. Check out this quick video tutorial on subscribing to alerts: Once subscribed, this is what a Slack notification would look like: And here is what an email notification would look like:","title":"Using Forta App"},{"location":"subscribing/#using-openzeppelin-defender","text":"Alternatively, you could receive alerts using OpenZeppelin Defender , a security operations platform for Ethereum, which has even more types of notifications including email, Slack, Telegram and Discord. Check out their Forta integration docs to learn more. Once you have your alert subscriptions set up, you are ready to learn about maintaining your agent .","title":"Using OpenZeppelin Defender"},{"location":"testing/","text":"Testing your agent Once you have initialized your agent, it\u2019s now time to test it. The code for a simple Forta Agent can be found in the src/agent.ts file. The entry point for your agent will always be a file named agent.ts (or agent.js/agent.py if using Javascript/Python, respectively). At the end of this file, you will find: export default { handleTransaction, handleBlock, }; We are exporting 2 functions inside of an object: handleTransaction and handleBlock . These functions are where the logic of your agent will live. As blocks and transactions are mined to the blockchain, these functions will be invoked with blockchain data to allow the agent to scan for certain conditions and return any findings. You can export either one or both of these functions based on your requirements. Let\u2019s take a closer look at the handleTransaction function: const handleTransaction: HandleTransaction = async ( txEvent: TransactionEvent ) => { const findings: Finding[] = []; // create finding if gas used is higher than threshold const gasUsed = new BigNumber(txEvent.gasUsed); if (gasUsed.isGreaterThan(\"1000000\")) { findings.push( Finding.fromObject({ name: \"High Gas Used\", description: `Gas Used: ${gasUsed}`, alertId: \"FORTA-1\", severity: FindingSeverity.High, type: FindingType.Suspicious, }) ); } return findings; }; The signature of this function is (txEvent: TransactionEvent) => Promise<Finding[]> . That is, it accepts a TransactionEvent as an input, and returns a Promise of an array of Finding objects. In this simple example, we check whether the amount of gas used by a transaction is above 1 million. If so, we flag the transaction as suspicious by creating a Finding object. We then return what we found in the findings array. Pretty straightforward. Manual testing Now let\u2019s run this agent locally with some real data from Ethereum mainnet to see how it behaves. First, let\u2019s specify a JSON-RPC provider in the forta.config.json file (located in ~/.forta). Uncomment the jsonRpcUrl property and set it to a HTTP provider (e.g. https://mainnet.infura.io/v3/YOUR_INFURA_API_KEY). We can begin throwing blockchain data at our agent and observe the output with the command: $ npm start npm scripts The package.json file includes a set of npm scripts which invoke the forta-agent CLI tool. When invoking npm start to run the agent, we are using the forta-agent run command. This will run blocks and transactions against your agent as they are mined. Since our gas threshold is pretty high (1 million), we may not flag a lot of transactions. To quickly make changes and see them take effect, try changing the threshold to a lower number and save the agent.ts file. The agent should automatically restart with your new changes. It is also worth mentioning that agents are long-running processes. This means you can maintain state in-memory across blocks and transactions if needed. See the high volume agent as an example of a stateful agent. Getting test data If you are writing an agent targeting a particular protocol or contract, you likely already have a wealth of data on the blockchain which you can use to test your agent. By visiting a block explorer (e.g. Etherscan ), you can browse the history of transactions on a contract. For example, if you were writing an agent that detects Tether transfers over $100, you can visit the Tether token page on Etherscan and see a list of transfers. From there you can easily pick out a transaction (e.g. 0x338c6d7095228544f27ba8479aea6cadbe5aea98806a651f66ef30b3cd7e1813 ) and run it against your agent using: $ npm run tx 0x338c6d7095228544f27ba8479aea6cadbe5aea98806a651f66ef30b3cd7e1813 You could also run your agent against all the transactions in a block using: $ npm run block 13682565 Also, if you visit the transaction's details page on Etherscan, you can see more information such as the block number, amount of gas used and which function was invoked. The logs generated by the transaction can also be viewed under the Logs tab . Automated testing A complete agent testing strategy will include automated unit tests that can quickly verify the behaviour of the agent. For your convenience, unit tests are included in the starter projects as examples. We use the jest testing framework in the Javascript/Typescript projects, and pytest in the Python project. These are only suggestions and you should feel free to use whichever testing framework you prefer. You can run the included unit tests with the following command: $ npm test When writing unit tests, you can easily create mock transactions and blocks using the SDK methods createTransactionEvent and createBlockEvent . See here for an example. Also, you can easily write tests for agents that detect log events or function calls by mocking out the SDK methods filterLog and filterFunction . See here for an example. Advanced testing For more advanced testing involving simulated transactions, check out the Advanced testing pattern. Code review We strongly recommend conducting code reviews within your team as a best practice. This will help ensure that any bugs are identified and any edge cases are covered by your agent. Best practices To learn more about agent development best practices, see the Best practices section. Be sure to check out Useful libraries for developing your agents as well. There are also sections describing more advanced agent patterns like hiding sensitive data , publishing private alerts , transaction simulation and querying other chains . Once you have tested and reviewed your agent, you can move on to deploying your agent .","title":"2) Testing your agent"},{"location":"testing/#testing-your-agent","text":"Once you have initialized your agent, it\u2019s now time to test it. The code for a simple Forta Agent can be found in the src/agent.ts file. The entry point for your agent will always be a file named agent.ts (or agent.js/agent.py if using Javascript/Python, respectively). At the end of this file, you will find: export default { handleTransaction, handleBlock, }; We are exporting 2 functions inside of an object: handleTransaction and handleBlock . These functions are where the logic of your agent will live. As blocks and transactions are mined to the blockchain, these functions will be invoked with blockchain data to allow the agent to scan for certain conditions and return any findings. You can export either one or both of these functions based on your requirements. Let\u2019s take a closer look at the handleTransaction function: const handleTransaction: HandleTransaction = async ( txEvent: TransactionEvent ) => { const findings: Finding[] = []; // create finding if gas used is higher than threshold const gasUsed = new BigNumber(txEvent.gasUsed); if (gasUsed.isGreaterThan(\"1000000\")) { findings.push( Finding.fromObject({ name: \"High Gas Used\", description: `Gas Used: ${gasUsed}`, alertId: \"FORTA-1\", severity: FindingSeverity.High, type: FindingType.Suspicious, }) ); } return findings; }; The signature of this function is (txEvent: TransactionEvent) => Promise<Finding[]> . That is, it accepts a TransactionEvent as an input, and returns a Promise of an array of Finding objects. In this simple example, we check whether the amount of gas used by a transaction is above 1 million. If so, we flag the transaction as suspicious by creating a Finding object. We then return what we found in the findings array. Pretty straightforward.","title":"Testing your agent"},{"location":"testing/#manual-testing","text":"Now let\u2019s run this agent locally with some real data from Ethereum mainnet to see how it behaves. First, let\u2019s specify a JSON-RPC provider in the forta.config.json file (located in ~/.forta). Uncomment the jsonRpcUrl property and set it to a HTTP provider (e.g. https://mainnet.infura.io/v3/YOUR_INFURA_API_KEY). We can begin throwing blockchain data at our agent and observe the output with the command: $ npm start npm scripts The package.json file includes a set of npm scripts which invoke the forta-agent CLI tool. When invoking npm start to run the agent, we are using the forta-agent run command. This will run blocks and transactions against your agent as they are mined. Since our gas threshold is pretty high (1 million), we may not flag a lot of transactions. To quickly make changes and see them take effect, try changing the threshold to a lower number and save the agent.ts file. The agent should automatically restart with your new changes. It is also worth mentioning that agents are long-running processes. This means you can maintain state in-memory across blocks and transactions if needed. See the high volume agent as an example of a stateful agent.","title":"Manual testing"},{"location":"testing/#getting-test-data","text":"If you are writing an agent targeting a particular protocol or contract, you likely already have a wealth of data on the blockchain which you can use to test your agent. By visiting a block explorer (e.g. Etherscan ), you can browse the history of transactions on a contract. For example, if you were writing an agent that detects Tether transfers over $100, you can visit the Tether token page on Etherscan and see a list of transfers. From there you can easily pick out a transaction (e.g. 0x338c6d7095228544f27ba8479aea6cadbe5aea98806a651f66ef30b3cd7e1813 ) and run it against your agent using: $ npm run tx 0x338c6d7095228544f27ba8479aea6cadbe5aea98806a651f66ef30b3cd7e1813 You could also run your agent against all the transactions in a block using: $ npm run block 13682565 Also, if you visit the transaction's details page on Etherscan, you can see more information such as the block number, amount of gas used and which function was invoked. The logs generated by the transaction can also be viewed under the Logs tab .","title":"Getting test data"},{"location":"testing/#automated-testing","text":"A complete agent testing strategy will include automated unit tests that can quickly verify the behaviour of the agent. For your convenience, unit tests are included in the starter projects as examples. We use the jest testing framework in the Javascript/Typescript projects, and pytest in the Python project. These are only suggestions and you should feel free to use whichever testing framework you prefer. You can run the included unit tests with the following command: $ npm test When writing unit tests, you can easily create mock transactions and blocks using the SDK methods createTransactionEvent and createBlockEvent . See here for an example. Also, you can easily write tests for agents that detect log events or function calls by mocking out the SDK methods filterLog and filterFunction . See here for an example.","title":"Automated testing"},{"location":"testing/#advanced-testing","text":"For more advanced testing involving simulated transactions, check out the Advanced testing pattern.","title":"Advanced testing"},{"location":"testing/#code-review","text":"We strongly recommend conducting code reviews within your team as a best practice. This will help ensure that any bugs are identified and any edge cases are covered by your agent.","title":"Code review"},{"location":"testing/#best-practices","text":"To learn more about agent development best practices, see the Best practices section. Be sure to check out Useful libraries for developing your agents as well. There are also sections describing more advanced agent patterns like hiding sensitive data , publishing private alerts , transaction simulation and querying other chains . Once you have tested and reviewed your agent, you can move on to deploying your agent .","title":"Best practices"},{"location":"tutorials/","text":"Video tutorials Here is an excellent set of video tutorials provided by Forta core dev and community member Arbitrary Execution to help developers understand the lifecycle of building agents. 1) What are Forta Agents? 2) What can Forta Agents monitor for? 3) Developing a Forta Agent 4) Testing your Forta Agent 5) Reviewing your Forta Agent 6) Publishing your Forta Agent 7) Maintaining your Forta Agent 8) Tips for successful agents 9) Full example agent walkthrough 10) Subscribing to alerts using Forta App 11) Deploying an agent with Forta Connect (deprecated) 12) Machine learning on Forta","title":"Video tutorials"},{"location":"tutorials/#video-tutorials","text":"Here is an excellent set of video tutorials provided by Forta core dev and community member Arbitrary Execution to help developers understand the lifecycle of building agents.","title":"Video tutorials"},{"location":"tutorials/#1-what-are-forta-agents","text":"","title":"1) What are Forta Agents?"},{"location":"tutorials/#2-what-can-forta-agents-monitor-for","text":"","title":"2) What can Forta Agents monitor for?"},{"location":"tutorials/#3-developing-a-forta-agent","text":"","title":"3) Developing a Forta Agent"},{"location":"tutorials/#4-testing-your-forta-agent","text":"","title":"4) Testing your Forta Agent"},{"location":"tutorials/#5-reviewing-your-forta-agent","text":"","title":"5) Reviewing your Forta Agent"},{"location":"tutorials/#6-publishing-your-forta-agent","text":"","title":"6) Publishing your Forta Agent"},{"location":"tutorials/#7-maintaining-your-forta-agent","text":"","title":"7) Maintaining your Forta Agent"},{"location":"tutorials/#8-tips-for-successful-agents","text":"","title":"8) Tips for successful agents"},{"location":"tutorials/#9-full-example-agent-walkthrough","text":"","title":"9) Full example agent walkthrough"},{"location":"tutorials/#10-subscribing-to-alerts-using-forta-app","text":"","title":"10) Subscribing to alerts using Forta App"},{"location":"tutorials/#11-deploying-an-agent-with-forta-connect-deprecated","text":"","title":"11) Deploying an agent with Forta Connect (deprecated)"},{"location":"tutorials/#12-machine-learning-on-forta","text":"","title":"12) Machine learning on Forta"},{"location":"tx-simulation/","text":"Transaction simulation Transaction simulation is a powerful technique that can be used by agent developers to see the results of transactions without having to pay for on-chain execution. Using simulation, you can run transactions from any account on the latest blockchain state and view the results. An example usecase would be to flag malicious transactions in the mempool targeting your protocol before they get mined. This page describes how to simulate transactions using an example Typescript agent. The code for this example can be found here . Forking the chain In this example, the ganache-core library is used to create an in-memory fork of the blockchain from a specified block number. Since we want to fork the latest state, we create the fork inside of the handleBlock handler and specify the latest block number: import ganache from \"ganache-core\"; const USER_ADDRESS = \"0x72cea5e3540956b2b71a91012a983267472d2fb1\"; // returns an ethers provider pointing to a forked version of the chain from the specified block function getEthersForkProvider(blockNumber: number) { return new ethers.providers.Web3Provider( ganache.provider({ fork: getJsonRpcUrl(), // specify the chain to fork from fork_block_number: blockNumber, // specify the block number to fork from unlocked_accounts: [USER_ADDRESS], // specify any accounts to unlock }) ); } async function handleBlock(blockEvent: BlockEvent) { // create an ethers provider that points to a forked ganache chain const provider = getEthersForkProvider(blockEvent.blockNumber); ... } The above code initializes an ethers provider pointing to the Ganache fork that you can use like a regular provider (e.g. invoke methods like getBalance ). We also specify exactly which accounts we want Ganache to unlock so we can simulate transactions from that account. Simulating transactions Now we can simulate transactions using the ethers provider. In this example, we execute a Tether transfer from the specified account to some other account. First we query the balance of the account, and then transfer the entire balance. async function handleBlock(blockEvent: BlockEvent) { // create an ethers provider that points to a forked ganache chain const provider = getEthersForkProvider(blockEvent.blockNumber); // create an ethers contract pointing to the Tether token on the forked ganache chain const tetherContract = new ethers.Contract( TETHER_ADDRESS, TETHER_ABI, provider.getSigner(USER_ADDRESS) ); try { // get the user's balance userBalance = await tetherContract.balanceOf(USER_ADDRESS); // transfer the entire balance to another user const tx = await tetherContract.transfer(USER2_ADDRESS, userBalance); // wait for transaction to be mined by ganache await tx.wait(); } catch (e) { // report a finding if the simulated transaction fails } } The above transaction should succeed with no errors. Ganache will mine the transaction and increase the block number. But what happens if you try to transfer an amount higher than the user's balance? The on-chain logic will throw an error, and the catch block will be invoked. In this example, we return a finding if the transfer fails for any reason. Amazing! You now have an agent that can fork the state of the blockchain, query on-chain data, and execute transactions without needing to pay any gas.","title":"Transaction simulation"},{"location":"tx-simulation/#transaction-simulation","text":"Transaction simulation is a powerful technique that can be used by agent developers to see the results of transactions without having to pay for on-chain execution. Using simulation, you can run transactions from any account on the latest blockchain state and view the results. An example usecase would be to flag malicious transactions in the mempool targeting your protocol before they get mined. This page describes how to simulate transactions using an example Typescript agent. The code for this example can be found here .","title":"Transaction simulation"},{"location":"tx-simulation/#forking-the-chain","text":"In this example, the ganache-core library is used to create an in-memory fork of the blockchain from a specified block number. Since we want to fork the latest state, we create the fork inside of the handleBlock handler and specify the latest block number: import ganache from \"ganache-core\"; const USER_ADDRESS = \"0x72cea5e3540956b2b71a91012a983267472d2fb1\"; // returns an ethers provider pointing to a forked version of the chain from the specified block function getEthersForkProvider(blockNumber: number) { return new ethers.providers.Web3Provider( ganache.provider({ fork: getJsonRpcUrl(), // specify the chain to fork from fork_block_number: blockNumber, // specify the block number to fork from unlocked_accounts: [USER_ADDRESS], // specify any accounts to unlock }) ); } async function handleBlock(blockEvent: BlockEvent) { // create an ethers provider that points to a forked ganache chain const provider = getEthersForkProvider(blockEvent.blockNumber); ... } The above code initializes an ethers provider pointing to the Ganache fork that you can use like a regular provider (e.g. invoke methods like getBalance ). We also specify exactly which accounts we want Ganache to unlock so we can simulate transactions from that account.","title":"Forking the chain"},{"location":"tx-simulation/#simulating-transactions","text":"Now we can simulate transactions using the ethers provider. In this example, we execute a Tether transfer from the specified account to some other account. First we query the balance of the account, and then transfer the entire balance. async function handleBlock(blockEvent: BlockEvent) { // create an ethers provider that points to a forked ganache chain const provider = getEthersForkProvider(blockEvent.blockNumber); // create an ethers contract pointing to the Tether token on the forked ganache chain const tetherContract = new ethers.Contract( TETHER_ADDRESS, TETHER_ABI, provider.getSigner(USER_ADDRESS) ); try { // get the user's balance userBalance = await tetherContract.balanceOf(USER_ADDRESS); // transfer the entire balance to another user const tx = await tetherContract.transfer(USER2_ADDRESS, userBalance); // wait for transaction to be mined by ganache await tx.wait(); } catch (e) { // report a finding if the simulated transaction fails } } The above transaction should succeed with no errors. Ganache will mine the transaction and increase the block number. But what happens if you try to transfer an amount higher than the user's balance? The on-chain logic will throw an error, and the catch block will be invoked. In this example, we return a finding if the transfer fails for any reason. Amazing! You now have an agent that can fork the state of the blockchain, query on-chain data, and execute transactions without needing to pay any gas.","title":"Simulating transactions"},{"location":"useful-libraries/","text":"Useful libraries Here is a collection of libraries and APIs that agent developers may find useful when building their agents. Want to add your library here? Check out this section to suggest an edit. forta-agent-templates forta-agent-templates is a repository of low-code agent templates developed by Forta community member Arbitrary Execution . All you have to do is modify a single json config file to build your agent. Some example templates include listening for a set of events and filtering by some conditions, or scanning for accounts that have interacted with Tornado Cash. forta-agent-tools forta-agent-tools is a nifty library developed by Forta community member Nethermind . It includes some common agent templates, as well as some neat testing tools. ethers-multicall ethers-multicall is useful for querying lots of data from the blockchain without having to make multiple http requests. For example, if you want to query token balances for a list of addresses, you can use this library to fetch all the balances in a single http request. rolling-math rolling-math is an awesome library developed by Forta community member Arbitrary Execution. It is useful for agents that require analyzing trends across some time window. lru-cache lru-cache is great for adding caching capability to your agent. You can specify the maximum number of items you want to cache and keep only the most recently used items. Etherscan API The Etherscan APIs are a great resource for agent developers. They can be used to answer questions like \"which transactions was a given address involved in?\" or \"what is the ABI for a given contract address?\". Note: make sure to use obfuscation if placing an Etherscan API key in your code.","title":"Useful libraries"},{"location":"useful-libraries/#useful-libraries","text":"Here is a collection of libraries and APIs that agent developers may find useful when building their agents. Want to add your library here? Check out this section to suggest an edit.","title":"Useful libraries"},{"location":"useful-libraries/#forta-agent-templates","text":"forta-agent-templates is a repository of low-code agent templates developed by Forta community member Arbitrary Execution . All you have to do is modify a single json config file to build your agent. Some example templates include listening for a set of events and filtering by some conditions, or scanning for accounts that have interacted with Tornado Cash.","title":"forta-agent-templates"},{"location":"useful-libraries/#forta-agent-tools","text":"forta-agent-tools is a nifty library developed by Forta community member Nethermind . It includes some common agent templates, as well as some neat testing tools.","title":"forta-agent-tools"},{"location":"useful-libraries/#ethers-multicall","text":"ethers-multicall is useful for querying lots of data from the blockchain without having to make multiple http requests. For example, if you want to query token balances for a list of addresses, you can use this library to fetch all the balances in a single http request.","title":"ethers-multicall"},{"location":"useful-libraries/#rolling-math","text":"rolling-math is an awesome library developed by Forta community member Arbitrary Execution. It is useful for agents that require analyzing trends across some time window.","title":"rolling-math"},{"location":"useful-libraries/#lru-cache","text":"lru-cache is great for adding caching capability to your agent. You can specify the maximum number of items you want to cache and keep only the most recently used items.","title":"lru-cache"},{"location":"useful-libraries/#etherscan-api","text":"The Etherscan APIs are a great resource for agent developers. They can be used to answer questions like \"which transactions was a given address involved in?\" or \"what is the ABI for a given contract address?\". Note: make sure to use obfuscation if placing an Etherscan API key in your code.","title":"Etherscan API"}]}