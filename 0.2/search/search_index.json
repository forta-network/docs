{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to the Forta Docs!","text":"<ul> <li> <p> Use Forta 0.2</p> <p>Access Forta's Threat Intel to detect Web3 hacks.</p> <p> Getting Started</p> </li> <li> <p> Build on Forta</p> <p>Build detection bots and earn recurring monthly revenue</p> <p> Start building</p> </li> <li> <p> Run a Node</p> <p>Setup a scan node to run detection bots and operate the Forta network</p> <p> Learn more</p> </li> <li> <p> Network Fees and Developer Rewards</p> <p>Users that want to consume Forta Threat Intel will need to purchase one or more monthly subscription plans. Developers that create and maintain those data feeds get rewards</p> <p> Getting Started</p> </li> <li> <p> Staking on Forta</p> <p>Delegate your FORT tokens to a Scanner Pool and get rewarded for increasing Forta network security</p> <p> Getting Started</p> </li> <li> <p> Network Overview</p> <p>Get a high-level understanding of the Forta Network, its governance, the FORT token and a security overview</p> <p> Learn more</p> </li> </ul> <p> Got a question or feedback? Get in touch with the community in the Forta Discord server.</p>"},{"location":"FAQs/","title":"Use Forta","text":""},{"location":"FAQs/#what-can-forta-be-used-for","title":"What can Forta be used for?","text":"<p>The Forta Network monitors on-chain activity in real-time, detecting threats, security-related events and other noteworthy activity. The network is made up of thousands of detection bots developed by a community of Web3 developers and security experts. Each bot acts like a little security camera monitoring something specific on-chain. Some bots monitor generic threats (i.e. phishing attacks, rug pulls), and others monitor protocol-specific activity (i.e. Lido, Compound).</p> <p>The output from all this monitoring and detection is what we call threat intelligence - data that tells you the \u201cwho, what, when, where and how\u201d about threats and security events.   </p> <p>Users can access threat intel generated by any bot on the network. Certain bots the community feels are particularly high value have been packaged up into Premium Feeds, like the Scam Detector. Premium Feeds are owned and maintained by one or more reputable community members (teams and/or individuals) and must meet certain requirements for performance and precision. The price for each Premium Feed is set by the owner. Intel from the other bots on the network can be accessed under the network\u2019s General subscription plan option.</p> <p>You can see all the Premium Feeds here. You can also browse the 1,000+ other bots on the network here.</p> <p>Intel from Premium Feeds and individual bots can be accessed either through Forta\u2019s GraphQL API (pull) or by subscribing to a bot directly (push) to receive notifications via email, Slack, or Telegram, among other options. Purchasing one or more network subscriptions allows you to access both options. </p>"},{"location":"FAQs/#who-uses-forta","title":"Who uses Forta?","text":"<p>Wallets, compliance solutions, protocols, liquidity providers, investors, exchanges, among others, use Forta\u2019s threat intelligence. They query the Forta API to get labels and alerts, or subscribe to notifications, from threat intelligence data feeds.  </p>"},{"location":"FAQs/#how-much-do-i-have-to-pay-to-use-forta","title":"How much do I have to pay to use Forta?","text":"<p>There are different plans which provide access to different sets of data feeds. Premium feeds are provided by dedicated bot developers and can provide sophisticated and curated data, and have custom pricing set by their owners. There is also a general plan which gives access to hundreds of detection bots, and is priced at 250 FORT.</p> <p>All plans provide unlimited access to the API, as well as subscription to notifications via Slack, Email, Telegram, Discord, or a custom Webhook.</p>"},{"location":"FAQs/#how-can-i-access-the-data-generated-by-the-forta-network","title":"How can I access the data generated by the Forta Network?","text":"<p>You can use Forta\u2019s GraphQL API to query the data, or subscribe to notifications through the Forta App and receive alerts via Slack, Email, Telegram, Discord, or a custom Webhook.</p> <p>Here you can learn how to use the API.</p> <p>Here you can learn how to subscribe to notifications using the Forta App.</p>"},{"location":"FAQs/#how-can-i-find-valuable-detection-bots-in-the-network","title":"How can I find valuable detection bots in the network?","text":"<p>A good way to start is to look at the premium feeds featured in the Forta App, which are offered by dedicated bot developers and can offer sophisticated and curated detection bots that provide high value for a specific use case. </p> <p>In addition, you can also use the search function in Forta App to look for the bot that best fits your needs, among the hundreds of existing bots in the network.</p>"},{"location":"FAQs/#build-detection-bots","title":"Build Detection Bots","text":""},{"location":"FAQs/#how-do-i-write-a-detection-bot-with-the-sdk","title":"How do I write a detection bot with the SDK?","text":"<p>Here you can find a quickstart guide to write your first detection bot using the SDK.</p>"},{"location":"FAQs/#do-i-need-special-hardware-to-build-bots","title":"Do I need special hardware to build bots?","text":"<p>The average consumer laptop is more than sufficient to build bots. If you are using your existing developer machine, you will do great.</p>"},{"location":"FAQs/#what-are-best-practices-when-writing-detection-bots","title":"What are best practices when writing detection bots?","text":"<p>You can take a look at some of the best practices for writing detection bots here.</p>"},{"location":"FAQs/#what-are-some-advanced-techniques-for-developing-bots","title":"What are some advanced techniques for developing bots?","text":"<p>The open source Forta SDK is extremely flexible and encourages bot developers to unleash their creativity. Here there are some advanced techniques which are useful when creating sophisticated detection bots.</p>"},{"location":"FAQs/#where-can-i-find-examples-of-detection-bots","title":"Where can I find examples of detection bots?","text":"<p>Here you can take a look at some examples of detection bots. In addition, you can use the Forta App to search for bots.</p>"},{"location":"FAQs/#do-i-get-compensated-for-building-detection-bots","title":"Do I get compensated for building detection bots?","text":"<p>Yes, bot developers receive rewards from users that subscribe to their detection bots.</p>"},{"location":"FAQs/#can-i-hide-the-code-of-the-detection-bots-i-write","title":"Can I hide the code of the detection bots I write?","text":"<p>Yes, you can obfuscate the code as explained here.</p>"},{"location":"FAQs/#do-i-have-to-ask-permission-from-anyone-to-deploy-a-bot-to-the-network","title":"Do I have to ask permission from anyone to deploy a bot to the network?","text":"<p>No, developing and deploying detection bots is permissionless. Just remember that after you deploy the detection bot, you have to stake for it to be enabled and run by scan nodes, in accordance with Network parameters (currently 100 FORT).</p>"},{"location":"FAQs/#can-i-write-bots-without-having-to-code","title":"Can I write bots without having to code?","text":"<p>Yes, the open source Forta detection bot Wizard is a no-code tool that enables anyone to create simple bots with just a few clicks, based on existing templates. Here you can learn how and start using the Wizard.</p>"},{"location":"FAQs/#running-a-scan-node","title":"Running a Scan Node","text":""},{"location":"FAQs/#how-do-i-run-a-scan-node","title":"How do I run a scan node?","text":"<p>Please see the scan node guide guide to learn how to set up a scan node.</p>"},{"location":"FAQs/#do-i-get-compensated-for-running-nodes","title":"Do I get compensated for running nodes?","text":"<p>Scan nodes get rewards according to their performance (measured via their uptime and SLA) and their security (measured via their stake). Here you can find more detail on the rewards formula, and here you can find updates regarding weekly rewards.</p>"},{"location":"FAQs/#fort-token","title":"FORT Token","text":""},{"location":"FAQs/#what-is-the-fort-token-used-for","title":"What is the FORT token used for?","text":"<p>FORT is a utility token that can be used to stake on node pools, to stake on detection bots, to pay fees, and also to participate in governance. You can learn more here. </p>"},{"location":"FAQs/#what-chain-is-the-fort-token-in","title":"What chain is the FORT token in?","text":"<p>FORT is an ERC-20 on Ethereum </p> <p>(Address: 0x41545f8b9472D758bB669ed8EaEEEcD7a9C4Ec29)</p> <p>Additionally, staking happens in Forta\u2019s smart contracts on Polygon, where the bridged version of FORT is used (Address:0x9ff62d1FC52A907B6DCbA8077c2DDCA6E6a9d3e1).</p>"},{"location":"FAQs/#what-is-the-total-supply-of-the-fort-token","title":"What is the total supply of the FORT token?","text":"<p>The total supply is 1,000,000,000 FORT. </p>"},{"location":"FAQs/#how-can-i-delegate-fort","title":"How can I delegate FORT?","text":"<p>Delegating FORT to secure scan pools in the network can be done with just a few clicks from the Forta App. Here you can find a detailed guide.</p>"},{"location":"FAQs/#general","title":"General","text":""},{"location":"FAQs/#what-are-detection-bots","title":"What are detection bots?","text":"<p>Detection bots refer to a set of code scripts within a Docker container that process some blockchain data (i.e. a block or transaction) and detect specific threat conditions (e.g. whether a flash loan attack occurred, or whether a particular account balance fell below some threshold). Bots are executed by scan nodes, and emit alerts for their findings. </p>"},{"location":"FAQs/#what-are-scan-nodes","title":"What are scan nodes?","text":"<p>A scan node executes detection bots for every transaction and every new block on a specific blockchain network. The scan node manages and coordinates bots (e.g. by instantiating and running bots, and restarting bots that become unresponsive). The scan node ferries blockchain data to bots to process the transaction/block. </p>"},{"location":"FAQs/#how-does-forta-ensure-reliable-monitoring","title":"How does Forta ensure reliable monitoring?","text":"<p>The Forta Network combines different approaches to ensure reliable monitoring. Firstly, scan nodes must produce a proof of scan for every block, so performance is measured continuously and an SLA score is calculated at all times. If SLA score is below an accepted threshold, the node stops receiving rewards and detection bots get unassigned from it. In addition, each bot is assigned and gets run by multiple nodes. This redundancy ensures that even if one node is not performing correctly, the others will. Additionally, for those detection bots that are very resource intensive and may not be handled well by a node, sharding can be enabled to shard the bot and have it be executed partially on different nodes. Finally, nodes have staking requirements, and can be slashed if found to be acting maliciously. This, as well as the effect of low SLA on rewards, represents an economic incentive for nodes to have good performance.</p>"},{"location":"FAQs/#how-are-forta-findings-validated","title":"How are Forta findings validated?","text":"<p>Forta scan nodes gather findings from detection bots for each block and then store a proof of scan on IPFS and broadcast the finding details to the Forta analyzer node. Users can obtain the detailed information from the Forta analyzer node via the public API, which can be validated against the proof of scan data on IPFS. The analyzer node performs data indexing and may provide additional analysis.</p>"},{"location":"FAQs/#what-chains-does-forta-support","title":"What chains does Forta support?","text":"<p>Forta supports monitoring on the following chains: Ethereum, Polygon, BNB Chain, Avalanche, Arbitrum, Optimism and Fantom.</p>"},{"location":"FAQs/#what-machine-learning-techniques-are-being-used-in-forta","title":"What machine learning techniques are being used in Forta?","text":"<p>The community of data scientists and developers in the Forta Network have created multiple detection bots that use advanced machine learning techniques for detection. These include deep learning, supervised classification, anomaly detection, time series anomaly detection, and clustering, among others. You can learn more about how machine learning is being used in the Forta Network here.</p>"},{"location":"FAQs/#is-forta-a-blockchain","title":"Is Forta a blockchain?","text":"<p>Short answer: no. Forta is not a blockchain in the sense that it does not maintain a shared state between nodes, but it has similar characteristics to a blockchain in that it is a decentralized network of nodes. Forta is more similar to The Graph protocol in that it runs on top of a blockchain. Forta uses a blockchain (i.e. Polygon) to coordinate scan nodes and store IPFS references to alerts generated by bots.</p>"},{"location":"Forta-for-Metamask/","title":"Forta for Metamask","text":"<p>Forta Snap for Metamask</p> <p>The Forta Snap for MetaMask is a plugin that automatically scans the addresses in a user\u2019s pre-signed transaction against Forta\u2019s database of known scammers. Based on the results, the plugin will display a \u201chigh-risk\u201d or \u201clow-risk\u201d warning message to the user. Some of the scam types covered by the Forta Snap include: </p> <pre><code>* Token impersonation\n* Pig butchering\n* Gas minting\n* Sleep minting\n* Hard and soft rug Pulls\n* NFT wash trading\n</code></pre> <ol> <li> <p>What is Forta? Forta is the largest network of security intelligence in Web3. The network provides real-time intelligence about scams, exploits and other suspicious activity to 100+ teams, including DeFi protocols, centralized exchanges, Web3 wallets, security tools and crypto compliance platforms. </p> </li> <li> <p>How do I install the Forta Snap for MetaMask? You can install the Forta Snap by following these steps:</p> <p>Set Up Metamask</p> <ul> <li>Open your MetaMask wallet.</li> <li>Go to the \"Settings\" menu.</li> <li>Click on \"Advanced\" at the bottom.</li> <li>Under the \"Snap Extensions\" section, click \"Add Snap\".</li> <li>Enter the Forta Snap's URL: https://snap.forta.network.</li> <li>Click \"Add\" to install the Snap.</li> </ul> </li> <li> <p>How do I use the Forta Snap once it's installed? Once installed, the Snap will automatically scan a user\u2019s pre-signed transactions and flag any scammer addresses involved. Warning messages will show up in the \u201cForta\u201d tab in the Metamask window.</p> </li> <li> <p>Where can I report issues or seek help? If you have questions or encounter any issues with the Forta Snap, please reach out to us info@forta.org.  You can also contact the Forta Snap team via Github to report problems and provide feedback - forta-network/metamask-snap.</p> </li> <li> <p>Is my privacy protected? The Forta Snap's design emphasizes user privacy and security. However, it's recommended to review the privacy policy and terms of use associated with both the Forta Network and MetaMask before using the Snap.</p> </li> </ol>"},{"location":"Forta-for-Metamask/#background","title":"Background","text":"<p>In the world of decentralized finance and cryptocurrency, determining the legitimacy of addresses can be a daunting task. The Forta Snap for MetaMask was developed to simplify this by offering an immediate risk assessment of addresses users intend to transact with.</p>"},{"location":"Forta-for-Metamask/#features","title":"Features","text":"<p>Forta Tab</p> <p>Within the MetaMask transaction signing window, there's a tab named \"Forta\". This tab has been integrated to provide a risk assessment for the address involved in the current transaction.</p> <p> </p> <p>Risk Assessment Indicators</p> <p>By accessing the Forta tab, users are presented with one of two indicators:</p> <p><code>High Risk</code>: This label signifies that the address being interacted with has prior associations with scam activities. Caution is advised.</p> <p><code>Low Risk</code>: This label indicates that there's no known record of the address being involved in scam-related activities. However, users should still exercise their own due diligence.</p> <p>Usage</p> <p>Click the Forta Tab in MetaMask: Once you've initiated a transaction, navigate to the Forta tab within the MetaMask transaction window.</p> <p>Check the Risk Level: On the Forta tab, you'll see a risk assessment label, either <code>High Risk</code> or <code>Low Risk</code>, which gives you an indication of the potential risk associated with the address.</p>"},{"location":"advanced-testing/","title":"Advanced testing","text":"<p>There may be cases where developers want to test their bot with more complex interactions using real data, or to test scenarios that have not yet occurred on-chain. One way to do this is to fork the state of the chain locally and point your bot to it. You can then simulate transactions on the forked chain and the bot will scan the resulting blocks and transactions.</p> <p>This page describes how to conduct more advanced testing using a locally forked chain. The complete code for this example can be found here.</p>"},{"location":"advanced-testing/#run-a-forked-chain","title":"Run a forked chain","text":"<p>We make use of the Ganache forking feature, specifically using the underlying ganache-core library. In the example project, there is a convenient script for you to run in package.json: <code>npm run ganache</code>. This will run the following code (make sure to replace the <code>RPC_URL</code> with a valid endpoint):</p> <pre><code>const RPC_URL = \"https://mainnet.infura.io/v3/YOUR_API_KEY\";\nconst PORT = 7545;\n\nasync function runGanacheFork() {\n  // get the latest block number\n  const provider = new ethers.providers.JsonRpcProvider(RPC_URL);\n  const blockNumber = await provider.getBlockNumber();\n\n  // fork the chain from the block number and unlock an account to simulate transactions from\n  const server = ganache.server({\n    fork: RPC_URL,\n    fork_block_number: blockNumber,\n    unlocked_accounts: [USER],\n  });\n\n  // start a rpc server\n  server.listen(PORT, () =&gt; {\n    console.log(`json-rpc listening on port ${PORT}`);\n  });\n}\n</code></pre> <p>This function will fetch the latest block number and create a Ganache fork at that point in the chain. You can also specify any accounts you want to unlock in order to simulate transactions from them. The last line starts a JSON-RPC server running locally on port 7545.</p>"},{"location":"advanced-testing/#point-the-bot-to-the-forked-chain","title":"Point the bot to the forked chain","text":"<p>Once we have the forked Ganache chain running, we want to point our bot to it. This is easily done by setting the <code>jsonRpcUrl</code> in forta.config.json:</p> <pre><code>{\n  \"jsonRpcUrl\": \"http://127.0.0.1:7545\"\n}\n</code></pre> <p>In the example project, we provide a local forta.config.json to point this specific bot to the forked chain (make sure that <code>jsonRpcUrl</code> is uncommented). You could also set <code>jsonRpcUrl</code> in your global forta.config.json (located at ~/.forta) if you want to point all of your local bots to the forked chain.</p> <p>Now you can run the bot in a separate terminal using <code>npm start</code>. This will start listening for blocks from the forked Ganache chain. Awesome!</p>"},{"location":"advanced-testing/#simulate-transactions","title":"Simulate transactions","text":"<p>Now we can simulate a number of transactions on the forked chain and see whether the bot returns any findings. In a separate terminal, run the script provided in package.json: <code>npm run simulation</code>. This will run the following code:</p> <pre><code>async function runSimulatedTransactions() {\n  // get an ethers provider that points to the ganache fork\n  const provider = getEthersProvider();\n  const tether = new ethers.Contract(\n    TETHER_ADDRESS,\n    TETHER_ABI,\n    provider.getSigner(USER)\n  );\n\n  // simulate a tether transfer for 100 TETH\n  const tx1 = await tether.transfer(USER2, 100 * 10 ** TETHER_DECIMALS);\n  const receipt1 = await tx1.wait();\n\n  // simulate a tether transfer for 10 TETH\n  const tx2 = await tether.transfer(USER2, 10 * 10 ** TETHER_DECIMALS);\n  const receipt2 = await tx2.wait();\n}\n</code></pre> <p>Here we simulate 2 transfers of Tether tokens from the unlocked account. After these transactions are mined by Ganache, you should see the bot scan the blocks shortly after (may take a few seconds). The bot should alert about one of these transactions. Sweet! Note that Ganache behaviour is to mine a new block for each transaction.</p>"},{"location":"advanced-testing/#automating-the-above","title":"Automating the above","text":"<p>While it's cool to be able to manually run the above scripts, it would be amazing to have it all automated. This is exactly what we have done in the provided agent.spec.js file. In it you will find a Jest test suite that will fork a Ganache chain, run simulated transactions and verify that the bot outputs the correct findings.</p>"},{"location":"advanced-testing/#other-considerations","title":"Other considerations","text":"<ul> <li>A known limitation of Ganache is the lack of tracing data. If your bot relies on trace data (either using <code>txEvent.traces</code> directly, or indirectly using <code>txEvent.filterFunction</code>), then this simulation may not generate the correct findings.</li> </ul>"},{"location":"airdrop/","title":"FORT Airdrop","text":"It's Time to Protect Web3 <p>Check your eligibility and claim your FORT airdrop</p> <p>The FORT Airdrop rewards early Forta contributors and seeds the broader Web3 security community with FORT tokens so they can begin building on the Forta Network. 26,769 addresses are eligible to claim FORT Tokens in the Forta Airdrop. If you\u2019ve used Forta, contributed to a Web3 project or are an active participant in the Web3 ecosystem, you may be eligible.</p> <p>Each category and subcategory is discrete and cumulative i.e. an address can be eligible for multiple categories and allocated a sum of tokens for each accordingly. The allocation and criteria are broken down as follows:</p>"},{"location":"airdrop/#forta-airdrop-allocation","title":"Forta Airdrop Allocation","text":""},{"location":"airdrop/#forta-users","title":"Forta Users","text":"<p>Forta Users, in the context of the airdrop, are those who have contributed to the Network from day one, including, but not limited to, Detection Bot developers, community members who participated in Detection Bot development contests, Alert subscribers, and Forta Scan Node runners.</p>"},{"location":"airdrop/#detection-bot-developers","title":"Detection Bot Developers","text":"<p>Detection Bot developers represent a critical aspect of the Network by building novel and clever ways to monitor blockchain activity. Thanks to their ideas identifying needs and leveraging their unique skills for development, a wide range of security and operational activities are now being monitored by the Forta Network.</p> <p> Each subcategory is discrete and cumulative: an address can be eligible for multiple and allocated a sum of tokens accordingly.</p>"},{"location":"airdrop/#alert-subscribers","title":"Alert Subscribers","text":"<p>This group selects early adopters who started using Forta by subscribing to alerts on the Forta Network.</p> <p></p>"},{"location":"airdrop/#node-runners","title":"Node Runners","text":"<p>Node runners are crucial to the Network\u2019s security and growth by operating the infrastructure that scans transactions and emits alerts. These early community members played a key role in hardening, stress-testing, and scaling Forta.</p> <p> Each subcategory is discrete and cumulative: an address can be eligible for multiple and allocated a sum of tokens accordingly.</p>"},{"location":"airdrop/#forta-contributors","title":"Forta Contributors","text":"<p>Forta Contributors are ambassadors and thought leaders who are strong proponents of Forta\u2019s mission and have contributed to the development and advancement of the network in a meaningful way.</p>"},{"location":"airdrop/#web3-github-contributors","title":"Web3 Github Contributors","text":"<p>This group includes developers who actively contributed to over 900 Web3 Github repositories. This list comprises Web3 libraries, public goods, and top projects that are vital to the Forta ecosystem. Thousands of people worked to build and maintain these projects over the years, some even working completely for free in an effort to create a better and safer decentralized economy.</p> <p> Each subcategory is discrete and cumulative: an address can be eligible for multiple and allocated a sum of tokens accordingly.</p>"},{"location":"airdrop/#ethernaut-players","title":"Ethernaut Players","text":"<p>Ethernaut is an open source foundational learning tool teaching thousands of developers the basics of smart contract security. Fans of Ethernaut have gone on to build and audit protocols, securing billions in TVL by incorporating the critical security concepts introduced in Ethernaut.</p> <p> Each subcategory is discrete and cumulative: an address can be eligible for multiple and allocated a sum of tokens accordingly.</p>"},{"location":"airdrop/#web3-coders","title":"Web3 Coders","text":"<p>Inspired by Project Galaxy\u2019s initiative to support innovative developers, top developers in the Ethereum ecosystem are eligible for the FORT Airdrop. These are defined as coders who deployed smart contracts with the most active interactions.</p> <p></p>"},{"location":"airdrop/#subgraph-developers","title":"Subgraph Developers","text":"<p>The Graph Protocol subgraph developers on the decentralized service, who are valuable contributors to Web3 by facilitating access to blockchain data for decentralized applications on Ethereum.</p> <p></p>"},{"location":"airdrop/#multisig-signers","title":"Multisig Signers","text":"<p>Multisig signers can be key decision-makers, DAO leaders, and/or builders that have access to large pools of assets or control over critical protocol functions.</p> <p></p>"},{"location":"airdrop/#malicious-actor-filtering","title":"Malicious Actor Filtering","text":"<p>In an effort to reward benevolent Forta Network participants, Forta filtered out blocklisted addresses involved in any malicious activities.</p> <ul> <li>Known exploit addresses were filtered out.</li> <li>Addresses listed in Hop Protocol\u2019s Airdrop Sybil Attacker List were excluded.</li> <li>Addresses listed in Optimism\u2019s Airdrop Sybil Filter were excluded.</li> <li>Addresses listed in Chainalysis Sanction Oracle Contract were excluded.</li> </ul>"},{"location":"airdrop/#whats-next","title":"What\u2019s Next?","text":"<p>To check your eligibility for FORT Airdrop, visit the Forta Airdrop page.</p> <p>If you weren\u2019t eligible in this FORT Airdrop, there are plenty of other ways to contribute to the Forta ecosystem even before the Permissionless Launch:</p> <ul> <li>Get started with bot development</li> <li>Monitor your wallets and contracts</li> <li>Start a discussion in the Forta Forum</li> <li>Contribute to the protocol on GitHub</li> <li>Check out full-time roles in the Forta ecosystem</li> </ul> <p>Finally, make sure to join the Forta Discord, follow Forta on Twitter, and subscribe to the Forta Newsletter so you never miss an update!</p> <p> The values above may change between now and the date of the token Airdrop. An announcement will be made by the Forta Foundation on the official announcement channels when tokens are ready to be claimed.</p>"},{"location":"alchemy-partnership/","title":"Scan with Alchemy","text":"<p>Disclosure</p> <p>The following documentation was written by the team at Alchemy and does not reflect the views of the Forta Foundation.</p>"},{"location":"alchemy-partnership/#scan-with-alchemy","title":"Scan With Alchemy","text":""},{"location":"alchemy-partnership/#why-use-alchemy","title":"Why use Alchemy?","text":"<p>Alchemy is the leading\u00a0web3\u00a0blockchain\u00a0development platform embedded with powerful tools to simplify dApp development, saving countless hours for web3 engineers. Using Alchemy to run your Forta nodes will grant you the accuracy, reliability, and data consistency of Supernode, the proprietary blockchain engine used by leading web3 companies like OpenSea, Meta, Adobe, and Sushi Swap.</p> <p>Before digging deeper into setting up your node using Alchemy, let\u2019s explore what is Supernode and why it\u2019s the most reliable solution to run your Forta scan nodes.</p>"},{"location":"alchemy-partnership/#alchemy-supernode","title":"Alchemy Supernode","text":"<p>Alchemy Supernode is the most widely used Ethereum API with all the functionality of a node, but with supercharged reliability, data accuracy, and scalability.</p> <p>There are 5 main points that make Supernode a game-changer when it comes to serving blockchain data, faster and more reliably:</p> <ul> <li>It ensures that your data is always correct, real-time, and in sync thanks to a proprietary coordinator service.</li> <li>It powers each piece of node functionality with a dedicated, distributed system -- the same systems used by Facebook and Amazon for achieving massive scale.</li> <li>It scales quickly and seamlessly to maximize your scanning throughput.</li> <li>It includes enhanced API methods and upgraded WebSockets to continuously listen for changes and automatically handle reconnection and backfilling missed events.</li> <li>It\u2019s a one-line infrastructure API that not only does all the jobs of a single node, but also comes with the uptime, availability, and necessities to run a production application.</li> </ul> <p>If you want to read more about how Supernode is helping developers scale their applications, here are a number of use cases you might find interesting.</p> <p>Now that we know how Alchemy helps your Forta nodes be more reliable and performant, let\u2019s dive into how to create a new Alchemy account completely for free.</p> <p>If you already have an Alchemy account, feel free to skip the next section.</p>"},{"location":"alchemy-partnership/#special-offer","title":"Special Offer","text":"<p>Now that we know how Alchemy helps your Forta nodes be more reliable and performant, let's dive into how to create a new Alchemy account completely for free.</p> <p>If you want to run your nodes at maximum speed, Alchemy also offers a special price for frens in Forta's community, that comes with full support for:</p> <ul> <li>Alchemy Testnet APIs</li> <li>Alchemy Supernode for Mainnet</li> <li>Alchemy Notify</li> <li>Alchemy Monitor</li> <li>Alchemy Build</li> <li>Enhanced APIs and Websockets</li> <li>Standard Throughput - 660 compute units/second</li> <li>Dashboard access (10 user licenses included)</li> </ul> <p>Redeem your discount here!</p>"},{"location":"alchemy-partnership/#create-a-new-alchemy-account","title":"Create a new Alchemy Account","text":"<p>To start using Alchemy as a node provider for our Forta node, you\u2019ll need to create a new account. </p> <p>Head to alchemy.com and click on the sign-in button to register.</p> <p></p> <p></p> <p>Next, specify the type of project you want to build:</p> <p></p> <p>Then, select the chain you want to scan:</p> <p></p> <p>You\u2019ll then be prompted to insert your credit card info, or skip the form to be redirected to the Alchemy Dashboard:</p> <p></p> <p>From here, you\u2019ll need to grab the RPC URL required to set up your Forta node. On the Alchemy dashboard, click on the \u201cMy Team\u2019s App\u201d:</p> <p></p> <p>Then, click on the \u201cView Key\u201d button to reveal your API Key:</p> <p></p> <p>Now that you have your HTTPS RPC URL, we\u2019ll need to connect Alchemy Supernode to the Forta scan node running on your terminal.</p>"},{"location":"alchemy-partnership/#configure-your-alchemy-chain-apis","title":"Configure your Alchemy Chain APIs","text":"<p>If you haven\u2019t already installed Forta on your terminal, make sure to go through the scan node guide for kickstarting your Forta scan node.</p> <p>Once your Forta directory has been initialised, you\u2019ll find a file named \u00a0<code>config.yml</code>. We\u2019ll need to configure that file so that our scan node knows how to pull data from the blockchain.</p> <p>Forta detection bots are able to call JSON-RPC APIs using the RPC endpoints and the chain ID configured  in the <code>config.yml</code> file, to do so, we\u2019ll need to initialize the <code>scan.jsonRpc.url</code>  property in the config.yml file, with the Alchemy RPC URL we got when we created our Alchemy DApp in the previous section.</p> <p>Open the config.yml file in your Forta directory, and copy your Alchemy RPC URL in the jsonRpc property:</p> <pre><code>chainId: 1\n\nscan:\n  jsonRpc:\n    url: https://eth-mainnet.alchemyapi.io/v2/KEY\n\ntrace:\n  jsonRpc:\n    url: https://eth-mainnet.alchemyapi.io/v2/KEY\n</code></pre> <p>That\u2019s it! Your Forta node will now scan blockchain transactions at lightning speed using Alchemy Supernode! </p> <p>Please note that we\u2019ve set the chainId property to one in the above code. This is because we provided guidance to create an Ethereum application, and the Ethereum Mainnet chain ID is one. </p> <p>If you want to scan other chains like Polygon, Arbitrum or Optimism, please refer to the following section! </p>"},{"location":"alchemy-partnership/#scanning-other-chains","title":"Scanning other chains","text":"<p>If you want to scan other chains beyond Ethereum Mainnet using Alchemy, you\u2019ll need to create a new Alchemy dApp selecting the chain you want to scan, and refer to the following settings and chain ID to setup your config.yml file:</p>"},{"location":"alchemy-partnership/#polygon","title":"Polygon","text":"<pre><code>chainId: 137\n\nscan:\n  jsonRpc:\n    url: https://polygon-mainnet.g.alchemy.com/v2/YOUR-API-KEY\n\ntrace:\n    jsonRpc:\n    url: https://polygon-mainnet.g.alchemy.com/v2/YOUR-API-KEY\n</code></pre>"},{"location":"alchemy-partnership/#arbitrum","title":"Arbitrum","text":"<pre><code>chainId: 42161\n\nscan:\n  jsonRpc:\n    url: https://arb-mainnet.g.alchemy.com/v2/YOUR-API-KEY\n\ntrace:\n    url: https://arb-mainnet.g.alchemy.com/v2/YOUR-API-KEY\n</code></pre>"},{"location":"alchemy-partnership/#optimism","title":"Optimism","text":"<pre><code>chainId: 10\n\nscan:\n  jsonRpc:\n    url: https://opt-mainnet.g.alchemy.com/v2/YOUR-API-KEY\n\ntrace:\n    url: https://opt-mainnet.g.alchemy.com/v2/YOUR-API-KEY\n</code></pre>"},{"location":"api-example-use-cases/","title":"Example Use Cases","text":"<p>The Forta API will allow protocols, DAOs, investors, and the community to integrate alerts in dApps and tools. There are many use cases for this, but here are three examples to give you a better idea of how this API can be used. </p> <p>You can also learn about these three examples and one Forta community member's API integration in the following youtube videos:</p> <ul> <li>Integrating with Forta: Learn more about the Forta API</li> <li>How the Convo Space is using the Forta API</li> </ul>"},{"location":"api-example-use-cases/#1-strengthen-protocol-security","title":"1. Strengthen Protocol Security","text":"<p>As a protocol developer...</p> <p>Let\u2019s say you developed a bot that monitors critical events on the protocol, but the bot has been emitting a lot of noisy alerts.  To reduce noisy alerts, you can:</p> <ol> <li>Query the API for past alerts</li> <li>Analyze your bot's alerting rate</li> <li>Tweak alerting threshold or logic</li> </ol> <p>Or you can also develop more complex mitigation scripts that:</p> <ol> <li>Query the API for specific bots' alerts</li> <li>Automate smart contract operations based on the received alerts</li> </ol>"},{"location":"api-example-use-cases/#2-reduce-phishing-attacks","title":"2. Reduce Phishing Attacks","text":"<p>As a dApp developer, you can:</p> <ol> <li>Notify users of potential threats and governance changes in the dApp. </li> <li>Build out an extension to wallets like Metamask to display warnings about a particular wallet address or smart contracts users are about to interact with.</li> <li>Build a smart contract safety checker tool.</li> </ol> <p>This is all possible by querying the API for alerts across bots that are associated with specific wallets and/or smart contracts at different points in time. </p>"},{"location":"api-example-use-cases/#3-make-informed-financial-decisions","title":"3. Make Informed Financial Decisions","text":"<p>As a financial analyst, you may want to analyze several blockchain projects\u2019 alerts and identify trends before making any investment decisions.</p> <p>As an insurance protocol, you can decide whether to provide coverage or process claims for a particular smart contract by analyzing its alerts to gauge its security. </p>"},{"location":"api-examples-tutorials/","title":"Example Queries and Tutorials","text":"<p>You can also view all examples and tutorials at forta-network.github.io/forta-api.</p>"},{"location":"api-examples-tutorials/#example-queries","title":"Example Queries","text":"<p>We provided some example queries for you to try in the API Sandbox:</p> <ul> <li>Recent alerts emitted by a specific bot</li> <li>Today's alerts associated with certain addresses</li> <li>Past alerts by block number or date range</li> <li>A list of blockchain projects</li> <li>Details of a blockchain project</li> </ul>"},{"location":"api-examples-tutorials/#tutorials","title":"Tutorials","text":"<ul> <li>Query alerts for analysis with python</li> </ul>"},{"location":"api-examples-tutorials/#recent-alerts-emitted-by-a-specific-bot","title":"Recent alerts emitted by a specific bot","text":"<p>You can also view this example query on github.</p> <p> </p>"},{"location":"api-examples-tutorials/#todays-alerts-associated-with-certain-addresses","title":"Today's alerts associated with certain addresses","text":"<p>You can also view this example query on github.</p> <p> </p>"},{"location":"api-examples-tutorials/#past-alerts-by-block-number-or-date-range","title":"Past alerts by block number or date range","text":"<p>You can also view this example query on github.</p> <p> </p>"},{"location":"api-examples-tutorials/#a-list-of-blockchain-projects","title":"A list of blockchain projects","text":"<p>You can also view this example query on github.</p> <p> </p>"},{"location":"api-examples-tutorials/#details-of-a-blockchain-project","title":"Details of a blockchain project","text":"<p>You can also view this example query on github.</p> <p> </p>"},{"location":"api-examples-tutorials/#query-alerts-for-analysis-with-python","title":"Query alerts for analysis with python","text":"<p>You can also view this tutorial on github.</p> <p> </p>"},{"location":"api-keys/","title":"API Keys","text":"<p>In order to use the Forta GraphQL API, you will need an API key. Also, when developing a bot locally that uses the <code>handleAlert</code> handler or the <code>getAlerts</code> or <code>getLabels</code> SDK method, you will need an API key.</p>"},{"location":"api-keys/#creating-an-api-key","title":"Creating an API Key","text":"<p>You can easily generate API keys using the Forta App by following these steps:</p>"},{"location":"api-keys/#1-navigate-to-my-api-keys","title":"1. Navigate to My API Keys","text":"<p>After signing in with your wallet in Forta App, select the \"My API Keys\" option in the top right menu. </p>"},{"location":"api-keys/#2-click-create-api-key","title":"2. Click Create API Key","text":"<p>Initially you will see an empty list, but you can generate a new API key by clicking the \"Create new API key\" button. You will then see a modal displaying your new API key as well as a randomly generated Key ID to identify your API key. Click on the Copy button next to the API key to copy it to your clipboard.</p> <p></p> <p>Protect your API key</p> <p>Remember to store your API key somewhere safe as it cannot be recovered. It should be kept secret. If you lose your API key you can always delete it from this page and generate a new one (up to a maximum of 10)</p>"},{"location":"api-keys/#using-the-api-key","title":"Using the API key","text":"<p>When querying the Forta GraphQL API directly, you must set the API key as a Bearer token in the Authorization header of your HTTP request. For example, if your API key is <code>abc123</code> your header would look like <code>\"Authorization\": \"Bearer abc123\"</code>. Here is an example curl usage:</p> <pre><code>curl POST --header \"Authorization: Bearer abc123\" --header \"content-type: application/json\" --url \"https://api.forta.network/graphql\"\n</code></pre>"},{"location":"api-keys/#using-with-a-bot-locally","title":"Using with a bot locally","text":"<p>If you have a bot that uses the <code>handleAlert</code> handler or the <code>getAlerts</code> or <code>getLabels</code> SDK method and you want to run the bot locally, you will need to provide the API key through the forta.config.json file. Simply set the <code>fortaApiKey</code> property in forta.config.json e.g.:</p> <pre><code>{\n  ...\n  \"fortaApiKey\": \"abc123\"\n  ...\n}\n</code></pre>"},{"location":"api-reference/","title":"Using the API","text":"<p>Forta currently supports GraphQL API access to intelligence emitted by detection bots. Each bot\u2019s documentation will describe the types of intelligence it generates, and will often have details about the detection methodology used. For Premium Feeds in particular, bot documentation should also feature example queries you can use to get up and running quickly. The API endpoint is https://api.forta.network/graphql and an API key is required. </p> <p>Note: Your query must also include the specific bot ID(s) you want intelligence from. </p>"},{"location":"api-reference/#before-you-can-access-the-api-you-must","title":"Before you can access the API, you must:","text":"<ul> <li>Purchase a Forta subscription (or been given a free trial), and</li> <li>Generate an API key</li> </ul>"},{"location":"api-reference/#generating-api-keys","title":"Generating API Keys","text":"<p>To access the Forta API, generate an API key using the Forta App:</p> <p>1. Navigate to My API Keys</p> <p>After signing in to the Forta App with your wallet, select the \"My API Keys\" option in the top right menu.</p> <p></p> <p>2. Click Create API Key</p> <p>Initially you will see an empty list, but you can generate a new API key by clicking the \"Create new API key\" button. You will then see a modal displaying your new API key as well as a randomly generated Key ID to identify your API key. Click on the Copy button next to the API key to copy it to your clipboard.</p> <p></p>"},{"location":"api-reference/#using-the-api-key","title":"Using the API Key","text":"<p>When querying the Forta GraphQL API directly, you must set the API key as a Bearer token in the Authorization header of your HTTP request. For example, if your API key is abc123 your header would look like \"Authorization\": \"Bearer abc123\". </p> <p>Here is an example curl usage:</p> <p></p>"},{"location":"api-reference/#api-sandbox","title":"API Sandbox","text":"<p>If you'd like an interactive interface for building and testing a query, please check out the API Sandbox.</p> <p>Step 1: Make sure that the endpoint is set to https://api.forta.network/graphql</p> <p></p> <p>If the sandbox is requesting an API key you can click on the gear logo just left of the publish button in order to insert your API key. </p> <p></p> <p>Under the \u2018Shared headers\u2019 section you must insert your API key by typing in \u2018bearer\u2019 space and then pasting your API key. </p> <p>Step 2: Create a new workspace if a blank one does not already exist by clicking on the + button as seen in the screenshot below.</p> <p></p> <p>Step 3: On the left hand side of the screen, under the \u2018Documentation\u2019 you will see the word Query with a + next to it and a \u2018Fields\u2019 heading with several options available. Click on Query to begin populating the Operation panel. Unlike a Rest API, the GraphQL API provides you with the flexibility to choose exactly the specific data you are interested in. </p> <p></p> <p>Step 4: Once you have clicked on Query, you will need to start populating the Operation panel with the necessary parameters required for your needs and the bot which you are querying. Certain bots emit alerts and labels. Check the bots documentation on how to query it correctly. </p> <p>After making your selections and jumping through the Documentation window your Operation window should look something like this: </p> <p></p> <p>Step 5: Under the Arguments heading in the Documentation window is where we will start to populate the Variables panel. </p> <p></p> <p>Step 6: Finally, we can click on the big blue Query button on the top right hand corner and our results will appear in the far right hand side of the screen. </p> <p></p>"},{"location":"api-reference/#using-with-a-bot-locally","title":"Using with a bot locally","text":"<p>If you have a bot that uses the <code>handleAlert</code> handler or the <code>getAlerts</code> or <code>getLabels</code> SDK method and you want to run the bot locally, you will need to provide the API key through the forta.config.json file. Simply set the <code>fortaApiKey</code> property in forta.config.json e.g.:</p> <p></p>"},{"location":"api-reference/#how-can-i-contribute","title":"How can I contribute?","text":"<p>If you'd like to report a bug, request a feature, or ask any questions about the API, please check out the forta-api github repository. We will be tracking all feature requests, bug reports, and feedback there.</p>"},{"location":"api/","title":"API Access","text":"<p>Forta requires a paid plan for GraphQL API access to alerts and blockchain projects data.</p>"},{"location":"api/#how-can-i-access-the-api","title":"How can I access the API?","text":"<p>You will first need to generate an API key in order to access the API. The API endpoint is https://api.forta.network/graphql.</p> <p>If you'd like an interactive interface for building and testing a query, please check out the API Sandbox.</p>"},{"location":"api/#how-can-i-contribute","title":"How can I contribute?","text":"<p>If you'd like to report a bug, request a feature, or ask any questions about the API, please check out the forta-api github repository. We will be tracking all feature requests, bug reports, and feedback there.</p>"},{"location":"attack-detector-bot/","title":"Attack Detector Bot","text":"Bot Name Bot Stats Bot Source Code Supported Chains Documentation Attack Detector Stats Github Repo All Docs <p>The Attack Detector bot combines past alerts under a common address from a variety of underlying base bots to emit a high precision alert. It does so by mapping each alert to the four attack stages (Funding, Preparation, Exploitation and Money Laundering/ Post Exploitation) utilizing an anomaly as well as heuristic detection approach.</p> <p>Individual alerts can have low precision (in other words raise false positives). This bot combines past alerts from base bots to separate the signal from noise.</p> <p>It does so with the realization that an attack usually consists of 4 distinct phases:</p> <ul> <li>funding (e.g. tornado cash funding)</li> <li>preparation (e.g. creation of an attacker contract)</li> <li>exploitation (e.g. draining funds from a contract)</li> <li>money laundering (e.g. sending funds to tornado cash)/ post exploitation (e.g. on-chain text messages)</li> </ul> <p>As such, this feed combines previously raised alerts under the initiating address (i.e. the attacker address/ addresses) and emits a crucial alert. As a result, the precision of this alert is quite high, but also some attacks may be missed. Note, in the case where attacks are missed, the broader set of detection bots deployed on Forta will still raise individual alerts that users can subscribe to.</p>"},{"location":"attack-detector-bot/#supported-chains","title":"Supported Chains","text":"<ul> <li>All EVM-compatible chains</li> </ul>"},{"location":"attack-detector-bot/#alerts","title":"Alerts","text":"<p>The Attack Detector bot emits the following alerts:</p> <ul> <li>ATTACK-DETECTOR-1 - heuristic alert that triggers when an alert is observed in each stage of the attack stages.</li> <li>ATTACK-DETECTOR-2 - heuristic alert that triggers when a highly precise (e.g. attack simulation) alert and one additional alert are observed.</li> <li>ATTACK-DETECTOR-3 - anomaly detection alert where anomaly scores of the base bots are combined (multiplied) per stage and the resulting anomaly score is lower than 1 * 10-7 (critical alert)</li> <li>ATTACK-DETECTOR-4 - anomaly detection alert where anomaly scores of the base bots are combined (multiplied) per stage and the resulting anomaly score is lower than 1 * 10-4 (low alert)</li> </ul>"},{"location":"attack-detector-bot/#labels","title":"Labels","text":"<p>The Attack Detector bot emits labels for each attacker address observed. The metadata contains the corresponding alertID. E.g. <pre><code>    'entityType': EntityType.Address,\n    'label': \"attacker\",\n    'entity': address,\n    'confidence': 0.99,\n    'remove': \"false\",\n    'metadata': {\n      'alert_id': alert_id,\n      'chain_id': chain_id\n    }\n</code></pre></p>"},{"location":"attack-detector-bot/#base-bots-utilized-by-attack-detector","title":"Base Bots Utilized By Attack Detector","text":"<p>The following bots are considered by the Attack Detector bot and mapped to the stages in the following way:</p> BotID Name AlertId Stage 0x8badbf2ad65abc3df5b1d9cc388e419d9255ef999fb69aac6bf395646cf01c14 ice phishing ICE-PHISHING-HIGH-NUM-APPROVALS Preparation 0x8badbf2ad65abc3df5b1d9cc388e419d9255ef999fb69aac6bf395646cf01c14 ice phishing ICE-PHISHING-PREV-APPROVED-TRANSFERED Exploitation 0x457aa09ca38d60410c8ffa1761f535f23959195a56c9b82e0207801e86b34d99 suspicious contract creation SUSPICIOUS-CONTRACT-CREATION Preparation 0x457aa09ca38d60410c8ffa1761f535f23959195a56c9b82e0207801e86b34d99 suspicious contract creation SUSPICIOUS-CONTRACT-CREATION-TORNADO-CASH Preparation 0x0e82982faa7878af3fad8ddf5042762a3b78d8949da2e301f1adfedc973f25ea blocklisted account tx EXPLOITER-ADDR-TX Preparation 0xa91a31df513afff32b9d85a2c2b7e786fdd681b3cdd8d93d6074943ba31ae400 tornado cash withdrawal FUNDING-TORNADO-CASH Funding 0x617c356a4ad4b755035ef8024a87d36d895ee3cb0864e7ce9b3cf694dd80c82a tornado cash funding TORNADO-CASH-FUNDED-ACCOUNT-INTERACTION Funding 0x492c05269cbefe3a1686b999912db1fb5a39ce2e4578ac3951b0542440f435d9 re-entrancy NETHFORTA-25 Exploitation 0x4adff9a0ed29396d51ef3b16297070347aab25575f04a4e2bd62ec43ca4508d2 money laundering POSSIBLE-MONEY-LAUNDERING-TORNADO-CASH MoneyLaundering 0x0ffe038c802784f739bb27fcd4274f71c384fea78de87c9ef8d5b3fb72b514c7 high gas usage IMPOSSIBLE-2 Exploitation 0xe27867c40008e0e3533d6dba7d3c1f26a61a3923bc016747d131f868f8f34555 high gas price FORTA-2 Exploitation 0xbf953b115fd214e1eb5c4d6f556ea30f0df47bd86bf35ce1fdaeff03dc7df5b7 high value transaction NETHFORTA-2 Exploitation 0x11b3d9ffb13a72b776e1aed26616714d879c481d7a463020506d1fb5f33ec1d4 txt messaging bot forta-text-messages-possible-hack Exploitation 0x20d57d727a2d7bf4b447d1952d7ea44efeda0920e45e779d298d5385f3b36cfa tx volume anomaly bot SUCCESSFUL-INTERNAL-TRANSACTION-VOL-INCREASE Exploitation 0x20d57d727a2d7bf4b447d1952d7ea44efeda0920e45e779d298d5385f3b36cfa tx volume anomaly bot SUCCESSFUL-TRANSACTION-VOL-INCREASE Exploitation 0x20d57d727a2d7bf4b447d1952d7ea44efeda0920e45e779d298d5385f3b36cfa tx volume anomaly bot FAILED-TRANSACTION-VOL-INCREASE Exploitation 0x20d57d727a2d7bf4b447d1952d7ea44efeda0920e45e779d298d5385f3b36cfa tx volume anomaly bot FAILED-INTERNAL-TRANSACTION-VOL-INCREASE Exploitation 0x55636f5577694c83b84b0687eb77863850c50bd9f6072686c8463a0cbc5566e0 flashloan detector FLASHLOAN-ATTACK, FLASHLOAN-ATTACK-WITH-HIGH-PROFIT Exploitation 0x2c8452ff81b4fa918a8df4441ead5fedd1d4302d7e43226f79cb812ea4962ece Large Mint Borrow Volume Anomaly Detection HIGH-BORROW-VALUE Exploitation 0x2c8452ff81b4fa918a8df4441ead5fedd1d4302d7e43226f79cb812ea4962ece Large Mint Borrow Volume Anomaly Detection HIGH-MINT-VALUE Exploitation 0x4c7e56a9a753e29ca92bd57dd593bdab0c03e762bdd04e2bc578cb82b842c1f3 unverified contract creation UNVERIFIED-CODE-CONTRACT-CREATION Preparation 0x6aa2012744a3eb210fc4e4b794d9df59684d36d502fd9efe509a867d0efa5127 token impersonation IMPERSONATED-TOKEN-DEPLOYMENT Preparation 0xbc06a40c341aa1acc139c900fd1b7e3999d71b80c13a9dd50a369d8f923757f5 flashbot attack bot FLASHBOT-TRANSACTION Exploitation 0x0f21668ebd017888e7ee7dd46e9119bdd2bc7f48dbabc375d96c9b415267534c smart price change bot SMART-PRICE-CHANGES Preparation 0x11b3d9ffb13a72b776e1aed26616714d879c481d7a463020506d1fb5f33ec1d4 text messages agent forta-text-messages-possible-hack (high severity only) MoneyLaundering 0xfcf3ee41d04eee52f7944387010bc8aa6f22d54c36576c9a05db7e6cafda41f9 balance decrease for bridge: polygon (ether) - Ethereum Mainnet BALANCE-DECREASE-ASSETS-ALL-REMOVED Exploitation 0xca504ee43501fe7c20084aa3112f8f57dd8c1e0e8a85d3884b66c252d6fc4f5b balance decrease for bridge: polygon (ERC20) - Ethereum Mainnet BALANCE-DECREASE-ASSETS-ALL-REMOVED Exploitation 0xa4b00d881c92526ef9a1db39cd3da2b7f32958eab2d7bb807546b7fd1a520748 balance decrease for bridge: Avalanche - Ethereum Mainnet BALANCE-DECREASE-ASSETS-ALL-REMOVED Exploitation 0x942c63db47285d28f01fba0a4e998f815f9784bf246fd981694fd1bcbc0e75c8 balance decrease for bridge: Arbitrum (Ether Gateway) - Ethereum Mainnet BALANCE-DECREASE-ASSETS-ALL-REMOVED Exploitation 0x6f07249485378615abb12b352f7f0e9c68e6bab2de57475b963445e5639fced3 balance decrease for bridge: Arbitrum (ERC20) - Ethereum Mainnet BALANCE-DECREASE-ASSETS-ALL-REMOVED Exploitation 0x4db4efcb505c19e076f1716f9c79d919ffb6a9802769b470e8d461066730c723 balance decrease for bridge: Arbitrum (Custom Gateway) - Ethereum Mainnet BALANCE-DECREASE-ASSETS-ALL-REMOVED Exploitation 0x3f5d0e780a99c3058b58884844e4c71df34b2b739fd957847facc77f69e9f2cc balance decrease for bridge: Near/Aurora (Ether) - Ethereum Mainnet BALANCE-DECREASE-ASSETS-ALL-REMOVED Exploitation 0x59cc55fc71711d81d99be376618e072fa34e1ddbda7401840542d9a584a78d08 balance decrease for bridge: Near/Aurora (ERC20) - Ethereum Mainnet BALANCE-DECREASE-ASSETS-ALL-REMOVED Exploitation 0x94f879d399f7fe7a06682d3abd58a955624ec08b9164c3838851bf6788d27e33 balance decrease for bridge: Optimism V1 - Ethereum Mainnet BALANCE-DECREASE-ASSETS-ALL-REMOVED Exploitation 0x5474812f32fa8206c178864bb7f95f737ab9cdb1e4125af2e86ad8dd8c5fbf31 balance decrease for bridge: Optimism V2 - Ethereum Mainnet BALANCE-DECREASE-ASSETS-ALL-REMOVED Exploitation 0x966929e33d640fead63ed3307ee802e1a45a5b3fabe8c796acf1d6bceb2c757e balance decrease for bridge: Harmony (Ether) - Ethereum Mainnet BALANCE-DECREASE-ASSETS-ALL-REMOVED Exploitation 0xb9008e67f9a2425dc0e11f80d8d26880ec83880b9a169c9542a8e8d74337bb44 balance decrease for bridge: Harmony (ERC20) - Ethereum Mainnet BALANCE-DECREASE-ASSETS-ALL-REMOVED Exploitation 0xee1a0da8184264ed000c2d33f0a6e0df3aa43ad515c21b8320a00aea8c3ae457 balance decrease for bridge: Harmony (BUSD) - Ethereum Mainnet BALANCE-DECREASE-ASSETS-ALL-REMOVED Exploitation 0xe4cee68ce6b2d75ce17a2c727b92838a32e698eacb8848caaf6dade6f9330c12 balance decrease for bridge: xDai - Ethereum Mainnet BALANCE-DECREASE-ASSETS-ALL-REMOVED Exploitation 0xdac6f4a16776648ef48b0c9850800507059e201139c2aa898b47d51ca0ebdaae balance decrease for bridge: Boba - Ethereum Mainnet BALANCE-DECREASE-ASSETS-ALL-REMOVED Exploitation 0x742da1d837ac91905ec470d4e9d92e9c31a3104aa05a014a8f51ba355135bf8a balance decrease for bridge: Ronin - Ethereum Mainnet BALANCE-DECREASE-ASSETS-ALL-REMOVED Exploitation 0x7b69174f32b91731d9b6245faaff945637c47f729a850fa312a27238bc98f383 balance decrease for bridge: THORChain - Ethereum Mainnet BALANCE-DECREASE-ASSETS-ALL-REMOVED Exploitation 0xc10fe54aa93d43702eece2c439550ee079b5fa045aa03e08d47df6a3837e172b balance decrease for bridge: Multichain/Anyswap (ALTA) - BSC BALANCE-DECREASE-ASSETS-ALL-REMOVED Exploitation 0xf947dfa6387710dd316cb9b1afec82d1f49d187426c8f6370000cddc2bec945d balance decrease for bridge: Multichain/Anyswap (USDC) - Ethereum Mainnet BALANCE-DECREASE-ASSETS-ALL-REMOVED Exploitation 0x3d1242fb8af0cdd548e7b5e073534f298f7ddaebbafe931a3506ab0be0e67e87 balance decrease for bridge: Multichain/Anyswap  (Marlin POND) - FTM BALANCE-DECREASE-ASSETS-ALL-REMOVED Exploitation 0x0b069cddde485c14666b35e13c0e0919e6bbb00ea7b0df711e45701b77841492 balance decrease for bridge: Multichain/Anyswap (USDT) - Ethereum Mainnet BALANCE-DECREASE-ASSETS-ALL-REMOVED Exploitation 0x19f468cbd6924a77fcb375a130e3bd1d3764366e42d4d7e6db0717a2229bfeba balance decrease for bridge: Multichain/Anyswap (USDT) - Polygon 0xfcf3ee41d04eee52f7944387010bc8aa6f22d54c36576c9a05db7e6cafda41f9 balance decrease for bridge: polygon (ether) - Ethereum Mainnet BALANCE-DECREASE-ASSETS-PORTION-REMOVED Exploitation 0xca504ee43501fe7c20084aa3112f8f57dd8c1e0e8a85d3884b66c252d6fc4f5b balance decrease for bridge: polygon (ERC20) - Ethereum Mainnet BALANCE-DECREASE-ASSETS-PORTION-REMOVED Exploitation 0xa4b00d881c92526ef9a1db39cd3da2b7f32958eab2d7bb807546b7fd1a520748 balance decrease for bridge: Avalanche - Ethereum Mainnet BALANCE-DECREASE-ASSETS-PORTION-REMOVED Exploitation 0x942c63db47285d28f01fba0a4e998f815f9784bf246fd981694fd1bcbc0e75c8 balance decrease for bridge: Arbitrum (Ether Gateway) - Ethereum Mainnet BALANCE-DECREASE-ASSETS-PORTION-REMOVED Exploitation 0x6f07249485378615abb12b352f7f0e9c68e6bab2de57475b963445e5639fced3 balance decrease for bridge: Arbitrum (ERC20) - Ethereum Mainnet BALANCE-DECREASE-ASSETS-PORTION-REMOVED Exploitation 0x4db4efcb505c19e076f1716f9c79d919ffb6a9802769b470e8d461066730c723 balance decrease for bridge: Arbitrum (Custom Gateway) - Ethereum Mainnet BALANCE-DECREASE-ASSETS-PORTION-REMOVED Exploitation 0x3f5d0e780a99c3058b58884844e4c71df34b2b739fd957847facc77f69e9f2cc balance decrease for bridge: Near/Aurora (Ether) - Ethereum Mainnet BALANCE-DECREASE-ASSETS-PORTION-REMOVED Exploitation 0x59cc55fc71711d81d99be376618e072fa34e1ddbda7401840542d9a584a78d08 balance decrease for bridge: Near/Aurora (ERC20) - Ethereum Mainnet BALANCE-DECREASE-ASSETS-PORTION-REMOVED Exploitation 0x94f879d399f7fe7a06682d3abd58a955624ec08b9164c3838851bf6788d27e33 balance decrease for bridge: Optimism V1 - Ethereum Mainnet BALANCE-DECREASE-ASSETS-PORTION-REMOVED Exploitation 0x5474812f32fa8206c178864bb7f95f737ab9cdb1e4125af2e86ad8dd8c5fbf31 balance decrease for bridge: Optimism V2 - Ethereum Mainnet BALANCE-DECREASE-ASSETS-PORTION-REMOVED Exploitation 0x966929e33d640fead63ed3307ee802e1a45a5b3fabe8c796acf1d6bceb2c757e balance decrease for bridge: Harmony (Ether) - Ethereum Mainnet BALANCE-DECREASE-ASSETS-PORTION-REMOVED Exploitation 0xb9008e67f9a2425dc0e11f80d8d26880ec83880b9a169c9542a8e8d74337bb44 balance decrease for bridge: Harmony (ERC20) - Ethereum Mainnet BALANCE-DECREASE-ASSETS-PORTION-REMOVED Exploitation 0xee1a0da8184264ed000c2d33f0a6e0df3aa43ad515c21b8320a00aea8c3ae457 balance decrease for bridge: Harmony (BUSD) - Ethereum Mainnet BALANCE-DECREASE-ASSETS-PORTION-REMOVED Exploitation 0xe4cee68ce6b2d75ce17a2c727b92838a32e698eacb8848caaf6dade6f9330c12 balance decrease for bridge: xDai - Ethereum Mainnet BALANCE-DECREASE-ASSETS-PORTION-REMOVED Exploitation 0xdac6f4a16776648ef48b0c9850800507059e201139c2aa898b47d51ca0ebdaae balance decrease for bridge: Boba - Ethereum Mainnet BALANCE-DECREASE-ASSETS-PORTION-REMOVED Exploitation 0x742da1d837ac91905ec470d4e9d92e9c31a3104aa05a014a8f51ba355135bf8a balance decrease for bridge: Ronin - Ethereum Mainnet BALANCE-DECREASE-ASSETS-PORTION-REMOVED Exploitation 0x7b69174f32b91731d9b6245faaff945637c47f729a850fa312a27238bc98f383 balance decrease for bridge: THORChain - Ethereum Mainnet BALANCE-DECREASE-ASSETS-PORTION-REMOVED Exploitation 0xc10fe54aa93d43702eece2c439550ee079b5fa045aa03e08d47df6a3837e172b balance decrease for bridge: Multichain/Anyswap (ALTA) - BSC BALANCE-DECREASE-ASSETS-PORTION-REMOVED Exploitation 0xf947dfa6387710dd316cb9b1afec82d1f49d187426c8f6370000cddc2bec945d balance decrease for bridge: Multichain/Anyswap (USDC) - Ethereum Mainnet BALANCE-DECREASE-ASSETS-PORTION-REMOVED Exploitation 0x3d1242fb8af0cdd548e7b5e073534f298f7ddaebbafe931a3506ab0be0e67e87 balance decrease for bridge: Multichain/Anyswap  (Marlin POND) - FTM BALANCE-DECREASE-ASSETS-PORTION-REMOVED Exploitation 0x0b069cddde485c14666b35e13c0e0919e6bbb00ea7b0df711e45701b77841492 balance decrease for bridge: Multichain/Anyswap (USDT) - Ethereum Mainnet BALANCE-DECREASE-ASSETS-PORTION-REMOVED Exploitation 0x19f468cbd6924a77fcb375a130e3bd1d3764366e42d4d7e6db0717a2229bfeba balance decrease for bridge: Multichain/Anyswap (USDT) - Polygon 0xe8527df509859e531e58ba4154e9157eb6d9b2da202516a66ab120deabd3f9f6 attack simulation - Ethereum Mainnet AK-ATTACK-SIMULATION-0 Preparation 0xee275019391109f9ce0de16b78e835c261af1118afeb1a1048a08ccbf67c3ea8 Social Engineering Contract Creation Bot SOCIAL-ENG-CONTRACT-CREATION Preparation 0xd935a697faab13282b3778b2cb8dd0aa4a0dde07877f9425f3bf25ac7b90b895 Malicious Address Bot AE-MALICIOUS-ADDR Exploitation 0x33faef3222e700774af27d0b71076bfa26b8e7c841deb5fb10872a78d1883dba Sleep Minting SLEEPMINT-3 Preparation 0xeab3b34f9c32e9a5cafb76fccbd98f98f441d9e0499d93c4b476ba754f8f0773 Suspicious Contract Creation ML SUSPICIOUS-CONTRACT-CREATION Preparation 0x2e51c6a89c2dccc16a813bb0c3bf3bbfe94414b6a0ea3fc650ad2a59e148f3c8 Anomalous Token Transfers Detection Machine Learning Bot ANOMALOUS-TOKEN-TRANSFERS-TX Exploitation 0xe4a8660b5d79c0c64ac6bfd3b9871b77c98eaaa464aa555c00635e9d8b33f77f Assets Drained FORTA-1 Exploitation 0xaf9ac4c204eabdd39e9b00f91c8383dc01ef1783e010763cad05cc39e82643bb Large Native Token Transfers Out LARGE-TRANSFER-OUT Money Laundering 0x127e62dffbe1a9fa47448c29c3ef4e34f515745cb5df4d9324c2a0adae59eeef Aztec funded contract interaction AK-AZTEC-PROTOCOL-FUNDED-ACCOUNT-INTERACTION-0 Exploitation 0xdccd708fc89917168f3a793c605e837572c01a40289c063ea93c2b74182cd15f Aztec money laundering AK-AZTEC-PROTOCOL-POSSIBLE-MONEY-LAUNDERING-NATIVE Money Laundering 0xf496e3f522ec18ed9be97b815d94ef6a92215fc8e9a1a16338aee9603a5035fb CEX Funding bot CEX-FUNDING-1 Funding 0xdccd708fc89917168f3a793c605e837572c01a40289c063ea93c2b74182cd15f Aztec bot AK-AZTEC-PROTOCOL-DEPOSIT-EVENT Money Laundering 0x887678a85e645ad060b2f096812f7c71e3d20ed6ecf5f3acde6e71baa4cf86ad Token Impersonation ML Bot SUSPICIOUS-TOKEN-CONTRACT-CREATION Funding 0x127e62dffbe1a9fa47448c29c3ef4e34f515745cb5df4d9324c2a0adae59eeef Aztec Funding bot AK-AZTEC-PROTOCOL-FUNDING Funding 0x2df302b07030b5ff8a17c91f36b08f9e2b1e54853094e2513f7cda734cf68a46 Malicious Account Funding Bot MALICIOUS-ACCOUNT-FUNDING Funding 0x186f424224eac9f0dc178e32d1af7be39506333783eec9463edd247dc8df8058 New Account Funding FLD_NEW_FUNDING Funding 0x186f424224eac9f0dc178e32d1af7be39506333783eec9463edd247dc8df8058 Account Funding FLD_FUNDING Funding 0x186f424224eac9f0dc178e32d1af7be39506333783eec9463edd247dc8df8058 Money Laundering FLD_Laundering Money Laundering 0x3858be37e155f84e8e0d6212db1b47d4e83b1d41e8a2bebecb902651ed1125d6 high gas usage NETHFORTA-1 Exploitation 0xbdb84cba815103a9a72e66643fb4ff84f03f7c9a4faa1c6bb03d53c7115ddc4d Text msg sentiment analysis NEGATIVE-ANGER-TEXT-MESSAGE Money Laundering 0xbdb84cba815103a9a72e66643fb4ff84f03f7c9a4faa1c6bb03d53c7115ddc4d Text msg sentiment analysis NEGATIVE-DISGUST-TEXT-MESSAGE Money Laundering 0xbdb84cba815103a9a72e66643fb4ff84f03f7c9a4faa1c6bb03d53c7115ddc4d Text msg sentiment analysis NEGATIVE-SADNESS-TEXT-MESSAGE Money Laundering 0x9324d7865e1bcb933c19825be8482e995af75c9aeab7547631db4d2cd3522e0e ChangeNow Bot FUNDING-CHANGENOW-NEW-ACCOUNT Funding 0x7cfeb792e705a82e984194e1e8d0e9ac3aa48ad8f6530d3017b1e2114d3519ac Large Profit Bot LARGE-PROFIT Exploitation 0x43d22eb5e1e3a2a98420f152825f215e6a756f32d73882ff31d8163652242832 Role change bot ROLE-CHANGE Preparation 0xda967b32461c6cd3280a49e8b5ff5b7486dbd130f3a603089ed4a6e3b03070e2 Suspicious flashloan contract creation SUSPICIOUS-FLASHLOAN-PRICE-MANIPULATOR Preparation <p>The following bots are used to mitigate FPs:</p> BotID Name AlertId 0xabdeff7672e59d53c7702777652e318ada644698a9faf2e7f608ec846b07325b MEV account bot MEV-ACCOUNT 0xa91a31df513afff32b9d85a2c2b7e786fdd681b3cdd8d93d6074943ba31ae400 High funding activity through TC FUNDING-TORNADO-CASH-HIGH 0xd6e19ec6dc98b13ebb5ec24742510845779d9caf439cadec9a5533f8394d435f Positive reputation bot POSITIVE-REPUTATION-1 0xe04b3fa79bd6bc6168a211bcec5e9ac37d5dd67a41a1884aa6719f8952fbc274 Victim Notification bot VICTIM-NOTIFICATION-1 <p>In addition, Etherscan tags are used for FP mitigation.</p>"},{"location":"best-practices/","title":"Best practices","text":"<p>This page describes some of the best practices observed for bot development.</p>"},{"location":"best-practices/#target-specific-conditions","title":"Target specific conditions","text":"<p>Write your bot to target a specific condition so that it does not generate findings for every other block/transaction. Verbose bots can make it hard to distinguish the signal from the noise i.e. if a bot alerts on more than 5% of transactions, the usefulness of those alerts would not be very high as it is difficult to know what to pay attention to.</p>"},{"location":"best-practices/#break-down-large-bots-into-smaller-files","title":"Break down large bots into smaller files","text":"<p>Your bot may be looking for multiple conditions that you could write in a single file. We recommend keeping each condition in its own file. This will make testing your bot easier and keep the code more maintainable. You would then combine all the bots in the top-level entrypoint file (i.e. agent.js). See here for an example.</p>"},{"location":"best-practices/#keep-findings-lean","title":"Keep findings lean","text":"<p>There is a <code>metadata</code> field in the <code>Finding</code> object that you can use to store any extra information that is useful. Try to keep the data here as lean as possible i.e. don't throw the whole <code>TransactionEvent</code> into the metadata since that information is already available on Etherscan.</p>"},{"location":"best-practices/#create-useful-alertids","title":"Create useful alertIds","text":"<p>You are required to populate the <code>alertId</code> field of the <code>Finding</code> object. Ideally, you would want it to be unique so that when you search for your <code>alertId</code> in Forta App it only shows your bot's alerts. Typically, an <code>alertId</code> has a string component (describing either the protocol or project) and a numeric component (to distinguish between different types of alerts about the same protocol or project) e.g. <code>TETHER-1</code>. It is left to the bot developer to choose what makes sense for their bot.</p>"},{"location":"best-practices/#write-unit-tests","title":"Write unit tests","text":"<p>You should write and maintain unit tests for your bot. This will ensure a high quality bar and also allow you to test all edge cases in your bot. Include both negative (i.e. when alerts should not be created) and positive (i.e. when alerts should be created) test cases for completeness.</p> <p>When writing tests that involve log events, you can mock out the <code>filterLog</code> SDK method instead of having to fiddle around with event topics and signatures. See here for an example. You can similarly mock out the <code>filterFunction</code> SDK method when writing tests that involve function calls. See here for an example.</p>"},{"location":"best-practices/#conduct-code-reviews","title":"Conduct code reviews","text":"<p>It is strongly recommended to conduct code reviews within your team. This will help ensure that any bugs are identified and all edge cases are covered by your bot. See the code review checklist for how to conduct a comprehensive review.</p>"},{"location":"best-practices/#include-documentation","title":"Include documentation","text":"<p>Ensure that your project documentation README.md is complete, clear and concise. Briefly describe what your bot does, as well as each type of alert it can produce under which conditions. You should also include real test data that someone could use to verify the bot's behaviour. See the example README.md included with the starter projects for an example.</p>"},{"location":"best-practices/#use-the-initialize-handler","title":"Use the initialize handler","text":"<p>Your bot may need to do some asynchronous initialization when it starts, for example, by fetching data from some external API. You should use the <code>initialize</code> handler function for such logic.</p>"},{"location":"best-practices/#limit-number-of-network-calls","title":"Limit number of network calls","text":"<p>Your bot may need to make network calls to fetch data from external sources e.g. token prices. Be sure to make only the necessary network calls in order to respond in a timely manner. Another useful strategy for this could be to use caching. Also, if querying lots of on-chain data (e.g. token balances for a list of accounts), consider using the <code>ethers-multicall</code> package listed in the Useful libraries section to fetch all the data in a single http request.</p>"},{"location":"best-practices/#use-caching-where-possible","title":"Use caching where possible","text":"<p>Caching is a great way to improve performance. If you need to store the result of a network call or some other calculation, try to use an in-memory cache. The <code>lru-cache</code> package listed in the Useful libraries section is a great option.</p>"},{"location":"best-practices/#use-concurrency-where-possible","title":"Use concurrency where possible","text":"<p>Try to make use of concurrency to maximize performance. For example, if you are firing multiple http requests to fetch on-chain data, you can use the <code>ethers-multicall</code> package to fetch all the data in a single http request. Also, if firing multiple network calls, you can fire all the requests at the same time using something like <code>Promise.all</code> in Javascript.</p>"},{"location":"best-practices/#beware-of-case-sensitivity","title":"Beware of case-sensitivity","text":"<p>When comparing addresses in your code, be mindful of case-sensitivity. The SDK will return addresses in the <code>BlockEvent</code> and <code>TransactionEvent</code> as lowercase, but if you are comparing to a checksum address it will not be equal.</p>"},{"location":"bot-development-patterns/","title":"Index","text":"<ul> <li>Adding labels to findings</li> </ul> <p>Labels provide a way to add more contextual data to findings generated by Forta bots. This information can be used to answer questions like \"which addresses have been involved in flashloan attacks?\" or \"which blocks contain exploits?\". </p> <ul> <li>Error monitoring</li> </ul> <p>While verifying the health of your bot from the status dashboard on Forta App (i.e. <code>https://app.forta.network/bot/YOUR_BOT_ID</code>) is useful information, bot developers may want to integrate their bot into an existing error monitoring solution (e.g. Sentry).</p> <ul> <li>Increasing bot throughput with Sharding</li> </ul> <p>Some detection bots may have difficulty keeping up with the volume of blocks/transactions (either because of the bot's logic or due to the speed of the blockchain being scanned). One solution is to use sharding to increase throughput for your detection bot. With sharding, you can increase the number of instances of your detection bot and split the blocks/transactions across these instances.</p> <ul> <li>Long running tasks</li> </ul> <p>Both <code>handleBlock</code> and<code>handleTransaction</code> functions are required to return within a timeout specified by the network (currently 30 seconds). This should be enough time for most bots to complete, but if you need longer for your bot (e.g. you need to execute many network calls) you can still return findings asynchronously.</p> <ul> <li>Protecting sensitive data</li> </ul> <p>There are cases where developers need to use sensitive information in their bot (e.g. some API key) or just hide their bot code from the public. Developers can still use JWT authentication or code obfuscation as two ways to protect sensitive data.</p> <ul> <li>Private alerts</li> </ul> <p>In certain usecases bot developers may want to keep their generated alerts private. Using encryption, bot developers can publish alerts that are unreadable to anyone but themselves.</p> <ul> <li>JWT authentication for bots</li> </ul> <p>There may be cases where you need to call a private API, perhaps to save some state or load some secret. The SDK provides the methods for generating a JWT token which enables bots to make authorized requests to external APIs.</p> <ul> <li>Deploying machine learning models</li> </ul> <p>This guide will share tips and tricks on deploying a scikit-learn machine learning model in a Python detection bot.</p> <ul> <li>Time series analysis</li> </ul> <p>To create a time series model in Python, the Prophet Library is a good choice. A simple model can be created by querying alerts from other detection bots or holding the timeline data in the bot directly.</p> <ul> <li>Consuming bot alerts</li> </ul> <p>With the addition of the new handleAlert handler, bots are now able to subscribe to alerts from the Forta network. This enables increased composability and higher reuse of existing bots when building your own bot.</p> <ul> <li>Transfer Bot Ownership</li> </ul> <p>Each Bot is an ERC-721 NFT and is minted to the creator of the Bot. This means that the owner can invoke the ERC-721 transferFrom function, and it changes the owner of the Bot.</p> <ul> <li>Transaction simulation</li> </ul> <p>Transaction simulation is a powerful technique that can be used by bot developers to see the results of transactions without having to pay for on-chain execution. Using simulation, you can run transactions from any account on the latest blockchain state and view the results.</p> <ul> <li>Advanced testing</li> </ul> <p>This page describes how to conduct more advanced testing using a locally forked chain.</p> <ul> <li>Querying other chains</li> </ul> <p>Bots can manually read data from any other chain themselves. This page will describe how to interact with any blockchain using a Javascript example bot. </p> <ul> <li>Bot licensing </li> </ul> <p>You are free to adopt the Forta Bot License if you think it fits your purpose! Alternatively, you can adopt any other license you believe is compatible with the technical architecture and spirit of the Forta Network, or no license at all.</p>"},{"location":"bot-licensing/","title":"Bot Licensing","text":"<p>Forta Bot Licensing</p> <p>One of the most powerful features of the Forta Network is that it is permissionless: anyone can use their unique expertise and experience to develop a novel Forta Detection Bot and deploy it to the Network, making its intelligence available to all Web3 users. </p> <p>Assuming that your bot constitutes an original work of authorship under applicable copyright laws (software typically does), you should automatically garner the right to license the use of your bot as you see fit, whether on the Forta Network or anywhere else. With this in mind, the Forta Foundation funded the development of the \u201cForta Bot License\u201d below, with the following goals in mind:</p> <ul> <li>to allow nodes to run your bot in the Network and broadcast alerts</li> <li>to allow users to subscribe to your bot and receive alerts if they comply with the rules of the protocol (e.g. pay the appropriate fees, if any)</li> <li>to allow other bot developers to integrate your bot into theirs, provided that they comply with the rules of the protocol (e.g. pay the appropriate fees, if any)</li> <li>to prevent others from copying or using your bot outside of the Network</li> <li>to limit your liability towards Network participants and users that use your bot</li> <li>to make it clear that you may change your bot or deprecate it</li> </ul> <p>You are free to adopt the Forta Bot License if you think it fits your purpose! Alternatively, you can adopt any other license you believe is compatible with the technical architecture and spirit of the Forta Network, or no license at all. However, by deploying your bot to the Network, other participants in the Network will act as if you are giving an implied license to utilize your bot in accordance with the protocol rules (e.g. nodes will run your bot, users may subscribe to your bot, etc). </p> <p>DISCLAIMER: This information is not intended to constitute legal advice, it is simply provided for general informational purposes only. No one should act or refrain from acting on the basis of information here (or anywhere on this site) without first seeking legal advice from counsel in the relevant jurisdiction.</p> <p>Forta Bot License</p> <p>Copyright \u00a9 2023 Forta Foundation</p> <p>Everyone is permitted to copy, use and distribute verbatim copies of this license document, but changing it is not allowed.</p> <p>Begin license text.</p> <p>Forta Bot License 1.0</p> <p>This Detection Bot License (\u201cAgreement\u201d) governs your use of the detection bot script and associated documentation files made available by each applicable Developer (as defined below) through the Forta Network (\u201cDetection Bot\u201d). The \u201cForta Network\u201d means \\ the collection of smart contracts found at https://github.com/forta-network/forta-contracts that are in production on the Polygon blockchain from time to time.</p> <ol> <li>Detection Bot License. <ol> <li>The legal person or entity controlling the blockchain address listed as the \u201cOwner\u201d of the Detection Bot (\u201cDeveloper\u201d) hereby grants you a perpetual (subject to Sections 2 and 6), worldwide, non-exclusive, non-transferable, non-sublicensable, right to access and use the Detection Bot solely in connection with participating in the Forta Network, including, without limitation, to run the Detection Bot on a node in the Forta Network, in accordance with the terms of this Agreement.</li> <li>The Developer hereby grants you a perpetual (subject to Sections 2 and 6), worldwide, non-exclusive, non-transferable, sublicensable, right to access and use any alerts or other data generated by the Detection Bot (the \u201cDetection Bot Results\u201d), in accordance with the terms of this Agreement. </li> <li>This license shall apply to the Detection Bot so long as it is registered in the Forta Network bot registry smart contract, currently found at the blockchain address 0x61447385B019187daa48e91c55c02AF1F1f3F863, as may be updated from time to time, and has sufficient FORT staked in the Forta Network staking contract, currently found at 0xd2863157539b1D11F39ce23fC4834B62082F6874, as may be updated from time to time. </li> <li>The foregoing licenses are contingent on the payment of applicable fees, if any, published or stated at https://docs.forta.network. You agree to comply with the terms and conditions of any subscription level or fee tier you select and for clarity, any breach thereof shall constitute a material breach of this Agreement and the licenses contained in this Agreement shall immediately terminate in accordance with Section 6 below.  For the avoidance of doubt, you are not authorized to use or otherwise make the Detection Bot available to third parties or to sell or otherwise distribute the Detection Bot Results, other than in accordance with your subscription level or fee tier.</li> <li>You acknowledge that the Detection Bot and Detection Bot Results, and all intellectual property rights therein, including those rights now known or hereafter developed or discovered, are the exclusive property of Developer or its licensors and that the license contemplated herein grants you no title or rights of ownership in the Detection Bot or Detection Bot Results or any components thereof or any other right or license to the foregoing, other than as explicitly set forth herein.  Notwithstanding anything to the contrary in this Agreement, the Detection Bot may include software components provided by a third party that are subject to separate license terms, in which case those license terms will govern such software components.</li> </ol> </li> <li>Availability of the Detection Bot.  Developer reserves the right to change, revise, update, suspend, discontinue, or otherwise modify the Detection Bot at any time, which may impact the Detection Bot Results.  You agree that Developer has no liability whatsoever for any loss or damage caused by your inability to access or use the Detection Bot or Detection Bot Results.  Nothing in this Agreement will be construed to obligate Developer to maintain or support the Detection Bot or to supply any corrections, updates, or releases in connection therewith.</li> <li>Assumption of Risk. <ol> <li>You acknowledge that there are risks associated with the Detection Bot, including that the Detection Bot Results may not be accurate, and you expressly acknowledge and assume all risks.  You further acknowledge that Developer cannot confirm the accuracy of the Detection Bot Results and Developer therefore is not responsible for any consequences related to or negative impacts arising from inaccurate, false, or incomplete Detection Bot Results.  You understand and agree that the Detection Bot and Detection Bot Results are offered on a purely non-reliance basis and at your own risk.  You further acknowledge that the Detection Bot and Detection Bot Results are offered through the Forta Network, which is a decentralized network of independent node operators and other bot developers that interact on a public blockchain over which Developer has no control.</li> <li>You acknowledge that the regulatory regime governing blockchain technologies is uncertain and continually evolving, and new laws, regulations or policies may negatively impact the potential utility of the Detection Bot or Detection Bot Results, and you assume such risk. </li> </ol> </li> <li>Release.  You hereby release Developer from any liability, loss or damage of any nature arising from any risk you assume pursuant to this section, as well as from any liability, loss or damage arising from use of the Detection Bot or reliance on the Detection Bot Results.</li> <li>Limitation of Liability. <ol> <li>DISCLAIMER.  THE DETECTION BOT AND DETECTION BOT RESULTS ARE EACH PROVIDED ON AN \u201cAS IS\u201d AND \u201cAS AVAILABLE\u201d BASIS. YOU AGREE THAT YOUR USE OF THE DETECTION BOT AND DETECTION BOT RESULTS WILL BE AT YOUR SOLE RISK. TO THE FULLEST EXTENT PERMITTED BY LAW, DEVELOPER DISCLAIMS ALL WARRANTIES OF ANY KIND, EXPRESS OR IMPLIED, IN CONNECTION WITH THE DETECTION BOT AND THE DETECTION BOT RESULTS AND YOUR USE THEREOF, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, NONINFRINGEMENT OR TECHNICAL OPERATION OR PERFORMANCE.  DEVELOPER ALSO MAKES NO WARRANTIES OR REPRESENTATIONS ABOUT THE ACCURACY OR COMPLETENESS OF THE DETECTION BOT RESULTS.  </li> <li>NO CONSEQUENTIAL DAMAGES.  IN NO EVENT SHALL DEVELOPER BE LIABLE TO YOU UNDER THIS AGREEMENT (WHETHER IN TORT, IN STRICT LIABILITY, IN CONTRACT, OR OTHERWISE) FOR ANY (I) INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES, INCLUDING DAMAGES FOR LOST PROFITS, EVEN IF DEVELOPER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES, OR (II) DAMAGES THAT EXCEED $100.  THE EXISTENCE OF MORE THAN ONE CLAIM WILL NOT ENLARGE OR EXTEND THESE LIMITS.</li> </ol> </li> <li>Termination.  If you materially breach this Agreement or if you violate any applicable law or regulation, you acknowledge you are prohibited from using the Detection Bot or Detection Bot results thereafter, even if you may be acting on behalf of a third party.</li> </ol> <p>End license text.</p>"},{"location":"bot-transfer-ownership/","title":"Transfer Bot Ownership","text":"<p>Each Bot is an ERC-721 NFT and is minted to the creator of the Bot. This means that the owner can invoke the ERC-721 <code>transferFrom</code> function, and it changes the owner of the Bot.</p> <p>These instructions walk through transferring ownership via the Polygonscan UI.</p> <p>Bot is the same as Agent</p> <p>Forta renamed Agents to Bots, but the smart contract still uses the Agent terminology. They are the same exact thing. An Agent ID is the same as a Bot ID.</p> <p>Transferring does not affect Stake Ownership</p> <p>After transferring ownership, the current stake on the bot is still owned by the previous staker. It is recommended to separately stake on the bot as the new owner, which will allow the previous staker to withdraw their stake without disabling your bot.</p>"},{"location":"bot-transfer-ownership/#transferring-bot-ownership","title":"Transferring Bot Ownership","text":""},{"location":"bot-transfer-ownership/#visit-the-bot-registry","title":"Visit the Bot Registry","text":"<p>https://polygonscan.com/address/0x61447385B019187daa48e91c55c02AF1F1f3F863</p>"},{"location":"bot-transfer-ownership/#click-the-contract-tab-and-write-as-proxy-and-connect-using-connect-to-web-3","title":"Click the Contract tab and Write as Proxy and connect using Connect to Web 3","text":"<p>Connect the Owner Wallet</p> <p>Please connect a wallet that is the current owner or the transaction will not be allowed.  If the owner used the SDK with a local private key, one will need to import that key into Metamask/Wallet to use this site.  The keyfile can be found by running <code>npm run keyfile</code> in your bot project</p>"},{"location":"bot-transfer-ownership/#fill-out-the-transferfrom-command-as-follows","title":"Fill out the <code>transferFrom</code> command as follows","text":"<ul> <li>from: The current owner (must be the connected wallet)</li> <li>to: the new address</li> <li>tokenId: the hexadecimal Bot ID for the bot</li> </ul>"},{"location":"bot-transfer-ownership/#execute-the-transaction-by-clicking-write-and-sign-the-transaction","title":"Execute the transaction by clicking Write and sign the transaction","text":""},{"location":"bot-transfer-ownership/#alternative-to-transferring","title":"Alternative to Transferring","text":"<p>Instead of transferring ownership of a bot, one can also create a new bot and refer to the image of the existing bot.  This mints a new ERC-721 with a new Bot ID.  Any updates to this new bot will not affect the old bot.  </p>"},{"location":"bridge-starter-kit/","title":"Bridge Threat Detection Kit","text":"<p>Frequent Doc Updates</p> <p>Forta will continue to add more curated security bots in the coming months, so stay tuned and come check this page frequently for new updates!</p> Bot Name Bot Details/Template Link Bot Description Anomalous Token Transfers Detection Machine Learning Bot Bot Details Alerts on anomalous transactions with erc2 token transfers. Anomalous Transaction Volume Bot Details Alerts on anomalous transaction volume (both successful and failed). Asset Drained Bot Bot Details Alerts on assets being drained from a contract. Attack Detector Feed (aka Alert Combiner) Bot Details Combines past alerts under a common address to emit a high precision alert around protocol attacks. Bridge Balance Difference Template available on Bot Wizard \ud83e\uddd9 Alerts when the two sides of the bridge are unexpectedly are out of balance. Chainalysis Sanctioned Addresses Bot Details Alerts when a Chainalysis sanctioned account interacts with the address monitored. Exploiter Addresses Bot Details Alerts when known exploiter address interacts with the address monitored. FlashBots Detector Bot Details Alerts when a transaction is routed through FlashBots framework bypassing the mempool. Ice Phishing Detection Bot Bot Details Alerts when ice phishing (social engineer users into token approvals) for a token contract monitored. Large Balance Decreases Template available on Bot Wizard \ud83e\uddd9 Identifies when the balance of an account decreases significantly. Note, this template has been deployed for the following bridges: Polygon, Avalanche, Arbitrum, Near/Aurora, Optimism, Harmony, xDAI, Boba, Ronin, THORChain and Multichain/Anyswap. Mint/Borrow Value Anomalies Bot Details Alerts when mint/borrow volume is changing in a statistically significant way. Monitor Events Template available on Bot Wizard \ud83e\uddd9 Monitors blockchain transactions for specified events emitted from specified contract addresses. This template can be used to alert events emitted from functions that should only be callable by privileged roles. Monitor Function Calls Template available on Bot Wizard \ud83e\uddd9 This bot monitors blockchain transactions for specific function calls to specific contract addresses. This template can be used to alert on function calls that should only be callable by privileged roles. OpenZeppelin-Gnosis Safe Contract Events Bot Details Alerts on security relevant events of the OZ contract library/ Gnosis Safe contact instances. Suspicious Contract Creation Bot Details Alerts on contract creation that contained the address monitored. Time Series Analyzer Template Template available on Bot Wizard \ud83e\uddd9 This template turns an underlying noisy alert representing a time series into a statistically meaningful alert when values become abnormal. Tornado Cash Funded Account Interaction Bot Details Alerts when a Tornado Cash funded account interacts with the address monitored. Unverified Contract Creation Bot Details Alerts on contract creation that isnt verified on Etherscan."},{"location":"bridging-fort/","title":"Bridging FORT tokens","text":"<p>You may need to bridge your FORT tokens from Ethereum to Polygon in order to stake on scan nodes or detection bots. This page will describe how to bridge your FORT tokens.</p> <ol> <li>Go to https://portal.polygon.technology/ connect your wallet and click on Bridge in the left side menu.</li> </ol> <p></p> <ol> <li>Here is where you will be able to configure your token transfer. Make sure that the Transfer From section (indicated as num. 1 in the diagram below) is set to Ethereum. Select the FORT token from the bottom right, you may need to search for the token here. Then enter the total number of FORT tokens you wish to bridge over. The Transfer To section (indicated as num. 2 in the diagram below) must be set to Polygon POS.</li> </ol> <p> </p> <p>Please Note: DO NOT bridge your FORT tokens over to Polygon zkEVM.   You must have some ETH in your wallet in order to pay the gas fee.    The correct contract address for the FORT token on Ethereum is 0x41545f8b9472D758bB669ed8EaEEEcD7a9C4Ec29.   The correct contract address for the FORT token on Polygon is 0xd2863157539b1D11F39ce23fC4834B62082F6874.</p> <ol> <li>Once you have your configuration complete, click on the large purple button at the the bottom that says \"Bridge FORT to Polygon\". Confirm the transaction within your wallet UI. Once the transaction is complete you can begin delegating your FORT to the Forta Network.</li> </ol> <p>Please Note:    Bridging transactions can take around 30 minutes on average to complete. Do not be alarmed if you don't see your FORT tokens on          Polygon immediatley. </p> <p></p> <p>Navigate web3 with confidence by adding the Forta Network Metamask Snap to your wallet. Learn more about how to protect yourself from scams with Forta here.</p>"},{"location":"bware-partnership/","title":"Scan with Bware","text":"<p>Disclosure</p> <p>The following documentation was written by the team at Bware Labs and does not reflect the views of the Forta Foundation.</p>"},{"location":"bware-partnership/#scan-with-blast-api-by-bware-labs","title":"Scan with Blast API by Bware Labs","text":""},{"location":"bware-partnership/#whats-the-problem-and-how-can-it-be-solved","title":"What\u2019s the problem and how can it be solved?","text":"<p>As many of you know, Forta is a blockchain protocol that scans various networks for events indicating malicious activity, with the help of multiple node operators running scan nodes.</p> <p>To run a scan node, you need access to reliable and efficient blockchain endpoints for the networks being scanned. That's where Blast API comes in. We propose that Forta scan nodes use Blast for spinning up blockchain endpoints that would enable running Forta scan nodes.</p>"},{"location":"bware-partnership/#why-use-blast","title":"Why Use Blast?","text":"<p>As the first and primary product developed under the Bware Labs umbrella, Blast is a blockchain API platform that provides easy blockchain access to the most relevant networks in the space. Using Blast, developers are able to get RPC, REST and WebSocket access to an ever-growing number of blockchain networks in just a couple of simple steps.</p> <p>Blast sets itself apart in the blockchain API space by offering exceptional quality, performance, and user-friendliness. It achieves this by decentralizing its infrastructure through the onboarding of third-party node providers. This approach is innovative as it incorporates a reward model for node runners, incentivizing them to participate and enhancing the platform's decentralization. Ultimately, this leads to improved access to supported blockchains.</p>"},{"location":"bware-partnership/#forta-scanner-plan","title":"Forta Scanner Plan","text":"<p>We are pleased to introduce Forta Scanner Plan, a subscription model designed by Bware Labs for Forta Protocol and its community of node operators.</p> <p>This will enable Forta node operators to run a scan node leveraging Blast decentralized API protocol for all the networks supported within the platform.</p> <p>The main benefits of using Forta Scanner Plan in Blast are as follows:</p> <ul> <li> <p>You don\u2019t have to manage your blockchain nodes by yourself and you can spin one in less than 1 minute;</p> </li> <li> <p>You can improve your scan SLAs by having access to all API calls supported including but not limited to trace_block, eth_getlogs and eth_getBlockByNumber</p> </li> <li> <p>You can moderately increase scan SLAs using your Blast endpoints for API calls made by Forta Agents( this practice has already been proven in house)</p> </li> <li> <p>Blast aligns with Forta\u2019s vision of decentralization by fetching blockchain data in a decentralized manner through our onboarded node operators (check blog post)</p> </li> <li> <p>You leverage the best price in the market 25M API calls for only 35$ and it is exclusively available for Forta Node Operators; Each additional 25M API calls you provision will cost 35$. You will be able to scale as you go in case the provisioned amount of calls is not enough. (Eg: 25M = 35$; 50M = 70$; 75M = 105$)</p> </li> <li> <p>You would benefit from a throughput of 50 API calls/s for each 25M API calls you provision</p> </li> </ul>"},{"location":"bware-partnership/#how-to-get-a-blast-endpoint-or-more","title":"How to get a Blast Endpoint? (or more)","text":"<ol> <li> <p>You have to visit our platform first - https://blastapi.io.</p> </li> <li> <p>Click on \u201cLaunch App\u201d button and select \u201cConsumer App\u201d. </p> </li> <li> <p>Connect your MetaMask wallet and sign a message to complete registration. </p> </li> <li> <p>Once you have reached your dashboard, you can create a new project where you'll be able to generate your required endpoints in order to start development. You will be able to create a different project for each network you plan to run scan nodes. </p> </li> <li> <p>Create your first project by clicking \u201cAdd Project\u201d as in the image above, fill in the required details and click on the \"Create Project\" button: </p> </li> <li> <p>Once your project is created, you will be able to navigate to the \"Available Endpoints\" tab and choose any of our supported networks. For this tutorial, we have chosen to create an Ethereum Mainnet endpoint.  </p> </li> <li> <p>Next, you have to choose the network you want to spin an endpoint for Testnet or Mainnet, and click \u201cActivate\u201d. </p> </li> <li> <p>After activating the endpoint you will be redirected to the Active Endpoints\u201d tab where the network you just spin an endpoint for will be displayed.  </p> </li> <li> <p>Now you can click on the above button and get the endpoint URLs. </p> </li> </ol> <p>You can also check our docs and tutorial for spinning an endpoint.</p>"},{"location":"bware-partnership/#how-to-get-access-to-forta-scanner-plan","title":"How to get access to Forta Scanner Plan?","text":"<p>Simply fill out this one-minute form and leave the rest to us. Your Forta Scanner Plan will be assigned in \u201cMy Plan\u201d tab in 2 days, at most, since form submission.</p>"},{"location":"bware-partnership/#scan-all-supported-networks-with-blast","title":"Scan all supported networks with Blast.","text":"<p>If you have not yet installed Forta on your terminal, we recommend going through the quickstart guide to start your Forta scan node. </p> <p>Once you have initialized your Forta directory, you will find a file called config.yml. This file needs to be configured so that your scan node can access the blockchain data.</p> <p>To enable Forta detection bots to call JSON-RPC APIs using the configured RPC endpoints and chain ID, you will need to initialize the scan.jsonRpc.url property in the config.yml file with the Blast RPC URL obtained in the previous section.</p> <p>To do this, simply open the config.yml file in your Forta directory and copy the Blast RPC URL into the jsonRpc property. With this setup, your Forta scan node will be able to effectively pull data from the blockchain and identify any events indicating malicious activity.</p>"},{"location":"bware-partnership/#ethereum","title":"Ethereum","text":"<pre><code>chainId: 1\n\nscan:\n  jsonRpc:\n    url: https://eth-mainnet.blastapi.io/&lt;UID&gt;\n\ntrace:\n    jsonRpc:\n    url: https://eth-mainnet.blastapi.io/&lt;UID&gt;\n</code></pre>"},{"location":"bware-partnership/#polygon","title":"Polygon","text":"<pre><code>chainId: 137\n\nscan:\n  jsonRpc:\n    url: https://polygon-mainnet.blastapi.io&lt;UID&gt;\n\ntrace:\n    jsonRpc:\n    url: https://polygon-mainnet.blastapi.io&lt;UID&gt;\n</code></pre>"},{"location":"bware-partnership/#optimism","title":"Optimism","text":"<pre><code>chainId: 10\n\nscan:\n  jsonRpc:\n    url: https://optimism-mainnet.blastapi.io/&lt;UID&gt;\n\ntrace:\n    url: https://optimism-mainnet.blastapi.io/&lt;UID&gt;\n</code></pre>"},{"location":"bware-partnership/#arbitrum","title":"Arbitrum","text":"<pre><code>chainId: 42161\n\nscan:\n  jsonRpc:\n    url: https://arbitrum-one.blastapi.io/&lt;UID&gt;\n\ntrace:\n    url: https://arbitrum-one.blastapi.io/&lt;UID&gt;\n</code></pre>"},{"location":"bware-partnership/#binance-chain","title":"Binance Chain","text":"<pre><code>chainId: 56\n\nscan:\n  jsonRpc:\n    url: wss://bsc-mainnet.blastapi.io/&lt;UID&gt;\n\ntrace:\n    url: wss://bsc-mainnet.blastapi.io/&lt;UID&gt;\n</code></pre>"},{"location":"cli/","title":"CLI Commands","text":"<p>The following sections describe the CLI commands available to bot developers. You can always use <code>forta-agent help</code> to get a quick overview of these commands, as well as details about specific commands e.g. <code>forta-agent run help</code>.</p>"},{"location":"cli/#invoke-commands-programmatically","title":"Invoke commands programmatically","text":"<p>You can invoke the available CLI commands programmatically in NodeJS using the exported <code>configureContainer</code> method. This method returns a dependency injection container that can be used to access different commands. It accepts an optional object of arguments that will configure its behaviour, the most important of which is <code>contextPath</code> which points to the bot directory that you are running commands for (defaults to current working directory if not specified). For example, if you wanted to invoke the <code>init</code> command it would look like the following:</p> <pre><code>const { configureContainer } = require(\"forta-agent\");\n\nconst pathToBotDirectory = \"/Desktop/my-bot\";\nconst container = configureContainer({ contextPath: pathToBotDirectory });\nconst init = container.resolve(\"init\");\nawait init();\n</code></pre> <p>The above code snippet will initialize a Forta bot at the specified <code>contextPath</code> (creating the folder if it does not exist). All the CLI commands are asynchronous so you will need to <code>await</code> them. Similarly, you can resolve other commands that are listed below.</p> <p>Exposing the CLI functionality enables developers to integrate with other tools. The first example of such an integration is the Forta Hardhat plugin. We look forward to seeing the new and creative ways developers will integrate this functionality into their own toolset!</p>"},{"location":"cli/#init","title":"init","text":"<p>Using the <code>npx forta-agent@latest init</code> command, you can quickly initialize a Forta bot Javascript project inside of the current working directory. The starter project includes some default configuration files as well as an example bot implementation. A keyfile and forta.config.json file will also be generated for you and placed in the ~/.forta folder if they do not already exist. You will be prompted to enter a password that will be used to encrypt the keyfile. This keyfile will be used later when publishing your bot.</p> <p>Options:</p> <pre><code>--typescript - initialize Typescript project\n--python - initialize Python project\n</code></pre> <p>Example: Initialize a Typescript Project</p> <pre><code>$ npx forta-agent@latest init --typescript\n</code></pre>"},{"location":"cli/#run","title":"run","text":"<p>Easily verify the behaviour of your bot during local development using the <code>forta-agent run</code> command. The default behaviour (i.e. without any options) is to subscribe to a JSON-RPC endpoint and listen for the latest blocks and transactions. A stream of the latest data will be passed to your bot with any findings printed to your output console. The endpoint is specified by the <code>jsonRpcUrl</code> property in the forta.config.json file.</p> <p>Options:</p> <pre><code>--tx - run your bot with a specific transaction hash\n--block - run your bot against a specific block number/hash, including the transactions in the block\n--alert - run your bot against a specific Forta alert hash\n--sequence - run your bot against a sequence of tx/block/alert events\n--range - run your bot against a specific range of block numbers\n--file - run your bot against a JSON file of test data\n--prod - used for running the bot inside of a production environment i.e. you probably won\u2019t need this during development\n--config - specify a config file to use (default: ~/.forta/forta.config.json)\n--nocache - disables writing block/tx data to local disk cache (but reads are still enabled)\n</code></pre> <p>Example: Run a specific transaction (or a comma-delimited list)</p> <pre><code>$ forta-agent run --tx 0xf9c43e15ef2abfec163ec3b1165f18a5119ba119b6e059fc924903e5251e3543\n</code></pre> <p>or if using locally installed package</p> <pre><code>$ npm run tx 0xf9c43e15ef2abfec163ec3b1165f18a5119ba119b6e059fc924903e5251e3543\n</code></pre> <p>Example: Run a specific block by number (or a comma-delimited list)</p> <pre><code>$ forta-agent run --block 12821978\n</code></pre> <p>or if using locally installed package</p> <pre><code>$ npm run block 12821978\n</code></pre> <p>Example: Run a specific block by hash (or a comma-delimited list)</p> <pre><code>$ forta-agent run --block 0x9e052eb02a3849b650e8b9e0a47b1fae194b928c930168ef19e311dbd7886172\n</code></pre> <p>or if using locally installed package</p> <pre><code>$ npm run block 0x9e052eb02a3849b650e8b9e0a47b1fae194b928c930168ef19e311dbd7886172\n</code></pre> <p>Example: Run a specific Forta alert (or a comma-delimited list)</p> <pre><code>$ forta-agent run --alert 0x40ba810affa9ae3df9420be08fdb2f5db1122ce6a3ea8f6ec87016905d870082\n</code></pre> <p>or if using locally installed package</p> <pre><code>$ npm run alert 0x40ba810affa9ae3df9420be08fdb2f5db1122ce6a3ea8f6ec87016905d870082\n</code></pre> <p>Example: Run a sequence of blocks, transactions and Forta alerts</p> <pre><code>$ forta-agent run --sequence 0x40ba810affa9ae3df9420be08fdb2f5db1122ce6a3ea8f6ec87016905d870082,12821978,tx0xf9c43e15ef2abfec163ec3b1165f18a5119ba119b6e059fc924903e5251e3543\n</code></pre> <p>or if using locally installed package</p> <pre><code>$ npm run sequence 0x40ba810affa9ae3df9420be08fdb2f5db1122ce6a3ea8f6ec87016905d870082,12821978,tx0xf9c43e15ef2abfec163ec3b1165f18a5119ba119b6e059fc924903e5251e3543\n</code></pre> <p>Example: Run a specific block range</p> <pre><code>$ forta-agent run --range 12821978..12821980\n</code></pre> <p>or if using locally installed package</p> <pre><code>$ npm run range 12821978..12821980\n</code></pre> <p>Example: Run an input file</p> <pre><code>$ forta-agent run --file ./test.data.json\n</code></pre> <p>or if using locally installed package</p> <pre><code>$ npm run file ./test.data.json\n</code></pre>"},{"location":"cli/#publish","title":"publish","text":"<p>Deploy your bot to the Forta network using the <code>forta-agent publish</code> command. This will build a Docker image for your bot and publish it to the image repository. Also, it will create a bot manifest which includes the Docker image reference, sign the manifest using your keyfile (you will be prompted for password), store it on IPFS and publish the IPFS reference to the Bot Registry contract.</p> <p>Options:</p> <pre><code>--config - specify a config file to use (default: forta.config.json)\n</code></pre>"},{"location":"cli/#push","title":"push","text":"<p>Push your bot image to a repository where scan nodes can find it. This will build and push your Docker bot image (but will not add it to the bot registry). Intended to be used as part of the Forta App bot deployment flow.</p> <p>Options:</p> <pre><code>--config - specify a config file to use (default: forta.config.json)\n</code></pre>"},{"location":"cli/#stake","title":"stake","text":"<p>Stake on your detection bot to make it operational on the Forta Network. This command will deposit a stake of 100 FORT tokens on your detection bot (if not already staked).</p> <p>Options:</p> <pre><code>--agentId - specify an agent ID to stake on (defaults to this bot)\n</code></pre>"},{"location":"cli/#logs","title":"logs","text":"<p>Retrieves logs for specified bot id and prints them to the console. The default <code>agentId</code> is read from <code>forta.config.json</code> unless specified.</p> <p>Options (optional):</p> <pre><code>--agentId - Specify a bot id to request logs for\n\n--before - An ISO timestamp [YYYY-MM-DDTHH:mmZ] representing the latest time to include in logs\n\n--after - An ISO timestamp [YYYY-MM-DDTHH:mmZ] representing the oldest time to include in logs\n\n--scannerId - Filter to only return logs of a given scannerId\n</code></pre>"},{"location":"cli/#info","title":"info","text":"<p>Inspect the state of your bot. This command prints the bot's IPFS metadata to the console as well as recent bot events. The default <code>agentId</code> is read from <code>forta.config.json</code> unless specified.</p> <p>Bot events include:</p> <ul> <li>Bot Created</li> <li>Bot Enabled/Disabled</li> <li>Bot Updated</li> </ul> <p>Options (optional):</p> <pre><code>--agentId - Specify a bot id to request info about\n</code></pre>"},{"location":"cli/#disable","title":"disable","text":"<p>Disable your deployed bot and stop it from running on the Forta network by using <code>forta-agent disable</code>. Your Docker image will still be publicly available, but scan nodes will know not to run your bot.</p>"},{"location":"cli/#enable","title":"enable","text":"<p>Enable your bot and start execution on the Forta network by using <code>forta-agent enable</code>. By default, your bot is enabled when you deploy to the Forta network. Only use this command if your bot is currently disabled.</p>"},{"location":"cli/#keyfile","title":"keyfile","text":"<p>You can print out information about your keyfile, including its absolute path and address, using the <code>forta-agent keyfile</code> command.</p>"},{"location":"concepts/","title":"Core Concepts","text":""},{"location":"concepts/#forta-network","title":"Forta Network","text":"<p>The Forta Network refers to the distributed and decentralized nodes collaborating to provide threat detection and prevention for smart contract transactions on supported blockchains, coordinated through a set of smart contracts deployed across multiple blockchains. One specific type of node is the scan node. The collection of all nodes and smart contracts is referred to as the Forta Network.</p>"},{"location":"concepts/#scan-nodes","title":"Scan Nodes","text":"<p>A scan node is a specific type of Forta node that executes detection bots for every transaction and every new block on a specific blockchain network. The scan node manages and coordinates bots (e.g. by instantiating and running bots, and restarting bots that become unresponsive). The scan node ferries blockchain data to bots to process the transaction/block. To learn more about scan nodes, see our FAQ section.</p>"},{"location":"concepts/#detection-bots","title":"Detection Bots","text":"<p>Detection bots refer to a set of code scripts within a Docker container that process some blockchain data (i.e. a block or transaction) and detect specific threat conditions (e.g. whether a flash loan attack occured, or whether a particular account balance fell below some threshold). Bots emit alerts for their findings. Bots are executed by scan nodes. To learn more about bots, see our FAQ section.</p>"},{"location":"concepts/#bot-registry","title":"Bot Registry","text":"<p>The Bot Registry refers to a smart contract (currently deployed on the Polygon public mainnet) that records the existence of all detection bots. Developers publish their bot manifests to this registry, and scan nodes listen for events from this contract to know how to manage the bots they are running.</p>"},{"location":"concepts/#bot-manifest","title":"Bot Manifest","text":"<p>A bot manifest refers to a signed JSON document that describes the contents of a bot container. Specifically, it provides information like the bot version as well as an IPFS reference to the bot container image. Manifests are stored on the IPFS network, with their IPFS references stored in the Bot Registry.</p>"},{"location":"concepts/#disco","title":"Disco","text":"<p>Disco is an open-source, decentralized and distributed container registry. This registry is used to store and distribute bot container images. Scan nodes request bot images from a Disco repository.</p>"},{"location":"config/","title":"forta.config.json","text":"<p>The forta.config.json file is a shared global config located in ~/.forta that provides configuration for your bot projects. You can optionally override any value for a specific bot project by providing a forta.config.json file in your project folder. Also, if you want to use a specific config file during local development, you can do so using the <code>--config</code> CLI flag. </p> <p>Securing sensitive information</p> <p>Since the config file can contain sensitive information (e.g. Infura API keys), you should not commit it into version control. </p> <p>Here are the following supported configuration properties:</p> <ul> <li><code>jsonRpcUrl</code> - for local development only; allows you to run your bot against data from a specific JSON-RPC endpoint</li> <li><code>traceRpcUrl</code> - for local development only; allows you to retrieve trace data from the specified JSON-RPC endpoint</li> <li><code>ipfsGatewayUrl</code> - optional; used to specify a IPFS gateway to upload your bot manifest when publishing</li> <li><code>ipfsGatewayAuth</code> - optional; provide an authorization header if your IPFS gateway requires one</li> <li><code>agentRegistryJsonRpcUrl</code> - optional; used to access the network where the Bot Registry is deployed (i.e. Polygon)</li> <li><code>imageRepositoryUsername</code> - optional; provide authorization username when pushing to an image repository</li> <li><code>imageRepositoryPassword</code> - optional; provide authorization password when pushing to an image repository</li> <li><code>keyfile</code> - optional; specify the name of a keyfile in ~/.forta to use for publishing (by default we assume there is only one keyfile)</li> <li><code>keyfilePassword</code> - optional; specify the password to decrypt the keyfile, useful for CI/CD pipelines</li> <li><code>agentId</code> - optional; specify the agentId of this bot, to be used for bos deployed with Forta App</li> <li><code>fortaApiKey</code> - optional; specify your Forta API key for local development (required if using the <code>getAlerts</code> or <code>getLabels</code> SDK method, or the <code>handleAlerts</code> handler)</li> </ul>"},{"location":"contest1-compound/","title":"Compound Contest (10/20/2021)","text":"<p>Forta is thrilled to announce that we\u2019ve partnered with Compound Grants to bring you our first bot development contest!</p> <p>Below you will find five challenges. Each challenge has a specific security concern that a Forta bot can solve, provided by Compound. Next to each challenge is a link to a Google Form, which you may use to submit a bot you develop that meets the challenge requirements to the contest judges.</p> <ul> <li> <p>Only the first ten (10) submissions to each challenge that meet the challenge requirements below will be considered.</p> </li> <li> <p>After ten valid submissions are received, the Google Form will be closed and you will be unable to submit any further bots, so work fast!</p> </li> <li> <p>As long as submissions are still open, you are welcome to build bots for as many of these challenges as you can!</p> </li> <li> <p>Each winning bot will receive $1500 in COMP tokens, and a unique Forta NFT which will be provided at a later date when our NFT\u2019s become available.</p> </li> <li> <p>To be eligible for a prize, you will be asked to submit a valid email and discord username through the google form, along with your bot.</p> </li> <li> <p>This contest will run from Oct. 20th through Oct. 27th, after which no further submissions will be considered.</p> </li> <li> <p>Winners will be chosen by a panel of bot reviewers from Forta community member Nethermind, and will be announced on Oct. 29th.</p> </li> <li> <p>For any questions, please contact a Forta Moderator on Discord.</p> </li> </ul> <p>Check out Compound docs for more information on Compound Protocol: https://compound.finance/docs</p>"},{"location":"contest1-compound/#challenges-winners","title":"Challenges &amp; Winners","text":"<ul> <li> <p>Provide alert if cToken exchange rate goes down. https://forms.gle/aTpwYWHA15YfdhLeA</p> <ul> <li>Winner: @jmederos</li> <li>Winning bot: https://github.com/jmederosalvarado/compound-ctoken-exrate-down</li> </ul> </li> <li> <p>Provide alert for large/unusual transfers out of Comptroller Contract. https://forms.gle/uuSTj6Wd7xCBR21W6</p> <ul> <li>Winner: @kovart</li> <li>Winning bot: https://github.com/kovart/challenge-2</li> </ul> </li> <li> <p>Provide alert for blacklisted address interacting with Compound Protocol. https://forms.gle/B9dwaAYvddUsnDBV6</p> <ul> <li>Winner: @kovart</li> <li>Winning bot: https://github.com/kovart/challenge-3</li> </ul> </li> <li> <p>Provide alert for governance proposal advancing through approval process and implementation. https://forms.gle/izaXz2KRRDUe4bkQA</p> <ul> <li>Winner: @kovart</li> <li>Winning bot: https://github.com/kovart/challenge-4</li> </ul> </li> <li> <p>Provide alert for 10% or more change in Utilization Rate within a 60 minute window in a given pool. https://forms.gle/WKhGJmJDHYJJzNe68</p> <ul> <li>Winner: @rsproule</li> <li>Winning bot: https://github.com/BlockchainCapitalLLC/forta-agent-challenge/tree/main/utilization-rate</li> </ul> </li> </ul>"},{"location":"contest10-forta/","title":"Forta Contest 6 (11/8/2022)","text":"<p>The Forta Foundation is thrilled to announce a new Bot Development Contest, this time diving into end user protections. Submit your entries for this contest HERE.</p> <p>Forta Detection bots are pieces of logic (scripts) that look for certain transaction characteristics or state changes (e.g. anomaly detection) on smart contracts across any supported chain. Nodes run detection bots against each block of transactions. When the bots detect a specific condition or event, the network emits an alert which is stored on IPFS. For more information on creating your first detection bot, check out our quickstart guide and video tutorials.</p> <p>Forta Detection Bot Development contests are mini-hackathons where everyone is welcome to submit a detection bot and compete for prizes. Contest discussion, support, and announcements are available on Forta\u2019s Discord.</p>"},{"location":"contest10-forta/#rules","title":"Rules","text":"<ul> <li>You will find one challenge listed below. The challenge has a specific security concern that a Forta detection bot monitors for. Please submit your completed bots to the contest judges through the Google form linked above and on Forta App.</li> <li>Only the first ten (10) QUALIFIED submissions to the challenge that meet the requirements below will be considered.</li> <li>After ten qualified submissions are received for the challenge, we will close the form and announce it on the #contests channel at Discord. As long as submissions are open, you are welcome to build and submit detection bots!</li> <li>All developers that submit a qualifying detection bot will receive a Forta NFT.</li> <li>Cash prizes will be awarded to the winner and runner-up of the challenge:<ul> <li>1st place will receive $5,000 USD (paid in FORT) and a unique Forta NFT.</li> <li>2nd place will receive $1,000 USD (paid in FORT) and a unique Forta NFT.</li> <li>3rd place will receive $500 USD (paid in FORT) and a unique Forta NFT.</li> </ul> </li> <li>To be eligible for a prize, you will be asked to submit a valid email and Discord username through the Google form, along with a link of your bot on Github.</li> <li>This contest will run from Nov 7st through Nov 21st, after which no further submissions will be considered.</li> <li>Winners will be chosen by a panel of detection bot reviewers from Nethermind, and will be announced on November 30th.</li> </ul> <p>For any questions, please contact a Forta Moderator on Discord.</p>"},{"location":"contest10-forta/#assessment-criteria","title":"Assessment Criteria","text":"<ul> <li>Bot implementation<ul> <li>Does the code correctly alert according to the challenge description?</li> <li>Does the code make appropriate use of Forta SDK and built-in functions?</li> <li>Does the bot operate on all Forta supported chains?</li> <li>Does the code contain comments?</li> <li>Is the code well-formatted and easy to read?</li> </ul> </li> <li>Alert efficacy<ul> <li>How well does the bot perform its task? A curated set of past attacks will be used to assess. Note, since these bots are used to join with other bots, noise level is not a concern.</li> </ul> </li> <li>Testing<ul> <li>Do all tests run and pass?</li> <li>Are there negative test cases? i.e. when alerts should not be created</li> <li>Are there positive test cases? i.e. when alerts should be created</li> </ul> </li> <li>Documentation<ul> <li>Does the README.md have a concise description of bot functionality?</li> <li>Does the README.md contain well-formatted descriptions of each alert?</li> <li>(If Applicable) Does the README.md contain real blocks/transactions that will trigger alerts?</li> <li>Does the package.json contain an appropriate name and description?</li> </ul> </li> </ul> <p>See Forta\u2019s Code Review checklist for a detailed description of how to develop a high quality bot.</p>"},{"location":"contest10-forta/#challenges","title":"Challenges","text":"<p>Anomalous funding and Money Laundering are essential steps attackers take when attacking a protocol or end users. </p> <p>Funding is the first signal emitted about an attacker for imminent attacks. Detection coverage is of utmost importance, but existing detection bot coverage is limited to protocol specific bots, like Tornado Cash and Aztec.</p> <p>The goal of this contest is to develop a detection bot that identifies mixers, bridges, exchanges generically, such that any funding and money laundering activities from those protocols can be flagged. Note, that mixers and bridges have a some of the following characteristics, which could be incorporated in the bot logic: - Many deposits and withdrawals - Withdrawals often are deposited to brand new EOAs - The mixers/ bridges have existed for some time  - Mixers and bridges are often flagged in block explorers with appropriate tags  - They have been used by attackers in the past</p> <p>The bot should emit two alerts: 1. Address is funded by a likely mixer/bridge/exchange. This alert should emit two types of alerts: one alert on newly funded accounts and one on existing accounts being funded. Differentiating bridges, mixers, exchanges should be made in the alert. Note, the bot should not use any hard coded addresses. 2. Address is engaged in money laundering behavior using a likely mixer/bridge/exchange. This alert should be configurable per the US dollar value of the tokens being laundered. Differentiating bridges, mixers, exchanges should be made in the alert. Note, the bot should not use any hard coded addresses.</p>"},{"location":"contest2-aave/","title":"Aave Contest (11/3/2021)","text":"<p>Forta is thrilled to announce that we\u2019ve partnered with Aave Grants DAO to bring you our second bot development contest!</p> <p>Below you will find five challenges. Each challenge has a specific security concern that a Forta bot can solve, provided by Aave. Next to each challenge is a link to a Google Form, which you may use to submit a bot you develop that meets the challenge requirements to the contest judges.</p> <ul> <li> <p>Only the first ten (10) submissions to each challenge that meet the challenge requirements below will be considered.</p> </li> <li> <p>After ten valid submissions are received, the Google Form will be closed and you will be unable to submit any further bots, so work fast! As long as submissions are still open, you are welcome to build bots for as many of these challenges as you can!</p> </li> <li> <p>Each winning bot will receive $1000 in AAVE tokens, and a unique Forta NFT which will be provided at a later date when our NFT\u2019s become available. To be eligible for a prize, you will be asked to submit a valid email and discord username through the google form, along with your bot.</p> </li> <li> <p>This contest will run from Nov 3rd through Nov 10th, after which no further submissions will be considered.   Winners will be chosen by a panel of bot reviewers from Forta community member Arbitrary Execution, and will be announced on Nov 12th.</p> </li> <li> <p>For any questions, please contact a Forta Moderator on Discord.</p> </li> </ul> <p>Check out the Aave liquidity protocol and the Aave Grants DAO for more information: https://governance.aave.com/</p>"},{"location":"contest2-aave/#challenges","title":"Challenges","text":"<ul> <li> <p>Alert if getFallbackOracle() function is called. https://forms.gle/oxM2zPVJdfWziuPA6</p> <ul> <li>Winner: @kovart</li> <li>Winning bot: https://github.com/kovart2/challenge-1</li> </ul> </li> <li> <p>Alert if getFallbackOracle() returns a price that deviates more than 10% from last price delivered by getAssetPrice(). https://forms.gle/jN1K43GYd6SjfJL99</p> <ul> <li>Winner: @kovart</li> <li>Winning bot: https://github.com/kovart2/challenge-2</li> </ul> </li> <li> <p>Alert if aUSDC / aDAI exchange rate goes down. https://forms.gle/yNyu5rfsDm8PHkNaA</p> <ul> <li>Winner: @vvlovsky</li> <li>Winning bot: https://github.com/VVlovsky/forta-aave-agents/tree/main/exchange_rate_goes_down</li> </ul> </li> <li> <p>Alert if flash loan transaction value \u2265 $10m. https://forms.gle/eAeB9zziRDw99ssS8</p> <ul> <li>Winner: @kovart</li> <li>Winning bot: https://github.com/kovart2/challenge-5</li> </ul> </li> <li> <p>Alert if governance proposal is EXECUTED. https://forms.gle/TnhhwTyG7FNoNBdh9</p> <ul> <li>Winner: @vvlovsky</li> <li>Winning bot: https://github.com/VVlovsky/forta-aave-agents/tree/main/governance</li> </ul> </li> </ul>"},{"location":"contest3-oz/","title":"OpenZeppelin Contest (11/18/2021)","text":"<p>Forta is thrilled to announce that we\u2019ve partnered with OpenZeppelin to bring you our third bot development contest!</p> <p>Submit your entries for this contest HERE.</p> <p>Forta bots are code scripts written in Python or Javascript that trigger alerts when certain conditions are met. The best bots trigger alerts when specific conditions indicate that a potential hack or exploit may be taking place and help end users prevent them. For more information on creating your first bot, check out our Quickstart Guide.</p> <p>Forta bot developer contests are mini-hackathons where anyone is able to submit a bot and be rewarded in NFTs, and crypto!</p> <p>Contest discussion group and announcements are available on our Discord here.</p> <p>You will find two challenges listed below. Each challenge has a specific security concern that a Forta bot monitors for. Please submit your completed bots to the contest judges through the Google form linked above and on connect.forta.network.</p> <ul> <li> <p>Only the first twenty five (25) QUALIFIED submissions to each challenge that meet the challenge requirements below will be considered.</p> </li> <li> <p>After twenty five qualified submissions are received for an individual challenge, we will close the challenge and announce it in the #agent-development-contest channel in Discord! As long as submissions are still open, you are welcome to build and submit bots for both challenges!</p> </li> <li> <p>All developers that submit a qualifying bot will receive a Forta NFT.</p> </li> <li> <p>Cash prizes will be awarded to the 1st, 2nd, and 3rd place bots in each challenge.</p> <ul> <li>1st place will receive $1500 in USDC and a unique Winners Forta NFT.</li> <li>2nd place will receive $750 in USDC and a unique Winners Forta NFT.</li> <li>3rd place will receive $250 in USDC and a unique Winners Forta NFT.</li> </ul> </li> <li> <p>To be eligible for a prize, you will be asked to submit a valid email and discord username through the Google form, along with your bot.</p> </li> <li> <p>This contest will run from November 18th through December 2nd, after which no further submissions will be considered. Winners will be chosen by a panel of bot reviewers from Forta community member Nethermind, and will be announced on December 4th.</p> </li> <li> <p>For any questions, please contact a Forta Moderator on Discord.</p> </li> </ul>"},{"location":"contest3-oz/#assessment-criteria","title":"Assessment Criteria","text":"<ul> <li> <p>Bot implementation</p> <ul> <li>Does the code correctly alert according to the challenge description?</li> <li>Does the code make appropriate use of Forta SDK and built-in functions?</li> <li>Does the code contain comments?</li> <li>Is the code well-formatted and easy to read?</li> </ul> </li> <li> <p>Testing</p> <ul> <li>Do all tests run and pass?</li> <li>Are there negative test cases? i.e. when alerts should not be created</li> <li>Are there positive test cases? i.e. when alerts should be created</li> </ul> </li> <li> <p>Documentation</p> <ul> <li>Does the README.md have a concise description of bot functionality?</li> <li>Does the README.md contain well-formatted descriptions of each alert?</li> <li>(If Applicable) Does the README.md contain real blocks/transactions that will trigger alerts?</li> <li>Does the package.json contain an appropriate name and description?</li> </ul> </li> </ul> <p>Check out OpenZeppelin.com for more information on our sponsor!</p>"},{"location":"contest3-oz/#challenges","title":"Challenges","text":"<ol> <li> <p>TimelockController</p> <p>The first vulnerability concerns the TimelockController contract.</p> <p>By exploiting this vulnerability, someone with the executor role could escalate privileges and become admin of the timelock. In the worst scenario, if the executor role was not granted to a set of trusted accounts but left \"open\" unrestricted, an arbitrary attacker could take full control of the timelock.</p> <p>For a detailed description of the issue refer to the post-mortem.</p> <p>The basic way that the exploit can be detected using a Forta bot is based on the particular sequence of events (logs) that it emits. As part of the execution of a batch proposal, at least the following things need to happen in this order: first the timelock delay is set to 0 emitting the events <code>MinDelayChange(\\_, 0)</code> and <code>CallExecuted(id, ...)</code>, then this proposal is scheduled emitting the event <code>CallScheduled(id, ...)</code> where the id is the same as seen in the previous event. Observe that for the same proposal id <code>Executed</code> is seen before <code>Scheduled</code>, which is a violation of the expected lifecycle of a proposal. If this is observed, an alert should be generated.</p> <p>The above rules identify this particular exploit, but as a bonus challenge it would be interesting to alert more generally on a potential privilege escalation situation by monitoring for batch proposals where an executor becomes a proposer or admin, all but one of the proposers and executors are removed, etcetera. Other ideas are welcome.</p> <p>Note: This attack has not, as far as we know, been executed on chain.</p> <ul> <li>Winner: @kovart#3924</li> <li>Winning bot: https://github.com/kovart3/contest-3-1</li> <li>2nd Place: @vvlovsky#6572</li> <li>2nd Place bot: https://github.com/VVlovsky/TimelockController-Exploit-Agent</li> <li>3rd Place: @Roderick#4932</li> <li>3rd Place bot: https://github.com/rodrigo-pino/timelock-agent-ts</li> </ul> </li> <li> <p>UUPSUpgradeable</p> <p>The second vulnerability concerns the UUPSUpgradeable contract.</p> <p>By exploiting this vulnerability, an attacker could trigger a selfdestruct of a UUPS implementation contract, leaving a proxy contract permanently broken.</p> <p>For a detailed description of the issue refer to the post-mortem.</p> <p>In order to detect an attack, a bot needs to find <code>Upgraded(address)</code> events and then retrieve the code of the contract that emitted the event. If the code is empty, this means that the contract was selfdestructed, and an alert should be emitted.</p> <ul> <li>Winner: @karmacoma#4155</li> <li>Winning bot: https://github.com/karmacoma-eth/forta-uups-agent</li> <li>2nd Place: @kovart#3924</li> <li>2nd Place bot: https://github.com/kovart3/contest-3-2</li> <li>3rd Place: @nfmelendez#2069</li> <li>3rd Place bot: https://github.com/nfmelendez/oz-uupsupgradeable-contract-agent</li> </ul> </li> </ol>"},{"location":"contest4-forta/","title":"Forta Contest (12/17/2021)","text":"<p>Forta is thrilled to announce the last bot development contest of 2021!</p> <p>Submit your entries for this contest HERE.</p> <p>Forta bots are code scripts written in Python, Javascript and Typescript that trigger alerts when certain conditions are met. The best bots trigger alerts when specific conditions indicate that a potential hack or exploit may be taking place and help end users prevent them. For more information on creating your first bot, check out our quickstart guide and video tutorials.</p> <p>Forta bot developer contests are mini-hackathons where anyone is able to submit a bot and be rewarded in NFTs, and Crypto!</p> <p>Contest discussion group and announcements are available on our Discord.</p>"},{"location":"contest4-forta/#rules","title":"Rules","text":"<ul> <li> <p>You will find two challenges listed below. Each challenge has a specific security concern that a Forta bot monitors for. Please submit your completed bots to the contest judges through the Google form linked above and on connect.forta.network.</p> </li> <li> <p>Only the first twenty five (25) QUALIFIED submissions to each challenge that meet the challenge requirements below will be considered.</p> </li> <li> <p>After twenty five qualified submissions are received for a challenge, we will close the challenge and announce it in the #agent-dev-contests channel in Discord. As long as submissions are open, you are welcome to build and submit bots for both challenges!</p> </li> <li> <p>All developers that submit a qualifying bot will receive a Forta NFT.</p> </li> <li> <p>Cash prizes will be awarded to the 1st, 2nd, and 3rd place bots in each challenge.</p> <ul> <li>1st place will receive $1,500 in USDC and a unique Forta NFT.</li> <li>2nd place will receive $750 in USDC and a unique Forta NFT.</li> <li>3rd place will receive $250 in USDC and a unique Forta NFT.</li> </ul> </li> <li> <p>To be eligible for a prize, you will be asked to submit a valid email and Discord username through the Google form, along with your bot.</p> </li> <li> <p>This contest will run from December 17th through December 31st, after which no further submissions will be considered. Winners will be chosen by a panel of bot reviewers from Forta community member Arbitrary Execution, and will be announced on January 7th.</p> </li> </ul> <p>For any questions, please contact a Forta Moderator on Discord.</p>"},{"location":"contest4-forta/#assessment-criteria","title":"Assessment Criteria","text":"<ul> <li> <p>Bot implementation</p> <ul> <li>Does the code correctly alert according to the challenge description?</li> <li>Does the code make appropriate use of Forta SDK and built-in functions?</li> <li>Does the code contain comments?</li> <li>Is the code well-formatted and easy to read?</li> </ul> </li> <li> <p>Testing</p> <ul> <li>Do all tests run and pass?</li> <li>Are there negative test cases? i.e. when alerts should not be created</li> <li>Are there positive test cases? i.e. when alerts should be created</li> </ul> </li> <li> <p>Documentation</p> <ul> <li>Does the README.md have a concise description of bot functionality?</li> <li>Does the README.md contain well-formatted descriptions of each alert?</li> <li>(If Applicable) Does the README.md contain real blocks/transactions that will trigger alerts?</li> <li>Does the package.json contain an appropriate name and description?</li> </ul> </li> </ul>"},{"location":"contest4-forta/#challenges","title":"Challenges","text":"<ol> <li> <p>Influencing Governance Proposals</p> <p>Governance proposals allow protocols to change to meet the evolving requirements of the DeFi ecosystem. Voting on these proposals occurs over a limited period of time where only those accounts that have been delegated votes may cast those votes in favor of or against the proposal. There is also a check to determine whether the delegated votes existed in the block number when the proposal was submitted.</p> <p>This challenge is to create a bot that will monitor proposals to the Uniswap Governance and the votes cast on those proposals. A finding should be created if an address casting a vote had a significant change in UNI balance in the 100 blocks leading up to the proposal starting block number. </p> <p>Optional, but recommended: Tracking balances in the 100 blocks after the vote is cast and creating a finding if the balance decreases.</p> <ul> <li> <p>GovernorBravo Contract</p> <ul> <li>Github</li> <li>Deployed Contract (Proxy)</li> </ul> </li> <li> <p>Uni Token Contract</p> <ul> <li>Github</li> <li>Deployed </li> </ul> </li> <li>Winner: vvlovsky</li> <li>Winning bot: https://github.com/VVlovsky/Influencing-Governance-Proposals-Agent</li> <li>2nd place: Miguel Martinez</li> <li>2nd place bot: https://github.com/miguelmtzinf/forta-uniswap-governance-influence</li> <li>3rd place: kovart</li> <li>3rd place bot: https://github.com/kovart/forta-agents/tree/main/uniswap/governance-votes</li> </ul> </li> <li> <p>Evidence of Phishing</p> <p>Users approving token transfers to an externally owned address (EOA) may be a behavior indicative of a phishing attack.</p> <p>This challenge is to create a bot that will detect when a high number (e.g. 10 or more) of EOAs call the <code>approve()</code> or <code>increaseAllowance()</code> methods for the same target EOA over an extend period of time (e.g. 6 hours ~ 1600 blocks). The finding should include the affected addresses, the alleged attacker's address, and the addresses and amounts of tokens involved. Be certain to filter out smart contracts (i.e. <code>approve()</code> called by a smart contract or a smart contract that is the designated spender for an <code>approve()</code> call) and EOAs for any centralized exchanges (e.g. FTX exchange: 0x2FAF487A4414Fe77e2327F0bf4AE2a264a776AD2).</p> <p>The bot should trigger when run against the following block range: 13650638 to 13652198</p> <ul> <li> <p>ERC20 Reference</p> <ul> <li><code>approve()</code></li> <li><code>increaseAllowance()</code></li> </ul> </li> <li> <p>Example phishing attacks</p> <ul> <li>BadgerDAO </li> </ul> </li> <li>Winner: kovart</li> <li>Winning bot: https://github.com/kovart/forta-agents/tree/main/common/erc20-approve</li> <li>2nd place: vvlovsky</li> <li>2nd place bot: https://github.com/VVlovsky/Evidence-of-Phishing-Agent</li> <li>3rd place: Rodrigo Pino</li> <li>3rd place bot: https://github.com/rodrigo-pino/forta-phishing-agent-ts</li> </ul> </li> </ol>"},{"location":"contest5-solace/","title":"Solace Contest (3/1/2022)","text":"<p>Forta is thrilled to announce the first bot development contest of 2022, co-sponsored by Solace!</p> <p>Submit your entries for this contest HERE.</p> <p>Forta bots are code scripts written in Python, Javascript and Typescript that trigger alerts when certain conditions are met. The best bots trigger alerts when specific conditions indicate that a potential hack or exploit may be taking place and help end users prevent them. For more information on creating your first bot, check out our quickstart guide and video tutorials.</p> <p>Forta bot developer contests are mini-hackathons where anyone is able to submit a bot and be rewarded in NFTs, stablecoins, and crypto.</p> <p>Contest discussion, support, and announcements are available on Forta\u2019s Discord.</p>"},{"location":"contest5-solace/#rules","title":"Rules","text":"<ul> <li> <p>You will find five challenges listed below. Each challenge has a specific security concern that a Forta bot monitors for. Please submit your completed bots to the contest judges through the Google form linked above and on Forta App.</p> </li> <li> <p>Only the first ten (10) QUALIFIED submissions to each challenge that meet the challenge requirements below will be considered.</p> </li> <li> <p>After ten qualified submissions are received for a challenge, we will close the challenge and announce it in the #agent-dev-contests channel in Discord. As long as submissions are open, you are welcome to build and submit bots for all challenges!</p> </li> <li> <p>All developers that submit a qualifying bot will receive a Forta NFT.</p> </li> <li> <p>Cash prizes will be awarded to the winner of each of the 5 challenges - win or go home!</p> <ul> <li>1st place will receive $1,000 in $SOLACE and a unique Forta NFT.</li> </ul> </li> <li> <p>To be eligible for a prize, you will be asked to submit a valid email and Discord username through the Google form, along with your bot.</p> </li> <li> <p>This contest will run from March 1st through March 8th, after which no further submissions will be considered. Winners will be chosen by a panel of bot reviewers from Forta community member Limechain, and will be announced on March 12th.</p> </li> </ul> <p>For any questions, please contact a Forta Moderator on Discord.</p>"},{"location":"contest5-solace/#assessment-criteria","title":"Assessment Criteria","text":"<ul> <li> <p>Bot implementation</p> <ul> <li>Does the code correctly alert according to the challenge description?</li> <li>Does the code make appropriate use of Forta SDK and built-in functions?</li> <li>Does the code contain comments?</li> <li>Is the code well-formatted and easy to read?</li> </ul> </li> <li> <p>Testing</p> <ul> <li>Do all tests run and pass?</li> <li>Are there negative test cases? i.e. when alerts should not be created</li> <li>Are there positive test cases? i.e. when alerts should be created</li> </ul> </li> <li> <p>Documentation</p> <ul> <li>Does the README.md have a concise description of bot functionality?</li> <li>Does the README.md contain well-formatted descriptions of each alert?</li> <li>(If Applicable) Does the README.md contain real blocks/transactions that will trigger alerts?</li> <li>Does the package.json contain an appropriate name and description?</li> </ul> </li> </ul> <p>See Forta\u2019s Code Review checklist for a detailed description of how to develop a high quality bot.</p>"},{"location":"contest5-solace/#challenges","title":"Challenges","text":"<ol> <li> <p>Monitoring Whales on Solace</p> <p>Listen for large <code>Transfer</code> events (&gt;= 1M SOLACE) (on the ETH blockchain)</p> <ul> <li>SOLACE Contract: 0x9c051f8a6648a51ef324d30c235da74d060153ac (ETH)</li> <li>SOLACE Docs: https://docs.solace.fi/docs/dev-docs/intro </li> <li>Winner: vvlovsky</li> <li>Winning bot: https://app.forta.network/bot/0x7d63...1f07 (source code)</li> </ul> </li> <li> <p>BondTeller Monitoring for Basic Functions</p> <p>Monitor when <code>pause()</code>, <code>unpause()</code>, <code>setTerms()</code>, <code>setFees()</code>, or <code>setAddresses()</code> are called on BondTeller contracts (important governance functions). Also listen for <code>Paused</code>, <code>Unpaused</code>, <code>TermsSet</code>, <code>FeesSet</code>, <code>AddressesSet</code> events. Tip: You should monitor all BondTeller contracts</p> <ul> <li>DAI BondTeller Contract: 0x501ACe677634Fd09A876E88126076933b686967a (ETH)</li> <li>BondTeller Docs: https://docs.solace.fi/docs/dev-docs/contracts/bonds/BondTellerErc20 </li> <li>Winner: hyodar</li> <li>Winning bot: https://app.forta.network/bot/0x022e...aee9 (source code)</li> </ul> </li> <li> <p>BondTeller Monitoring Whale Alert</p> <p>Listen for large deposits (&gt;= 1M SOLACE tokens created). Tip: You should monitor all BondTeller contracts</p> <ul> <li>DAI BondTeller Contract: 0x501ACe677634Fd09A876E88126076933b686967a (ETH)</li> <li>BondTeller Docs: https://docs.solace.fi/docs/dev-docs/contracts/bonds/BondTellerErc20 </li> <li>Winner: karmacoma</li> <li>Winning bot: https://app.forta.network/bot/0x407c...c276 (source code)</li> </ul> </li> <li> <p>StakingRewards Monitoring</p> <p>Report when <code>setRewards()</code> or <code>setTimes()</code> are called (important governance functions). Also listen for <code>RewardsSet</code> and <code>FarmTimesSet</code> events.</p> <ul> <li>StakingRewards Contract: 0x501ace3D42f9c8723B108D4fBE29989060a91411 (ETH)</li> <li>StakingRewards Docs: https://docs.solace.fi/docs/dev-docs/contracts/staking/StakingRewards </li> <li>Winner: miguelmtzinf</li> <li>Winning bot: https://app.forta.network/bot/0xda27...e6ee (source code)</li> </ul> </li> <li> <p>BondDepository Monitoring</p> <p>Report when Teller added or removed by listening for <code>TellerAdded</code> and <code>TellerRemoved</code> events</p> <ul> <li>BondDepository Contract: 0x501ACe2f00EC599D4FDeA408680e192f88D94D0D (ETH)</li> <li>BondDepository Docs: https://docs.solace.fi/docs/dev-docs/contracts/bonds/BondDepository </li> <li>Winner: vvlovsky</li> <li>Winning bot: https://app.forta.network/bot/0x143f...c15d (source code)</li> </ul> </li> </ol>"},{"location":"contest6-forta/","title":"Forta Contest 2 (4/27/2022)","text":"<p>Forta is thrilled to announce a new Bot Development Contest, this time in data science. Submit your entries for this contest HERE.</p> <p>Forta Detection bots are pieces of logic (scripts) that look for certain transaction characteristics or state changes (e.g. anomaly detection) on smart contracts across any supported chain. Nodes run detection bots against each block of transactions. When the bots detect a specific condition or event, the network emits an alert which is stored on IPFS. For more information on creating your first detection bot, check out our quickstart guide and video tutorials.</p> <p>Forta Detection Bot Development contests are mini-hackathons where everyone is welcome to submit a detection bot and compete for prizes. Contest discussion, support, and announcements are available on Forta\u2019s Discord.</p>"},{"location":"contest6-forta/#rules","title":"Rules","text":"<ul> <li>You will find two challenges listed below. Each challenge has a specific security concern that a Forta detection bot monitors for. Please submit your completed bots to the contest judges through the Google form linked above and on Forta App.</li> <li>Only the first ten (10) QUALIFIED submissions to each challenge that meet the requirements below will be considered.</li> <li>After ten qualified submissions are received for each challenge, we will close the form and announce it on the #contests channel at Discord. As long as submissions are open, you are welcome to build and submit detection bots for all challenges!</li> <li>All developers that submit a qualifying detection bot will receive a Forta NFT.</li> <li>Cash prizes will be awarded to the winner, runner-up and third place of each of the two challenges<ul> <li>1st place will receive $3,000 in USDC and a unique Forta NFT.</li> <li>Runner up will receive $1,500 in USDC and a unique Forta NFT.</li> <li>Third place will receive $500 in USDC and a unique Forta NFT.</li> </ul> </li> <li>To be eligible for a prize, you will be asked to submit a valid email and Discord username through the Google form, along with a link of your bot on Github.</li> <li>This contest will run from April 27th through May 11th, after which no further submissions will be considered.</li> <li>Winners will be chosen by a panel of detection bot reviewers from Limechain, and will be announced on May 18th.</li> </ul> <p>For any questions, please contact a Forta Moderator on Discord.</p>"},{"location":"contest6-forta/#assessment-criteria","title":"Assessment Criteria","text":"<ul> <li>Bot implementation<ul> <li>Does the code correctly alert according to the challenge description?</li> <li>Does the code make appropriate use of Forta SDK and built-in functions?</li> <li>Does the code contain comments?</li> <li>Is the code well-formatted and easy to read?</li> </ul> </li> <li>Testing<ul> <li>Do all tests run and pass?</li> <li>Are there negative test cases? i.e. when alerts should not be created</li> <li>Are there positive test cases? i.e. when alerts should be created</li> </ul> </li> <li>Documentation<ul> <li>Does the README.md have a concise description of bot functionality?</li> <li>Does the README.md contain well-formatted descriptions of each alert?</li> <li>(If Applicable) Does the README.md contain real blocks/transactions that will trigger alerts?</li> <li>Does the package.json contain an appropriate name and description?</li> </ul> </li> </ul> <p>See Forta\u2019s Code Review checklist for a detailed description of how to develop a high quality bot.</p>"},{"location":"contest6-forta/#challenges","title":"Challenges","text":"<ol> <li> <p>Monitor unusual high gas usage</p> <p>Detection bots so far are alerting on high gas usage. However, gas changes over time (based on block congestion, which adjusts the base fee) and also may have a different baseline depending on the protocol (e.g. OpenSea gas usage may be generally higher than Uniswap\u2019s)</p> <p>Goal of the bot is to alert on unusual high gas usage for a specific protocol. As such, bot will need to maintain a list of baselines for a set of contract addresses. This should not be hard coded, but dynamically generated. </p> <p>It\u2019s recommended that you take a look at time series analysis taking into account seasonality (remember detection bots can be authored in Python, which have a slew of libraries). Sensitivity of alerts should be configurable.</p> <p>The bot should operate on all Forta supported chains (if applicable).</p> <p>An example set of transactions can be found in the Ronin hack e.g. the chart below shows the priority fee gas for the Ronin bridge.</p> <p></p> <p> - Winner: soptq - Winning bot: https://app.forta.network/bot/0xe2786...4555 - 2nd place: kovart - 2nd place bot: https://app.forta.network/bot/0x3054...13ed - 3rd place: hex.marc</p> </li> <li> <p>Monitor unusual price changes</p> <p>DeFi often relies on on-chain oracles. Some of these - if liquidity is low - can be easily manipulated driving prices up/down to subsequently perform actions that drain funds.</p> <p>The goal of this detection bot is to identify significant price swings using time series analysis. As such, the bot will need to maintain a list of baselines for each price feed for the top 5 major price feed providers. This should not be hard coded, but dynamically generated. Sensitivity of alerts should be configurable.</p> <p>The bot should operate on all Forta supported chains (if applicable).</p> <p>An example set of transactions can be found in the Beanstalk hack e.g. the chart below shows the price manipulation of the ETH/INV price (https://etherscan.io/dex/sushiswap/0x328dfd0139e26cb0fef7b0742b49b0fe4325f821 on April 2nd 2022).</p> <p></p> <p> - Winner: vvlovsky - Winning bot: https://app.forta.network/bot/0xe2786...4555 - 2nd place: khayalievartur</p> </li> </ol>"},{"location":"contest7-forta/","title":"Forta Contest 3 (6/17/2022)","text":"<p>Forta is thrilled to announce a new Bot Development Contest, this time we dive into attack simulation. Submit your entries for this contest HERE.</p> <p>Forta Detection bots are pieces of logic (scripts) that look for certain transaction characteristics or state changes (e.g. anomaly detection) on smart contracts across any supported chain. Nodes run detection bots against each block of transactions. When the bots detect a specific condition or event, the network emits an alert which is stored on IPFS. For more information on creating your first detection bot, check out our quickstart guide and video tutorials.</p> <p>Forta Detection Bot Development contests are mini-hackathons where everyone is welcome to submit a detection bot and compete for prizes. Contest discussion, support, and announcements are available on Forta\u2019s Discord.</p>"},{"location":"contest7-forta/#rules","title":"Rules","text":"<ul> <li>You will find one challenge listed below. The challenge has a specific security concern that a Forta detection bot monitors for. Please submit your completed bots to the contest judges through the Google form linked above and on Forta App.</li> <li>Only the first ten (10) QUALIFIED submissions to the challenge that meet the requirements below will be considered.</li> <li>After ten qualified submissions are received for the challenge, we will close the form and announce it on the #contests channel at Discord. As long as submissions are open, you are welcome to build and submit detection bots!</li> <li>All developers that submit a qualifying detection bot will receive a Forta NFT.</li> <li>Cash prizes will be awarded to the winner and runner-up of the challenge:<ul> <li>1st place will receive $3,000 USD (paid in FORT) and a unique Forta NFT.</li> <li>Runner up will receive $1,000 USD (paid in FORT) and a unique Forta NFT.</li> <li>Third place will receive $500 USD (paid in FORT) and a unique Forta NFT.</li> </ul> </li> <li>To be eligible for a prize, you will be asked to submit a valid email and Discord username through the Google form, along with a link of your bot on Github.</li> <li>This contest will run from June 17th through July 8th, after which no further submissions will be considered.</li> <li>Winners will be chosen by a panel of detection bot reviewers from Limechain, and will be announced on July 13th.</li> </ul> <p>For any questions, please contact a Forta Moderator on Discord.</p>"},{"location":"contest7-forta/#assessment-criteria","title":"Assessment Criteria","text":"<ul> <li>Bot implementation<ul> <li>Does the code correctly alert according to the challenge description?</li> <li>Does the code make appropriate use of Forta SDK and built-in functions?</li> <li>Does the code contain comments?</li> <li>Is the code well-formatted and easy to read?</li> </ul> </li> <li>Testing<ul> <li>Do all tests run and pass?</li> <li>Are there negative test cases? i.e. when alerts should not be created</li> <li>Are there positive test cases? i.e. when alerts should be created</li> </ul> </li> <li>Documentation<ul> <li>Does the README.md have a concise description of bot functionality?</li> <li>Does the README.md contain well-formatted descriptions of each alert?</li> <li>(If Applicable) Does the README.md contain real blocks/transactions that will trigger alerts?</li> <li>Does the package.json contain an appropriate name and description?</li> </ul> </li> </ul> <p>See Forta\u2019s Code Review checklist for a detailed description of how to develop a high quality bot.</p>"},{"location":"contest7-forta/#challenges","title":"Challenges","text":"<ol> <li> <p>Attack Simulation</p> <p>Forta detection bots monitor transactions and blocks for suspicious or malicious activity. However, detection bots can do more to identify these behaviors; and more importantly can do so even before any funds are diverted from a protocol.</p> <p>As outlined in the recent blog post Detecting Exploits Before Funds Are Lost Using Attack Simulation - Saddle Finance Case Study, bots can simulate attacks utilizing a locally forked version of the blockchain using Ganache.</p> <p>The goal of this bot is to successfully identify the Saddle Finance and similar attacks on block 14684300 with a critical alert utilizing a simulation approach:</p> <ol> <li>Upon suspicious contract creation, the bot should create a local fork of the blockchain using Ganache (see https://docs.forta.network/en/latest/tx-simulation for details on how to do so)</li> <li>Invoke the functions of the created smart contract</li> <li>Assess whether state changes (e.g. large balance changes) occur to determine whether exploitation occurred</li> <li>Emit a critical alert</li> </ol> <p>Note that invocation of the functions of the created smart contract can easily be simulated - as it was the case for the Saddle Finance attack - if it is parameterless. However, when parameters are involved, it becomes more difficult, and contest participants are encouraged to venture into opcode analysis and fuzzing to handle those cases.</p> <p>Further, assessing whether state changes are indicative of an exploit need to be broad (e.g. assessing native, ERC-20, ERC-721, and ERC-1155 balances), where these balances are changing (e.g. is the contract creator or contract invoker seeing large balance increases?), and whether the magnitude of the change is actually indicative of an exploit. Given this bot will result in a critical alert, the precision should be high (aka noise level low).</p> </li> </ol>"},{"location":"contest8-forta/","title":"Forta Contest 4 (8/31/2022)","text":"<p>Forta is thrilled to announce a new Bot Development Contest, this time we dive into attack simulation. Submit your entries for this contest HERE.</p> <p>Forta Detection bots are pieces of logic (scripts) that look for certain transaction characteristics or state changes (e.g. anomaly detection) on smart contracts across any supported chain. Nodes run detection bots against each block of transactions. When the bots detect a specific condition or event, the network emits an alert which is stored on IPFS. For more information on creating your first detection bot, check out our quickstart guide and video tutorials.</p> <p>Forta Detection Bot Development contests are mini-hackathons where everyone is welcome to submit a detection bot and compete for prizes. Contest discussion, support, and announcements are available on Forta\u2019s Discord.</p>"},{"location":"contest8-forta/#rules","title":"Rules","text":"<ul> <li>You will find one challenge listed below. The challenge has a specific security concern that a Forta detection bot monitors for. Please submit your completed bots to the contest judges through the Google form linked above and on Forta App.</li> <li>Only the first ten (10) QUALIFIED submissions to the challenge that meet the requirements below will be considered.</li> <li>After ten qualified submissions are received for the challenge, we will close the form and announce it on the #contests channel at Discord. As long as submissions are open, you are welcome to build and submit detection bots!</li> <li>All developers that submit a qualifying detection bot will receive a Forta NFT.</li> <li>Cash prizes will be awarded to the winner and runner-up of the challenge:<ul> <li>1st place will receive $3,000 USD (paid in FORT) and a unique Forta NFT.</li> <li>Runner up will receive $1,000 USD (paid in FORT) and a unique Forta NFT.</li> </ul> </li> <li>To be eligible for a prize, you will be asked to submit a valid email and Discord username through the Google form, along with a link of your bot on Github.</li> <li>This contest will run from August 31st through September 20th, after which no further submissions will be considered.</li> <li>Winners will be chosen by a panel of detection bot reviewers from Nethermind, and will be announced on October 5th.</li> </ul> <p>For any questions, please contact a Forta Moderator on Discord.</p>"},{"location":"contest8-forta/#assessment-criteria","title":"Assessment Criteria","text":"<ul> <li>Bot implementation<ul> <li>Does the code correctly alert according to the challenge description?</li> <li>Does the code make appropriate use of Forta SDK and built-in functions?</li> <li>Does the code contain comments?</li> <li>Is the code well-formatted and easy to read?</li> </ul> </li> <li>Alert efficacy<ul> <li>How noisy is the bot (will be evaluated based on transactions from Sept 12th to Sep 18th)?</li> <li>How well does the bot identify the attacker addresses (contracts/ EOAs)?</li> <li>How well does the bot describe the scam identified?</li> </ul> </li> <li>Testing<ul> <li>Do all tests run and pass?</li> <li>Are there negative test cases? i.e. when alerts should not be created</li> <li>Are there positive test cases? i.e. when alerts should be created</li> </ul> </li> <li>Documentation<ul> <li>Does the README.md have a concise description of bot functionality?</li> <li>Does the README.md contain well-formatted descriptions of each alert?</li> <li>(If Applicable) Does the README.md contain real blocks/transactions that will trigger alerts?</li> <li>Does the package.json contain an appropriate name and description?</li> </ul> </li> </ul> <p>See Forta\u2019s Code Review checklist for a detailed description of how to develop a high quality bot.</p>"},{"location":"contest8-forta/#challenges","title":"Challenges","text":"<ol> <li> <p>Scams</p> <p>In 2021, Chainanalysis - in their 2022 cyber crime report - estimated scam losses far exceed losses of DeFi hacks with 7.7B and 2.3B respectively. Forta\u2019s mission is to secure web3. So far, Forta\u2019s efforts have primarily focused on securing on-chain protocols through monitoring of all on-chain activity. However, opportunities exist for Forta to protect end users as well.</p> <p>In December 2021, BAYC owners became victim of a scam (see https://medium.com/@investigationsbyzachxbt/scammers-in-paris-32b8e3c039ba); in August 2022, Curve Finance users were tricked into token approvals, which were quickly drained out of user\u2019s wallets (https://rekt.news/curve-finance-rekt/).</p> <p>Commonly, these attacks are referred to as ice phishing attacks and a community developed bot exists to identify these ice phishing attacks (see Ice Phishing 2.0 bot). However, the alerts the bot emits are too noisy identifying many approval events that are not part of an actual scam.</p> <p>The purpose of this contest is to create a new bot that is permitted to consume any existing alerts (e.g. through the get_alerts SDK function) (those alerts can be augmented with additional bots) as well as external data sources (e.g. twitter data/ web site HTML code) to identify these scams with high precision, aka low false positive rate. The goal is to identify the two attacks in question but do so with 50% precision (in other words, 50% of the alerts raised by the bot should identify actual scams). One way to accomplish this is to combine existing alerts in a way that is consistent with the attack stages associated with attacks: funding, preparation, exploitation, and money laundering as done by the Alert Combiner bot. The alert combiner utilizes simple heuristics; a better way may be described in Attack chain detection paper by Sexton J., Storlie C., Neil, J.</p> </li> </ol>"},{"location":"contest9-forta/","title":"Forta Contest 5 (10/11/2022)","text":"<p>Forta is thrilled to announce a new Bot Development Contest, this time diving into end user protections. Submit your entries for this contest HERE.</p> <p>Forta Detection bots are pieces of logic (scripts) that look for certain transaction characteristics or state changes (e.g. anomaly detection) on smart contracts across any supported chain. Nodes run detection bots against each block of transactions. When the bots detect a specific condition or event, the network emits an alert which is stored on IPFS. For more information on creating your first detection bot, check out our quickstart guide and video tutorials.</p> <p>Forta Detection Bot Development contests are mini-hackathons where everyone is welcome to submit a detection bot and compete for prizes. Contest discussion, support, and announcements are available on Forta\u2019s Discord.</p>"},{"location":"contest9-forta/#rules","title":"Rules","text":"<ul> <li>You will find one challenge listed below. The challenge has a specific security concern that a Forta detection bot monitors for. Please submit your completed bots to the contest judges through the Google form linked above and on Forta App.</li> <li>Only the first ten (10) QUALIFIED submissions to the challenge that meet the requirements below will be considered.</li> <li>After ten qualified submissions are received for the challenge, we will close the form and announce it on the #contests channel at Discord. As long as submissions are open, you are welcome to build and submit detection bots!</li> <li>All developers that submit a qualifying detection bot will receive a Forta NFT.</li> <li>Cash prizes will be awarded to the winner and runner-up of the challenge:<ul> <li>1st place will receive $3,000 USD (paid in FORT) and a unique Forta NFT.</li> <li>Runner up will receive $1,000 USD (paid in FORT) and a unique Forta NFT.</li> </ul> </li> <li>To be eligible for a prize, you will be asked to submit a valid email and Discord username through the Google form, along with a link of your bot on Github.</li> <li>This contest will run from October 11th through November 1st, after which no further submissions will be considered.</li> <li>Winners will be chosen by a panel of detection bot reviewers from Nethermind, and will be announced on November 8th.</li> </ul> <p>For any questions, please contact a Forta Moderator on Discord.</p>"},{"location":"contest9-forta/#assessment-criteria","title":"Assessment Criteria","text":"<ul> <li>Bot implementation<ul> <li>Does the code correctly alert according to the challenge description?</li> <li>Does the code make appropriate use of Forta SDK and built-in functions?</li> <li>Does the bot operate on all Forta supported chains?</li> <li>Does the code contain comments?</li> <li>Is the code well-formatted and easy to read?</li> </ul> </li> <li>Alert efficacy<ul> <li>How well does the bot perform its task? A curated set of past attacks will be used to assess. Note, since these bots are used to join with other bots, noise level is not a concern.</li> </ul> </li> <li>Testing<ul> <li>Do all tests run and pass?</li> <li>Are there negative test cases? i.e. when alerts should not be created</li> <li>Are there positive test cases? i.e. when alerts should be created</li> </ul> </li> <li>Documentation<ul> <li>Does the README.md have a concise description of bot functionality?</li> <li>Does the README.md contain well-formatted descriptions of each alert?</li> <li>(If Applicable) Does the README.md contain real blocks/transactions that will trigger alerts?</li> <li>Does the package.json contain an appropriate name and description?</li> </ul> </li> </ul> <p>See Forta\u2019s Code Review checklist for a detailed description of how to develop a high quality bot.</p>"},{"location":"contest9-forta/#challenges","title":"Challenges","text":"<p>The Attack Detector Feed Bot combines various alerts across the attack chain to emit a highly precise alert for protocol attacks. It does its job well and alerts emitted by this bot are shared on the @FortaAlerts twitter handle. However, it lacks context that is needed to swiftly understand what is going on. One primary question arises on what protocols are/were attacked and where were assets drained from?</p> <ol> <li> <p>Attacked Protocol/Asset Source Identification Bot</p> <p>The Attack Detector Feed Bot aggregates all addresses observed in the underlying alerts and exposes those in the metadata fields. For instance, the Wintermute attack resulted in the following alert: https://app.forta.network/alert/0x186becf1ad85541067d2244a3daacfdfe4e4de4733840832b0a8b0d5a8f84b9e</p> <p>As can be seen, the alert contains a lot of addresses that were involved in the attack. As the attacker obtained various digital assets and used several exchanges to swap those assets and various protocols to launder the funds, who was actually attacked is lost.</p> <p>This part of the contest asks to create a bot that identifies the protocol that was likely attacked as well as asset source (e.g. Swap XYZ\u2019s liquidity pool Asset1/Asset2) from which assets were drained from. One possible route is to look at token balance decreases and use block explorer tags to identify which protocol is used.</p> <p>However, it is not going to be that simple. If an attack, for instance, targets a specific liquidity pool, the tag may not exist on the block explorer and needs to be inferred from who created the liquidity pool or based on the source code of the underlying contract. Or if a particular position in a liquidity pool is targeted, it may not represent an attack on the liquidity pool, but rather on the holder of the position.</p> <p>The bot is allowed to utilize block explorer tags and block explorer information with the notable exception of the exploiter tags that are often added after an attack. It should emit an informational alert that contains both the name as well as the twitter handle of the attacked protocol and information of the asset source. Since this alert is informational only and will be combined with additional information to emit a highly precise alert, it is OK if this bot is noisy. </p> <p>The bot should output the following captured in the metadata of the alert:</p> <ul> <li>protocol attacked (addresses, names and twitter handle)</li> <li>asset source (addresses, name, and twitter handle) (e.g. if ETH/USDC Uniswap V3 pool would be drained, it would list all the position holders)</li> <li>quantification of the assets stolen</li> </ul> </li> </ol>"},{"location":"contributing/","title":"How to contribute","text":"<p>Thank you for being a part of the Forta network! All contributions from the community are valuable and encouraged. Getting the community involved is essential to Forta's success and there are many ways to contribute even without having to write any code. Here are just a few ideas, but you're welcome to submit any more you think of!</p>"},{"location":"contributing/#join-the-forta-discord","title":"Join the Forta Discord","text":"<p>One of the best ways to contribute is to just be a positive and helpful member of the Forta Discord community. Participating in the conversation to help answer questions or contribute ideas/advice is extremely valuable, including feedback on how to improve the product and UX. If you have a good understanding of Forta, helping others when they have a question or get stuck is an excellent way to grow the community.</p>"},{"location":"contributing/#spread-the-word","title":"Spread the word","text":"<p>Runtime blockchain security is a relatively new concept and many people do not know that such a tool is available. If you are aware of a project that is looking to improve their security, has suffered a recent exploit or just needs to build a first line of defense, let them know about Forta! You can also share the Forta bot development contests on your social media to spread awareness, get people involved and earn crypto prizes.</p>"},{"location":"contributing/#use-the-tools","title":"Use the tools","text":"<p>Helping test the following tools by simply using them is a great way to contribute:</p> <ul> <li>Forta App: Deploy new bots and subscribe to alerts.</li> <li>Forta App: Monitor bots and alerts.</li> <li>Forta API: Integrate alerts into your monitoring tools or dApps.</li> </ul> <p>See a bug or have an idea for improvement? Share it in Discord!</p>"},{"location":"contributing/#improve-the-documentation","title":"Improve the documentation","text":"<p>Documentation is one of the most important parts of the Forta ecosystem as it onboards new community members and helps users when troubleshooting. Going through the tutorials and reporting typos or parts that are confusing is a helpful way to contribute. This documentation site is opensource and available on Github. See something missing? You can add to the docs by submitting a pull request against the repository (by forking it).</p>"},{"location":"contributing/#develop-the-sdk","title":"Develop the SDK","text":"<p>Are you a skilled Javascript, Typescript or Python developer? You can help build out the Forta SDK and developer tools. The SDK and CLI are opensource and available on Github. Got an idea to improve the developer workflow? You can submit a pull request against the repository (by forking it). Reporting or fixing bugs and making suggestions for code improvements are also fantastic ways to contribute.</p>"},{"location":"contributing/#share-useful-libraries","title":"Share useful libraries","text":"<p>Have you written an awesome library to help you develop bots? Sharing such tools and libraries helps the community also improve their bots. If you have identified a common pattern when writing your bots, you could share a set of templates that others can use to speed up their bot development process. Check out the useful libraries page to see what is currently recommended.</p>"},{"location":"contributing/#run-a-scan-node","title":"Run a scan node","text":"<p>Scan nodes are a key piece of Forta infrastructure as they help run bots and share any alerts. A great way to expand the network is to run your own scan node and create bandwidth for more bots to run.</p>"},{"location":"contributing/#analyze-historical-alerts","title":"Analyze historical alerts","text":"<p>There\u2019s a unique opportunity for the community to take advantage of the open data and collaborate on new data science and machine learning solutions together. For example, the community can begin to extract trends and insights from historical alerts that may be helpful to improving blockchain security. And with the right tools and data, Forta can also begin to detect threats and exploits before they happen with increasing accuracy over time.</p> <p>Do you need access to historical alerts soon for data analysis or for your bot? If so, check out Forta API.</p>"},{"location":"defi-starter-kit/","title":"DeFi Threat Detection Kit","text":"<p>Frequent Doc Updates</p> <p>Forta will continue to add more curated security bots in the coming months, so stay tuned and come check this page frequently for new updates!</p> Bot Name Bot Details/Template Link Bot Description Anomalous Token Transfers Detection Machine Learning Bot Bot Details Alerts on anomalous transactions with erc2 token transfers. Anomalous Transaction Volume Bot Details Alerts on anomalous transaction volume (both successful and failed). Asset Drained Bot Bot Details Alerts on assets being drained from a contract. Attack Detector Feed (aka Alert Combiner) Bot Details Combines past alerts under a common address to emit a high precision alert around protocol attacks. Chainalysis Sanctioned Addresses Bot Details Alerts when a Chainalysis sanctioned account interacts with the address monitored. Exploiter Addresses Bot Details Alerts when known exploiter address interacts with the address monitored. FlashBots Detector Bot Details Alerts when a transaction is routed through FlashBots framework bypassing the mempool. Flash Loan Detector Bot Details Alerts when a flash loan results in large profits indicative of an attack Ice Phishing Detection Bot Bot Details Alerts when ice phishing (social engineer users into token approvals) for a token contract monitored. Large Balance Decreases Template available on Bot Wizard \ud83e\uddd9 Identifies when the balance of an account decreases significantly. Note, this template has been deployed for the following bridges: Polygon, Avalanche, Arbitrum, Near/Aurora, Optimism, Harmony, xDAI, Boba, Ronin, THORChain and Multichain/Anyswap. Mint/Borrow Value Anomalies Bot Details Alerts when mint/borrow volume is changing in a statistically significant way. Monitor Events Template available on Bot Wizard \ud83e\uddd9 Monitors blockchain transactions for specified events emitted from specified contract addresses. This template can be used to alert events emitted from functions that should only be callable by privileged roles. Monitor Function Calls Template available on Bot Wizard \ud83e\uddd9 This bot monitors blockchain transactions for specific function calls to specific contract addresses. This template can be used to alert on function calls that should only be callable by privileged roles. OpenZeppelin-Gnosis Safe Contract Events Bot Details Alerts on security relevant events of the OZ contract library/ Gnosis Safe contact instances. Price Change Anomalies Bot Details Re-entrancy counter Bot Details Alerts when reentrancy on the contract monitored is detected. Suspicious Contract Creation Bot Details Alerts on contract creation that contained the address monitored. Time Series Analyzer Template Template available on Bot Wizard \ud83e\uddd9 This template turns an underlying noisy alert representing a time series into a statistically meaningful alert when values become abnormal. Token Impersonation Bot Details Alerts when an existing token is being impersonated by a newly created contract. Tornado Cash Funded Account Interaction Bot Details Alerts when a Tornado Cash funded account interacts with the address monitored. Unverified Contract Creation Bot Details Alerts on contract creation that isnt verified on Etherscan."},{"location":"delegated-staking-introduction/","title":"Delegated Staking","text":"<p>Delegated staking is the process by which FORT token holders delegate all or a portion of their FORT to one or more scan node pools to secure the network and earn rewards. Pools are composed of one or more nodes, and can be formed by node runners to enable delegation. </p> <p>Like individual scan nodes, pools earn weekly FORT rewards based on uptime, SLA scores and stake of the nodes in the pool. The difference with pools is a percentage of rewards is distributed to delegators. </p> <p>Polygon</p> <p>Delegated staking is done by using the staking contract on Polygon. Please check this guide to find out how to bridge FORT tokens to Polygon.</p> <p>Pool owners share rewards with delegators by establishing on-chain parameters, including:</p> <ul> <li>How much of the delegated stake is allocated</li> <li>Percentage of delegators' rewards withheld as commission</li> </ul> <p>After every reward epoch ends (each epoch is one week, from Monday 00:00:00 UTC to Sunday 23:59:59 UTC), FORT rewards are distributed to node pools. Rewards earned by each pool are written to the reward distribution smart contract and distributed between owners and delegators based on the rewards formula.</p> <p>To learn more about delegated staking rewards, visit the Rewards Formula page.</p> <p>Also, please be aware that FORT delegated to a pool (which includes FORT delegated via the vault) is subject to pro rata slashing in the event the pool you have delegated to is slashed. Review the Slashing Policy for more information.</p>"},{"location":"delegated-staking-rewards/","title":"Delegated Staking Rewards","text":""},{"location":"delegated-staking-rewards/#claiming-rewards","title":"Claiming rewards","text":"<p>After the end of each epoch (each epoch is one week from, Monday 00:00:00 UTC to Sunday 23:59:59 UTC), reward calculation starts. The rewards are written to the rewards distributor contract as soon as the calculation is completed. FORT rewards are distributed to node pools. Rewards earned by each pool are written to the reward distribution smart contract and distributed between owners and delegators based on the rewards formula.</p>"},{"location":"delegated-staking-rewards/#forta-app","title":"Forta App","text":"<p>Visit \"My Rewards\" page from the top right menu in the Forta App! You can see on the rewards page if you have any available rewards and claim rewards from multiple epochs with a single action. Please note that this is not available to token vault users. </p> <p>For token vault users, FORT rewards will automatically be re-delegated. Visit the \u201cMy Delegations\u201d page from the top right menu in the Forta App to view your current deposited token holdings. </p>"},{"location":"delegated-staking-rewards/#polygonscan","title":"Polygonscan","text":"<p>To claim pool owner rewards over Polygonscan:</p> <ul> <li>visit the <code>getCurrentEpochNumber</code> method and take a note of the epoch number,</li> <li>visit the <code>claimRewards</code> method</li> <li>click on \"Connect to Web3\" on the top and connect your wallet,</li> <li>and fill in:<ul> <li>subjectType: 2 for pool owner, 3 for delegator</li> <li>subjectId: The pool ID to claim the rewards from</li> <li>epochNumbers: Do number from first step minus 1 and input e.g. <code>[2561]</code> if the number was 2562</li> </ul> </li> <li>click on \"Write\" to send the transaction.</li> </ul> <p>This transaction may fail if you have no rewards from that epoch. To verify this over Polygonscan:</p> <ul> <li>visit the <code>availableReward</code> method,</li> <li>and fill in:<ul> <li>subjectType: 2 for pool owner, 3 for delegator</li> <li>subjectId: The pool ID to claim the rewards from</li> <li>epochNumber: Same as in the <code>claimRewards</code> example above</li> <li>staker: Your wallet address which you used to stake on this pool</li> </ul> </li> </ul>"},{"location":"delegated-staking-rewards/#formula","title":"Formula","text":"<p>With the introduction of delegated staking, there are new reward formulas for pool owners and delegators. These formulas seek to</p> <ul> <li>encourage node runners to ensure the reliability and performance of the Forta network by achieving the highest possible SLA scores in their nodes,</li> <li>encourage node runners and delegators to stake more and increase the economic security of the network.</li> </ul> <p>The approach involves distributing rewards to participants as a function of the proportional scan node SLA, scan node uptime and allocated pool stake on the network, using the Cobb-Douglas production function.</p> <p>Important definitions</p> <ul> <li>epoch duration: 1 week, from Monday 00:00:00 UTC to Sunday 23:59:59 UTC</li> <li>commission becomes effective: next epoch</li> <li>commission lockdown after any change: two epochs (excluding the current one)</li> </ul> <p>These values are subject to change.</p> <p>The score of scan node <code>j</code> during an epoch is:</p> <p></p> <p>Consequently, the total score of scanner pool <code>i</code> during an epoch is:</p> <p></p> <p>And the share of the rewards scanner pool <code>i</code> receives during an epoch is:</p> <p></p> <p>Consequently, the total amount of rewards allocated to scanner pool <code>i</code>, during an epoch is:</p> <p></p> <p>where <code>F</code> is the total amount of FORT rewards to all of the Forta scan nodes during the epoch.</p> <p>Finally, the total amount of rewards allocated to scanner pool <code>i</code> is divided between the node runner of that pool and all the delegators to it:</p> <p>Node runner rewards on scanner pool <code>i</code>: </p> <p></p> <p>Delegator rewards on scanner pool <code>i</code>:</p> <p></p> <p>where:</p> <p></p> <p>The values of parameters \u03b1 and \u03b2 are set to 3 and 0.5 respectively and are subject to change in the future.</p> <p>Initial values</p> <p>For new pools during their first week, the formulas will be modified slightly and instead of using the stake at the beginning of the epoch, the rewards will be calculated using the time-weighted average stake during the epoch. For the following epochs, the distribution will be based on the initial stake values in each epoch.</p> <p>The total amount of the delegator rewards is distributed to each delegator proportionally to their initial deposited stake value in each epoch. The on-chain rules are the ultimate authority of this logic, and in the case where the on-chain rules differ from this, it will prevail.</p> <ol> <li> <p>For this calculation, only the periods when the SLA is at least 0.75 are considered.\u00a0\u21a9</p> </li> <li> <p>For this calculation, only the periods where the stake is at least 2,500 are considered. When the stake is less than that, the node is not considered to be online, so that\u2019s already captured on the time online parameter.\u00a0\u21a9</p> </li> <li> <p>Rewardable time online requires the SLA to be at least 0.75.\u00a0\u21a9</p> </li> </ol>"},{"location":"deploying-app/","title":"Deploying your bot with Forta App","text":"<p>This page covers how to deploy your bot using Forta App.</p>"},{"location":"deploying-app/#enable-logging-optional","title":"Enable logging (optional)","text":"<p>Forta provides a logging feature that can be used to see what's happening inside of your bot across multiple scan nodes. To enable this feature, you need to add/uncomment the following line in the bot Dockerfile:</p> <pre><code>LABEL \"network.forta.settings.agent-logs.enable\"=\"true\"\n</code></pre> <p>After deploying, you can view bot logs using the Forta API.</p>"},{"location":"deploying-app/#documentation","title":"Documentation","text":"<p>Documentation for your bot is required in order to deploy. It should let others know what conditions your bot is detecting and what sort of alerts it will fire. Documentation will always be in the README.md file in your project folder (we have provided example documentation to help you get started). Please update the README.md for your specific bot.</p> <p>You will also find the Forta Detection Bot License included in your project LICENSE.md file (and copied over in your Dockerfile). This is required for every detection bot deployed to the network.</p>"},{"location":"deploying-app/#pushing-your-bot-image","title":"Pushing your bot image","text":"<p>Before you head over to Forta App, you will need one piece of information: your bot's image reference. You can get the image reference by running the following command (make sure your Docker is running before proceeding):</p> <pre><code>npm run push\n</code></pre> <p>This will build your bot image and push it to a repository where scan nodes can find it. Once completed, you should see a message in your output similar to:</p> <p><pre><code>successfully pushed image with reference bafybeifutbdhewyz7lfl4z7bfry6xfscaewwhe4n3uqi2gdj67js6plwre@sha256:3904d36d3527ae4135e479dd223c37dde1e6052ae47fdbf3305ebd506d4e34d2\n</code></pre> Copy the image reference (i.e. <code>bafybeifutbdhewyz7lfl4z7bfry6xfscaewwhe4n3uqi2gdj67js6plwre@sha256:3904d36d3527ae4135e479dd223c37dde1e6052ae47fdbf3305ebd506d4e34d2</code>) to your clipboard and head over to Forta App.</p>"},{"location":"deploying-app/#import-your-keyfile-into-metamask","title":"Import your keyfile into Metamask","text":"<p>Forta App will use your Metamask to send the deployment transaction. You can import your keyfile (located in ~/.forta) with the following steps:</p> <ol> <li>In Metamask, click the Accounts dropdown and then click on Import Account</li> <li>Select the JSON File option from the Type dropdown</li> <li>Click on Choose File and navigate to your keyfile (in ~/.forta) and select it</li> <li>Enter the password for your keyfile in the Password box</li> <li>Click the Import button</li> </ol> <p>Your keyfile should now be in Metamask.</p>"},{"location":"deploying-app/#connect-your-metamask-to-forta-app","title":"Connect your Metamask to Forta App","text":"<p>You will need to connect your Metamask to Forta App with the following steps:</p> <ol> <li>On the Forta App website, click the \"Log in with wallet\" button on the top right</li> <li>A Metamask dialog will appear asking you to select which account to connect. Select your imported account, click Next and then click Connect</li> <li>Another Metamask dialog will ask you to sign a message to login. Click the Sign button</li> </ol> <p>Your Metamask should now be connected to Forta App. You should see your wallet address appear on the menu at the top right of the page.</p>"},{"location":"deploying-app/#deploying","title":"Deploying","text":"<p>In order to deploy your bot, you will need to complete a short form by navigating to the Detection Bots page (from the menu at the top right):</p> <ol> <li>Click the Deploy Bot button to bring up the form. The bot ID will be automatically generated for you</li> <li>Fill in the rest of the fields with your bot's information like name, description, version and which blockchains you want to scan (currently supported chains are Ethereum, Polygon, Binance Smart Chain, Avalanche, Arbitrum, Optimism, and Fantom)</li> <li>For the Documentation field, select the README.md from your project folder. This will be uploaded to IPFS</li> <li>For the Docker Image field, paste in the image reference you copied earlier from the <code>npm run push</code> command</li> <li>If your code repository is public, fill in the Repository field</li> <li>Click the \"Sign to proceed\" button</li> <li>A Metamask dialog will appear asking you to sign the bot metadata. Click the Sign button</li> <li>A confirmation form will display your bot metadata, including the IPFS hash of the bot metadata and documentation. If these look good, click the Deploy Bot button to initiate the deployment transaction</li> <li>A Metamask dialog will appear asking you to confirm the deployment transaction. Review the details and click the Confirm button</li> </ol>"},{"location":"deploying-app/#staking","title":"Staking","text":"<p>In order to enable your bot, it must be staked with 100 FORT tokens. You can easily stake on your bot by following the steps here.</p> <p>Congratulations! You have successfully deployed your first Forta bot!</p> <p>Great job getting this far! You have created a project, developed a bot, written and run a test, and deployed it to the Forta network. We encourage you to share your bots with the Discord community as a way to showcase your ideas or receive general feedback! For any questions or feedback you may have, you can find us in the Forta Discord server as well.</p> <p>Continue to the next page where you can learn more about subscribing to alerts.</p>"},{"location":"deploying-cli/","title":"Deploying your bot with the CLI","text":"<p>This page covers how to deploy your bot using the <code>forta-agent</code> CLI tool.</p>"},{"location":"deploying-cli/#enable-logging-optional","title":"Enable logging (optional)","text":"<p>Forta provides a logging feature that can be used to see what's happening inside of your bot across multiple scan nodes. To enable this feature, you need to add/uncomment the following line in the bot Dockerfile:</p> <pre><code>LABEL \"network.forta.settings.agent-logs.enable\"=\"true\"\n</code></pre> <p>After deploying, you can view bot logs using the Forta API.</p>"},{"location":"deploying-cli/#documentation","title":"Documentation","text":"<p>Documentation for your bot is required in order to deploy. It should let others know what conditions your bot is detecting and what sort of alerts it will fire. Documentation will always be in the README.md file in your project folder (we have provided example documentation to help you get started). Please update the README.md for your specific bot.</p> <p>You will also find the Forta Detection Bot License included in your project LICENSE.md file (and copied over in your Dockerfile). This is required for every detection bot deployed to the network.</p>"},{"location":"deploying-cli/#configuration","title":"Configuration","text":"<p>A few configuration values must be set in your package.json in order to deploy:</p> <ul> <li><code>name</code> of your bot project should be specified</li> <li><code>description</code> should be a short human-readable description of what your bot does</li> <li><code>version</code> of your bot should also be set as well</li> <li><code>chainIds</code> of the blockchains that your bot will be scanning should be specified as an array of integers. You must specify at least one and up to as many as you need. The supported chain IDs are:<ul> <li>1 (Ethereum)</li> <li>137 (Polygon)</li> <li>56 (Binance Smart Chain)</li> <li>43114 (Avalanche)</li> <li>42161 (Arbitrum)</li> <li>10 (Optimism)</li> <li>250 (Fantom)</li> </ul> </li> <li><code>repository</code> is optional, but providing a link to your code helps build trust in your bot</li> </ul>"},{"location":"deploying-cli/#deploying","title":"Deploying","text":"<p>Make sure your Docker is running before proceeding. You can now run the following command from your project folder to deploy your bot:</p> <pre><code>npm run publish\n</code></pre> <p>This will build a Docker image for your bot using the Dockerfile in your project folder and push it to an image repository where scan nodes can find it. A manifest will be generated for your bot (which includes a reference to the Docker image) and be published to the Bot Registry contract.</p> <p>Signing the manifest</p> <p>The bot manifest will need to be signed using your keyfile (located in ~/.forta), so you will be prompted for the password (unless you specified <code>keyfilePassword</code> in forta.config.json).</p> <p>When successfully deployed, you should see a message in your output similar to  <pre><code>successfully added agent id 0x855b1556a45637abf05c63407437f6f305b4627c4361fb965a78e5731999c0c7 with manifest QmcWPhPQ3un47QpZKKJZxD5ih3TXgk91ehLeUw6we2ncYg\n</code></pre> This message contains your bot ID (i.e. <code>0x855b1556a45637abf05c63407437f6f305b4627c4361fb965a78e5731999c0c7</code>) as well as your manifest IPFS reference (i.e. <code>QmcWPhPQ3un47QpZKKJZxD5ih3TXgk91ehLeUw6we2ncYg</code>). You can view the manifest by requesting it from any IPFS gateway (e.g. <code>https://ipfs.io/ipfs/QmcWPhPQ3un47QpZKKJZxD5ih3TXgk91ehLeUw6we2ncYg</code>)</p>"},{"location":"deploying-cli/#staking","title":"Staking","text":"<p>In order to enable your bot, it must be staked with 100 FORT tokens. You can easily stake on your detection bot using the following command:</p> <pre><code>npm run stake\n</code></pre> <p>If you prefer to stake using a UI, you can do so by following the steps here.</p> <p>Congratulations! You have successfully deployed your first Forta bot!</p> <p>Great job getting this far! You have created a project, developed a bot, written and run a test, and deployed it to the Forta network. We encourage you to share your bots with the Discord community as a way to showcase your ideas or receive general feedback! For any questions or feedback you may have, you can find us in the Forta Discord server as well.</p> <p>Continue to the next page where you can learn more about subscribing to alerts.</p>"},{"location":"deploying-ml-models/","title":"Deploying a Machine Learning Model in a Detection Bot","text":"<p>This guide will share tips and tricks on deploying a scikit-learn machine learning model in a Python detection bot. To help illustrate the outlined steps, the guide will make references to the  Anomalous Token Transfer ML Detection Bot\u2019s code (ATT). Throughout the guide, we\u2019ll use the abbreviation ATT to refer to this bot.</p> <p>The ATT bot utilizes the Isolation Forest, an unsupervised outlier detection algorithm to detect anomalous transactions with erc20 token transfers. For more details on its training process, please check out the bot\u2019s readme.</p>"},{"location":"deploying-ml-models/#loading-the-ml-model","title":"Loading the ML Model","text":"<p>The following three steps are required to load and interact with a trained machine learning model in the detection bot container:</p> <ol> <li>Save the trained model with serialization.</li> <li>Add model to Dockerfile.</li> <li>Load the model in the <code>initialize</code> function.</li> </ol>"},{"location":"deploying-ml-models/#step-1-save-trained-model-with-serialization","title":"Step 1: Save trained model with serialization","text":"<p>To use a model in a different environment without retraining, we\u2019ll need a way to serialize the model. <code>Dill</code>, an extended version of <code>Pickle</code>, a built-in python object serialization module, was used to serialize the ATT\u2019s model after training in a python notebook.</p> <pre><code>import dill\n\nwith open('isolation_forest.pkl','wb') as f:\n    dill.dump(model, f)\n</code></pre> <p>For more details on persisting scikit-learn models, please check out the model persistence documentation.</p>"},{"location":"deploying-ml-models/#step-2-add-model-to-dockerfile","title":"Step 2: Add model to Dockerfile","text":"<p>Next, the serialized model will need to be added to the Dockerfile for the model to be accessible in the container.</p> <pre><code>WORKDIR /app\nCOPY ./isolation_forest.pkl ./\n</code></pre> <p>Tip: Update base image for faster Docker builds</p> <p>Most Python detection bots use the alpine base image for installing Python dependencies. However, if the bot utilizes Python data science packages such as <code>numpy</code>, <code>pandas</code>, and <code>scikit-learn</code>, the build can take 2+ hours. To reduce the build time, it\u2019s recommended to update the <code>Dockerfile</code> to use a debian base image. This will bring the build time down to &lt;10 minutes. To learn more about this, please check out this github issue.</p>"},{"location":"deploying-ml-models/#step-3-load-model-in-the-initialize-handler","title":"Step 3: Load model in the <code>initialize</code> handler","text":"<p>The <code>initialize</code> handler can be used to set any global variables and will be only invoked once in the beginning after a bot is assigned to a scan node. To avoid loading a model every time for prediction, we can define a global variable <code>MODEL</code> and load it once during initialization.</p> <pre><code>ML_MODEL = None\n\ndef initialize():\n   global ML_MODEL\n   logger.info('Start loading model')\n   with open('isolation_forest.pkl', 'rb') as f:\n       ML_MODEL = pickle.load(f)\n   logger.info('Complete loading model')\n</code></pre> <p>When loading a model, it is important for the scikit-learn version in the bot environment to be the exact version as the version used during saving. If not, the model can output unexpected results.</p>"},{"location":"deploying-ml-models/#preparing-model-input-data","title":"Preparing Model Input Data","text":"<p>When preparing input data for a model, you can follow the tips below that can help with code readability, feature generation speed, and debugging:</p>"},{"location":"deploying-ml-models/#tip-1-break-down-logic-into-separate-files","title":"Tip 1: Break down logic into separate files","text":"<p>Create a separate file for input data processing related functions and keep each function logic readable and simple. The ATT bot has a file called data_processing.py, where feature generation functions are located. This will avoid clutter in the main <code>agent.py</code> file and maintain separation of concern.</p>"},{"location":"deploying-ml-models/#tip-2-caching-3rd-party-api-results","title":"Tip 2: Caching 3rd Party API Results","text":"<p>If the model relies on 3rd party data like Etherscan and some data is expected to be requested more than once, consider setting up an LRU cache with python\u2019s <code>functools.lru_cache</code>. This will eliminate redundant network calls and improve feature generation speed. The ATT bot has an LRU cache setup for the following functions:</p> <ul> <li>Get_first_timestamp: Given address A, the function queries Etherscan to get address A\u2019s first transaction timestamp.</li> <li>Get_token_info: Given an erc20 token address, the function requests token name, symbol, and decimals from the Ethplorer API.</li> </ul>"},{"location":"deploying-ml-models/#tip-3-input-validation-and-alerting","title":"Tip 3: Input Validation and Alerting","text":"<p>There can be issues during feature generation, especially if requested data from 3rd party APIs are not available. Validating the generated inputs can help surface issues more easily. With validation, we can avoid producing model predictions from invalid inputs. To surface errors more clearly, a finding can be produced for invalid inputs.</p> <p>The ATT Bot has a simple validation function that checks for incorrect calculation of the feature <code>account_active_period_in_minutes</code>.</p> <pre><code>def valid_features(features) -&gt; bool:\n   '''Evaluate model input values'''\n   if features['account_active_period_in_minutes'] &lt; 0:\n       return False\n\n   return True\n</code></pre> <p>If the features are invalid, the ATT bot creates an <code>InvalidModelFeatures</code> finding with severity level set to info. These findings can be easily queryable via the Forta API and examined.</p> <pre><code>class InvalidModelFeatures(TokenTransfersTxFinding):\n   def __init__(self, metadata, tx_executor):\n       super().__init__()\n       self.alert_id = 'INVALID-TOKEN-TRANSFERS-TX'\n       self.description = f'Model input generation failed for tx executed by {tx_executor}'\n       self.name = 'Invalid Model Features'\n       self.severity = FindingSeverity.Low\n       self.type = FindingType.Info\n       self.metadata = metadata\n</code></pre>"},{"location":"deploying-ml-models/#processing-model-output","title":"Processing Model Output","text":""},{"location":"deploying-ml-models/#tip-1-normalizing-prediction-values","title":"Tip 1: Normalizing Prediction Values","text":"<p>For anomaly detection, it\u2019s good practice to normalize a model's prediction to a value range between 0 and 1 where anomalous values are closer to 1. It can help you understand how anomalous a value is and evaluate different ML techniques more easily.</p>"},{"location":"deploying-ml-models/#tip-2-setting-a-classification-threshold","title":"Tip 2: Setting a Classification Threshold","text":"<p>With the normalized value, you can set an <code>ANOMALY_THRESHOLD</code> to tweak how often a prediction is classified as an anomaly and reduce the bot\u2019s alerting rate. If precision is more important than recall, the threshold can be set to a higher value (e.g. prediction greater than 0.7 is considered anomalous). If recall is more important, the threshold can be set lower to allow more predictions with low confidence scores to be classified as anomalies.</p> <p>Here\u2019s how the ATT model\u2019s scores are updated and predictions defined based on a threshold.</p> <pre><code>raw_score = ML_MODEL.score_samples(model_input)[0]\n# normalize to return score between 0 and 1 (inclusive)\nnormalized_score = abs(raw_score)\n# ANOMALY_THRESHOLD set to 0.5\nprediction = 'ANOMALY' if normalized_score &gt;= ANOMALY_THRESHOLD else 'NORMAL'\n</code></pre>"},{"location":"deploying-ml-models/#tip-3-distinguish-model-outputs-in-findings","title":"Tip 3: Distinguish Model Outputs in Findings","text":"<p>If certain model outputs are more important to surface than others, for example an anomaly vs inlier, it\u2019s important to set an appropriate severity and finding type for different model outputs.</p> <p>The ATT has a different finding class for anomalous and normal transactions:</p> <pre><code>class NormalTransaction(TokenTransfersTxFinding):\n   def __init__(self, metadata, tx_executor):\n       super().__init__()\n       self.alert_id = 'NORMAL-TOKEN-TRANSFERS-TX'\n       self.description = f'{tx_executor} executed normal tx with token transfers'\n       self.name = 'Normal Transaction'\n       self.severity = FindingSeverity.Info\n       self.type = FindingType.Info\n       self.metadata = metadata\n\n\nclass AnomalousTransaction(TokenTransfersTxFinding):\n   def __init__(self, metadata, tx_executor):\n       super().__init__()\n       self.alert_id = 'ANOMALOUS-TOKEN-TRANSFERS-TX'\n       self.description = f'{tx_executor} executed anomalous tx with token transfers'\n       self.name = 'Anomalous Transaction'\n       self.severity = FindingSeverity.Critical\n       self.type = FindingType.Suspicious\n       self.metadata = metadata\n</code></pre> <p>Also, over time you may update and improve the model, so to be able to distinguish and evaluate different models, it\u2019s important to include the model version, score, classification label, and used threshold in the finding. When the model is updated, the model version can help separate out findings produced by the old and new model.</p> <p>The agent docker image hash can technically be used as a version, but the hash will not be able to tell apart a code update, model update, or both, so maintaining separate model and bot versions is key. It may also be helpful to keep a log of the model version and the changes you made so that you\u2019re aware of the techniques you tried before and avoid re-evaluating past experiments.</p> <p>ATT bot\u2019s finding outputs (partial): <pre><code>{\n \"name\": \"Normal Transaction\",\n...\n \"metadata\": {\n   ...\n   \"prediction\": \"NORMAL\",\n   \"anomaly_score\": 0.311,\n   \"anomaly_threshold\": 0.5,\n   \"model_version\": \"1657669403\" # created timestamp\n }\n}\n</code></pre></p>"},{"location":"deploying-ml-models/#monitoring-model-performance","title":"Monitoring Model Performance","text":""},{"location":"deploying-ml-models/#tip-1-recording-latency","title":"Tip 1: Recording Latency","text":"<p>Finally, it\u2019s also useful to record feature generation time and model response time to gauge the model\u2019s performance in production. This can help you debug and detect issues more easily.</p> <p>ATT bot\u2019s finding outputs (partial):</p> <pre><code>\"feature_generation_response_time\": 1.292835959,\n\"model_pred_response_time\": 0.024292124999999887,\n</code></pre>"},{"location":"deploying-ml-models/#tip-2-retraining-ml-model","title":"Tip 2: Retraining ML Model","text":"<p>As time passes, the model performance can degrade due to shifts in real world data distribution. So once the model is deployed, it's important to frequently monitor the model output distribution to detect any deviations from the distribution seen during training. If the deviation is significant, it\u2019s recommended to retrain the model with more recent data.</p> <p>For example, with the ATT bot, the model can start considering more transactions as anomalous if the more recent transactions no longer share similar patterns or characteristics as the transactions the model was trained on. If the ATT bot starts to alert more anomalies than usual, it may be a good time to retrain the model with recent transaction data.</p>"},{"location":"deploying-ml-models/#tip-3-monitoring-ml-model-performance","title":"Tip 3: Monitoring ML Model Performance","text":"<p>There are two ways to monitor a ML model\u2019s performance:</p> <ol> <li>One option is to check your bot\u2019s <code>Alert Severities</code> breakdown on the bot details page. If the model\u2019s class label predictions are mapped to different severity levels, you can use the pie chart to roughly gauge each class\u2019s prediction rate. For example, the ATT bot outputs class labels <code>ANOMALY</code> or <code>NORMAL</code>. The anomalous transactions have the severity level set to CRITICAL, and normal transactions have the level set to <code>INFO</code>. The pie chart below shows the CRITICAL findings rate (= anomaly rate) is &lt;1%.</li> </ol> <p> </p> <ol> <li>Another option is to query alerts with the Forta API and calculate more precise model statistics for a specific timeframe. For the ATT bot, this Daily Model Stats Notebook queries 1 day\u2019s worth of alerts and compares the model\u2019s anomaly rate in production with training\u2019s anomaly rate. This notebook also shows how ANOMALY_THRESHOLD can be tweaked to increase or decrease the anomaly rate.</li> </ol>"},{"location":"deploying-ml-models/#interpreting-model-predictions","title":"Interpreting Model Predictions","text":"<p>It may be challenging to trust a model\u2019s predictions without understanding the rationale behind it. There are explainable AI packages such as  Local Interpretable Model-Agnostic Explanations (LIME) or SHapley Additive exPlanations (SHAP) that can explain model predictions. These explanations can help you see the particular features the model considered to make a prediction.</p> <p>With the ATT bot, LIME produces a list of features and their weights to indicate the feature\u2019s influence on the prediction. For example, LIME shows below that the ATT model considered the number of USDC/USDT token transfers an important feature in labeling a transaction anomalous.</p> <p> </p>"},{"location":"deploying-ml-models/#was-the-guide-helpful","title":"Was the guide helpful?","text":"<p>If you made it all the way here, thanks for taking the time to read this guide! Was it useful or are there other guides or anything you\u2019d like to see? Did you integrate ML in a detection bot or need help? Let the community know how Forta can help, and don\u2019t forget to share your bot, thoughts, and/or feedback in the \u201cmachine-learning\u201d discord channel!</p>"},{"location":"deploying/","title":"Deploying your bot","text":"<p>Once you have tested your bot locally, you are ready to deploy it to the Forta network production environment! Deploying your bot involves 3 key steps:</p> <ol> <li>publishing a Docker image</li> <li>registering it in the Bot Registry smart contract</li> <li>staking 100 FORT tokens on your bot</li> </ol>"},{"location":"deploying/#acquiring-polygon-matic-tokens","title":"Acquiring Polygon MATIC tokens","text":"<p>The Bot Registry smart contract currently lives on Polygon mainnet, so you will need MATIC tokens on Polygon mainnet in order to deploy your bot. You can acquire some MATIC tokens by following this guide.</p>"},{"location":"deploying/#using-forta-app-vs-cli","title":"Using Forta App vs CLI","text":"<p>You can choose to deploy using Forta App or deploy using the CLI tool. You may want to use the CLI tool, for example, in your CI/CD pipeline.</p>"},{"location":"deposit-fort-vault/","title":"Deposit Your FORT in the Token Vault via Forta App","text":"<p>The FORT Token Vault is a simple and streamlined way to contribute your FORT tokens to securing the Forta Network. The vault allows you to simply deposit FORT tokens into the vault and rest is taken care of for you. Start earning rewards for your contribution without having to choose and decide between different individual pools. </p> <ol> <li> <p>Make sure your FORT is on the Polygon network. If you have your FORT on Ethereum Mainnet, follow these steps to bridge it to Polygon. </p> </li> <li> <p>After connecting your wallet, navigate to the stake button on the top of the Forta App. Here you can deposit your FORT tokens into the vault. </p> </li> </ol> <p></p> <p>Click on Deposit and choose the amount of FORT tokens you want to approve by clicking Approve, then confirm the transaction from within your wallet. </p> <p></p> <p></p> <p>After your approval transaction is confirmed, click the Deposit button and approve the transaction from within your wallet. </p> <p></p> <ol> <li>In this view you can review the total amount of FORT you have deposited in the vault, the overall total amount of FORT in the vault and the current estimated annual rewards. </li> </ol> <p></p> <ol> <li>Navigate to the My Delegations page from the top right of the Forta App. Here you can track the total amount of FORT you have deposited in the vault, the total amount of FORT deposited in the vault and the current estimated annual rewards. Additionally, here you will be able to deposit more FORT or withdraw any amount of FORT you wish to withdraw. </li> </ol> <p></p>"},{"location":"deposit-fort-vault/#withdrawing-from-the-fort-token-vault-and-claiming-rewards","title":"Withdrawing from the FORT Token Vault and Claiming Rewards","text":"<p>Initiating a withdrawal request from the FORT Token Vault will result in a percentage amount of FORT returned to you at the time of withdrawal based on the availability of liquidity in the vault. To claim the remaining FORT, you must wait the 10 day cooling off period to initiate a withdrawal transaction for the remainder of your FORT tokens. </p> <p>Rewards are automatically included in your total FORT deposit amount and will continue to grow.  </p>"},{"location":"error-monitoring/","title":"Error monitoring","text":"<p>You can verify the health of your bot from the status dashboard on Forta App (i.e. <code>https://app.forta.network/bot/YOUR_BOT_ID</code>). This will give you information like how many transactions the bot has processed or the latency of its responses. You can also use Forta's logging feature to view bot logs.</p> <p>While this is useful information, bot developers may want to integrate their bot into an existing error monitoring solution (e.g. Sentry).</p>"},{"location":"error-monitoring/#initialization","title":"Initialization","text":"<p>Whatever 3rd party error monitoring tool you decide to use, there will probably be some sort of initialization method you need to invoke, possibly using some API key. A good place to do this would be inside the <code>initialize</code> handler of the bot. Also, when placing API keys in your code you probably want to use methods described in the pattern for protecting sensitive data.</p>"},{"location":"error-monitoring/#catching-errors","title":"Catching errors","text":"<p>The simplest approach would be to wrap the logic in your handler functions with a <code>try</code>/<code>catch</code> statement. Upon catching any unexpected errors, you can simply log it using your tool of choice. This will allow you to gain more insights into errors and patch your bot if needed.</p> <p>Keep in mind that there can be multiple instances of your bot running across Forta scan nodes. As such, you may want to assign some generated ID in the bot to distinguish between errors from different instances.</p>"},{"location":"external-bots/","title":"External bots","text":"<p>\"External bots\" are a new type of detection bot that run outside of the Forta Network (i.e. not on a scan node) but can still submit alerts. This can be helpful if you want to run a detection bot using your private IP while still contributing intel. External bots are still required to register on-chain in order to submit alerts.</p> <p>The responsibility to execute the bot lies with the developer. You can run your external bot in any environment suitable to you and submit alerts using the GraphQL API directly or using the convenient SDK methods as described below.</p>"},{"location":"external-bots/#publishing-an-external-bot","title":"Publishing an external bot","text":"<p>Publishing an external bot is largely similar to publishing a normal bot. You can publish using the Forta App UI or the CLI. This step will register your bot ID in the on-chain bot registry.</p>"},{"location":"external-bots/#via-forta-app","title":"via Forta App","text":"<p>To publish an external bot using the Forta App, you simply need to check the \"External Bot\" checkbox (under the \"Docker Image\" field) on the Deploy Bot form.</p> <p></p> <p>You can then proceed with publishing by filling in the remaining fields.</p>"},{"location":"external-bots/#via-cli","title":"via CLI","text":"<p>To publish an external bot using the CLI, all you need to do is set the <code>external</code> property in your package.json like this:</p> <pre><code>{\n  ...\n  \"external\": true,\n  ...\n}\n</code></pre> <p>The command to publish the bot is the exact same: <code>forta-agent publish</code> (or <code>npm run publish</code>).</p>"},{"location":"external-bots/#submitting-alerts","title":"Submitting alerts","text":"<p>Before you can submit any alerts, you need to generate an API key in order to interact with the GraphQL API. Any alerts submitted can be queried for through the GraphQL API or via the Forta App UI.</p>"},{"location":"external-bots/#via-the-sdk","title":"via the SDK","text":"<p>The SDK provides a convenient method to submit alerts called <code>sendAlerts</code> (or <code>send_alerts</code> in Python). Make sure to set the <code>FORTA_API_KEY</code> environment variable with your API key first. You can submit a list of alerts or an individual alert using the same <code>Finding</code> object as before. The key difference is that you need to specify the <code>botId</code> for which you are submitting an alert (this also implies you can submit alerts for different bots in the same request).</p> <p>Here is some example Typescript usage:</p> <pre><code>import {\n  sendAlerts,\n  Finding,\n  FindingType,\n  FindingSeverity,\n  Label,\n  EntityType,\n} from \"forta-agent\";\n\nconst response = await sendAlerts({\n  botId: \"0x42265c815a3f2cc137bcd30f6688760ac0201911ce6006576b4b3e7f6e62ddc6\",\n  finding: Finding.from({\n    name: `test ${Date.now()}`,\n    description: \"this is a test\",\n    alertId: \"TEST_1\",\n    type: FindingType.Exploit,\n    severity: FindingSeverity.Info,\n    labels: [\n      Label.from({\n        entityType: EntityType.Address,\n        entity: \"0x87fb424282bd043de413aa74153af074d8c9bbb5\",\n        confidence: 0.95,\n        label: \"Attacker\",\n        metadata: {\n          some: \"data\",\n        },\n      }),\n      Label.from({\n        entityType: EntityType.Unknown,\n        entity: \"test\",\n        confidence: 0.15,\n        label: \"Hacker\",\n      }),\n    ],\n    source: {\n      chains: [\n        {\n          chainId: 137,\n        },\n      ],\n      transactions: [\n        {\n          chainId: 137,\n          hash: \"0xcc8dedfbc2c2757e793ccc781746a8996658541885017314ced5138ae6009f26\",\n        },\n        {\n          chainId: 1,\n          hash: \"0x0ce941aae4eecdd1cae0fe4c90e8c3b14a84f346b669c60e654b2eecd736b9b6\",\n        },\n      ],\n    },\n    addresses: [\"0x87fb424282bd043de413aa74153af073d8c9bbb5\"],\n    metadata: {\n      chain: \"137\",\n    },\n    uniqueKey: `TEST-${Date.now()}`,\n    timestamp: new Date(1694214981000), // you can specify when this alert was created (defaults to now)\n  }),\n});\nconsole.log(response);\n</code></pre> <p>As well as some example Python usage:</p> <pre><code>import os\nfrom datetime import datetime\nfrom forta_agent import Finding, Label, FindingType, FindingSeverity, EntityType, send_alerts\n\nresponse = send_alerts([{\n    \"bot_id\": \"0x075384e577be5c17efdc6cec5e80b3f84fb5b40257d8ecdd8ab0a542f8a6e084\",\n    \"finding\": Finding({\n        \"name\": f'test {datetime.now()}',\n        \"description\": \"this is a test\",\n        \"alert_id\": \"TEST_1\",\n        \"type\": FindingType.Exploit,\n        \"severity\": FindingSeverity.Info,\n        \"labels\": [\n            Label({\n              \"entityType\": EntityType.Address,\n              \"entity\": \"0x87fb424282bd043de413aa74153af073d8c9bbb5\",\n              \"confidence\": 0.95,\n              \"label\": \"Attacker\",\n              \"metadata\": {\n                  \"some\": \"data\",\n              },\n            }),\n            Label({\n                \"entityType\": EntityType.Unknown,\n                \"entity\": \"test\",\n                \"confidence\": 0.15,\n                \"label\": \"Hacker\",\n            }),\n        ],\n        \"source\": {\n            \"chains\": [\n                {\n                    \"chainId\": 137,\n                },\n            ],\n            \"transactions\": [\n                {\n                    'chainId': 137,\n                    'hash': \"0xcc8dedfbc2c2757e793ccc781746a8996658541885017314ced5138ae6009f26\",\n                },\n                {\n                    'chainId': 1,\n                    'hash': \"0x0ce941aae4eecdd1cae0fe4c90e8c3b14a84f346b669c60e654b2eecd736b9b6\",\n                },\n            ],\n        },\n        \"addresses\": [\"0x87fb424282bd043de413aa74153af073d8c9bbb5\"],\n        \"metadata\": {\n            \"chain\": \"137\",\n        },\n        \"uniqueKey\": f'TEST-{datetime.now().timestamp()}',\n        \"timestamp\": datetime.fromtimestamp(1694214981)\n    })\n}, {\n    \"bot_id\":  \"0x075384e577be5c17efdc6cec5e80b3f84fb5b40257d8ecdd8ab0a542f8a6e084\",\n    \"finding\": Finding({\n        \"name\": f'test {datetime.now()}',\n        \"description\": \"this is a test\",\n        \"alert_id\": \"TEST_1\",\n        \"type\": FindingType.Exploit,\n        \"severity\": FindingSeverity.Info\n    })\n},\n])\nprint(response)\n</code></pre>"},{"location":"external-bots/#via-the-graphql-api","title":"via the GraphQL API","text":"<p>If you want to interact with the GraphQL API directly, you can access the endpoint at https://api.forta.network/graphql. Make sure to set the <code>Authorization</code> header with your API key first. The name of the mutation to submit alerts is <code>sendAlerts</code>. Check out the schema to understand the inputs and their types.</p>"},{"location":"faq/","title":"Frequently asked questions","text":""},{"location":"faq/#is-forta-a-blockchain","title":"Is Forta a blockchain?","text":"<p>Short answer: no. Forta is not a blockchain in the sense that it does not maintain a shared state between nodes, but it has similar characteristics to a blockchain in that it is a decentralized network of nodes. Forta is more similar to The Graph protocol in that it runs on top of a blockchain. Forta uses a blockchain (i.e. Polygon) to coordinate scan nodes and store IPFS references to alerts generated by bots.</p>"},{"location":"faq/#how-can-i-consume-alerts-from-bots","title":"How can I consume alerts from bots?","text":"<p>You can subscribe to alerts from specific bots or contracts using the Forta App subscriptions page. Once signed in with your wallet, you can set up notifications for alerts. Currently, the supported channels to receive notifications are email, Slack, Telegram, Discord and webhooks.</p>"},{"location":"faq/#how-do-i-run-a-scan-node","title":"How do I run a scan node?","text":"<p>Please see the scan node guide guide to learn how to set up a scan node.</p>"},{"location":"faq/#do-i-need-special-hardware-to-run-scan-nodes","title":"Do I need special hardware to run scan nodes?","text":"<p>The hardware requirements for running a Forta scan node are described here.</p>"},{"location":"faq/#can-i-scan-other-blockchains-like-bnb-chain","title":"Can I scan other blockchains like BNB Chain?","text":"<p>Yes! Forta supports scanning on several blockchains including Ethereum, Polygon, BNB Chain, Avalanche, Arbitrum, Optimism and Fantom. Scan nodes are able to scan any EVM-compatible blockchain.</p>"},{"location":"faq/#what-makes-a-good-bot","title":"What makes a good bot?","text":"<p>Good bots are ones that detect real-world exploits before or as they occur, or provide warning of suspicious or unexpected conditions. A good bot is one that is targeting a specific condition i.e. if a bot alerts on more than 5% of transactions, the usefulness of those alerts would not be very high as it is difficult to know what to pay attention to.</p>"},{"location":"faq/#where-can-i-get-ideas-for-bots","title":"Where can I get ideas for bots?","text":"<p>The best ideas for bots are actual exploits that occur in the real world. As the DeFi space grows rapidly, exploits are occurring almost on a daily basis. To stay up-to-date on these exploits, you can check out the rekt.news website or subscribe to the Blockchain Threat Intelligence newsletter. You can also see bots that are currently deployed by other protocols on the Forta App Discover page.</p> <p>Also, if you are writing bots for your own protocol it can be useful to think about the types of conditions you want to be notified of, either in your own protocol or upstream/downstream protocols.</p>"},{"location":"faq/#do-i-need-special-hardware-to-build-bots","title":"Do I need special hardware to build bots?","text":"<p>The average consumer laptop is more than sufficient to build bots. If you are using your existing developer machine, you will do great.</p>"},{"location":"faq/#how-many-resources-does-my-bot-have-access-to-when-running","title":"How many resources does my bot have access to when running?","text":"<p>When deployed to a Forta scan node, detection bots are allowed a maximum of 20% CPU and 1GB of memory.</p>"},{"location":"faq/#what-determines-the-uniqueness-of-an-alert","title":"What determines the uniqueness of an alert?","text":"<p>A set of fields from an alert is used to determine whether or not it has fired before (this is used when de-duplicating alerts fired by the same detection bot across multiple scan nodes). You can see the <code>calculateAlertID</code> function used for transaction alerts as well as block alerts.</p>"},{"location":"faq/#how-can-i-create-alerts-that-only-i-can-see","title":"How can I create alerts that only I can see?","text":"<p>You can write a \"private bot\" to generate alerts that can only be understood by you. See the documentation on writing private bots.</p>"},{"location":"faq/#can-i-include-sensitive-information-like-api-keys-in-my-bot","title":"Can I include sensitive information like API keys in my bot?","text":"<p>Bots are stored as Docker images in a public repository i.e. anyone can access and inspect the image and its contents. Currently, there is no supported mechanism for storing secrets on bots. We do not recommend storing high-value secrets on the bot. Please see the pattern for protecting sensitive data to learn more.</p>"},{"location":"faq/#where-is-my-keyfile","title":"Where is my keyfile?","text":"<p>The <code>forta-agent</code> CLI will generate a keyfile for you the first time you initialize a bot project. It can be found in the ~/.forta folder. To get the absolute path and address of your keyfile, use the <code>npm run keyfile</code> command from your project folder.</p>"},{"location":"faq/#can-i-use-my-existing-metamask-key-to-publish-bots","title":"Can I use my existing Metamask key to publish bots?","text":"<p>You can use any key you prefer for publishing bots.</p>"},{"location":"faq/#my-infura-consumption-is-high-during-development-what-can-i-do","title":"My Infura consumption is high during development. What can I do?","text":"<p>If the free tier of services like Infura is not meeting your local development requirements, you can consider running a light Geth node locally. To do this, you would install Geth and then run the command <code>geth --syncmode light --http</code>. This will expose a JSON-RPC endpoint (defaults to <code>http://127.0.0.1:8545</code>) that you can point your bot to using the <code>jsonRpcUrl</code> config property in forta.config.json.</p>"},{"location":"fees-faqs%20copy/","title":"Fees faqs copy","text":"<p>Why is the Forta Network implementing subscription fees?</p> <p>Fees for subscriptions to bot alerts and related data feeds were implemented with overwhelming support of the community (that voted \u201cyes\u201d to FP-5 and FP-6), requiring users to pay for the data they consume, and rewarding the detection bot developers that create and maintain those data feeds. </p> <p>Developer rewards represent a vital component of a sustainable and decentralized Forta Network. These incentives create a flywheel effect in which developers create better data feeds, which bring more users, and that drives more revenue to developers, which again attracts more developers to build on Forta. These will be sustainable incentives, as they will be coming from real demand from users, and not from the protocol\u2019s treasury.</p> <p>What fees are being introduced in the Forta Protocol?</p> <p>At the moment, only fees to consume the Threat Intel Data: users will need to pay to access alerts, findings, and labels generated by the Forta Network. These fees will provide rewards to the participants in the network that generate corresponding data (i.e. bot owners).</p> <p>Will other fees be introduced in the future in the Forta Protocol?</p> <p>Other fees may be added to the Forta Network through future community governance proposals. For example, bot execution fees that could be paid by detection bot owners to directly reward node operators and their delegators for running bots on the network. Members of the Forta community are encouraged to explore how the Forta Network can evolve and explore how other types of fees might promote the long-term health of the network. </p>"},{"location":"fees-faqs%20copy/#users","title":"Users","text":"<p>What Threat Intel plans are available?</p> <ol> <li> <p>The General Plan: Forta\u2019s General Subscription Plan plan gives you access to 99%+ of the Network\u2019s hundreds of detection bots (ie. everything except Premium Feeds).You can also browse the 1,000+ other bots on the network here. The General Plan can only be paid in FORT.</p> </li> <li> <p>Premium Plans:  Premium Feeds are owned and maintained by one or more reputable community members (teams and/or individuals) and must meet certain requirements for performance and precision. The price for each Premium Feed is set by the owner. You can see all the Premium Feeds on the homepage of the Forta App once fees are live. Premium plans will be paid in either USDC or FORT. This decision is made by the premium feed\u2019s owner.</p> </li> </ol> <p>How to buy a plan?</p> <p>Plans can be bought directly through the respective Plan\u2019s smart contracts or using the Forta App in the Threat Intel Page that will go live on August 8th. You can also visit the documentation for all the details.</p> <p>How long do plans last?</p> <p>Plans have a duration of 30 days and are automatically renewed until canceled. If you do not hold sufficient funds in the wallet you subscribed with at the time of renewal, the renewal will fail and your subscription will lapse.</p> <p>How to cancel a plan?</p> <p>Users can cancel at any time, however their subscription will continue to give the user access until the end of their current subscription term. Current plans can be reviewed and canceled in the account tab of the Forta App, or directly through the smart contracts.</p> <p>What happens if I don\u2019t have enough funds in my wallet on the renewal date?</p> <p>If the user doesn\u2019t have enough funds in their wallet on the renewal date, the plan will be canceled. The user will need to add funds to the wallet and purchase the plan again to resume it.</p> <p>What happens if I don\u2019t have enough approved funds on the renewal date?</p> <p>If the user doesn\u2019t have enough approved funds on the renewal date, the plan will be canceled. The user will need to purchase the plan again to resume it.</p> <p>In this context, approved funds are the funds (USDC and/or FORT) that you have authorized the Forta dapp to access and move from your wallet. As with other Dapps, the Forta smart contracts need your permission -as the wallet owner- to access and move your tokens. For more information about token approvals, please check here. </p> <p>I already paid for the plan, now what? How can I access the data from the bots that belong to the plan I purchased?</p> <p>Intel from Premium Feeds and the individual bots on the General plan can be accessed either through Forta\u2019s GraphQL API (pull) or by subscribing to a bot directly (push). Purchasing one or more network subscriptions will give you access to both options. </p> <p>How do I manage my API keys?</p> <p>The user can manage their API keys in the API Keys section of the Forta App.</p> <p>I\u2019m subscribed to a bot but I\u2019m not getting notifications. Why?</p> <p>You might not have access to that bot intel on the plan you have purchased. Please, make sure the plan you\u2019ve purchased includes access to the bot you are trying to subscribe to.</p> <p>If the problem persists, you can always get technical support on Discord.</p> <p>I want to try Forta before purchasing, are there free trials?</p> <p>You can apply to gain access to a 1-month free trial of the General Plan here. </p> <p>Each premium feed owner manages their own discounts and free trials, please refer to the premium feed page to learn more or apply for the Scam Detector 1-month free trial here.</p> <p>Are there other terms and conditions applicable to my subscription?</p> <p>Assuming that a bot constitutes an original work of authorship under applicable copyright laws (software typically does), bot owners should automatically garner the right to license the use of their bot as they see fit. By deploying a bot to the Network, other participants in the Network will act as if a bot owner is giving an implied license to utilize their bot in accordance with the protocol rules (e.g. nodes will run your bot, users may subscribe to your bot if they pay the corresponding fees, etc). Bot owners may choose to apply other licensing terms to their bot(s), so be sure to review any such licensing terms (e.g. on Github or other documentation).</p>"},{"location":"fees-faqs%20copy/#bot-owners","title":"Bot Owners","text":"<p>I created a bot on the Network, what happens next?</p> <p>By default, any newly created detection bot will be automatically assigned to the General Plan. Anyone who wants to access your bot\u2019s data, will have to purchase the General Plan and subscribe or integrate with your bot.</p> <p>What happens if a premium feed consumes my bot data?</p> <p>Your bot will still be part of the General Plan, and you will collect the revenue it generates for being part of the General Plan. </p> <p>Whether the premium feed owner has funded your bot development or has agreed with you on the bot\u2019s usage, the premium feed belongs to the owner and he can decide to distribute the revenue the Premium feed collects or not.</p> <p>What are the benefits of having a Premium Feed on Forta?</p> <p>The benefits of launching a Premium Feed on Forta are (a) leveraging Forta\u2019s infrastructure, including thousands of node runners, and (b) leverage Forta\u2019s position as the leading network for threat intelligence in Web3 and exposing your data to a larger audience.</p> <p>Do I have to pay to make my bot a premium feed?</p> <p>No, you will have to submit a proposal at the Forta\u2019s forum to get governance approval. Premium Feeds must meet certain requirements for performance and precision, but every bot developer can submit a proposal to make their bots premium feeds.</p> <p>How do I make a premium feed?</p> <p>Every Bot developer and owner can submit a proposal on the Forta forum to make their bots a Premium Feed. </p> <p>The proposal needs to include, - Name of Premium Plan, - Proof of bot ownership and owner name, - Price in FORT or USDC, - Performance data; - Documentation; - Compatible licensing (Forta Bot License 1.0 is compatible, but not required); - Owner\u2019s Polygon wallet address for fee collection</p> <p>Here an example proposal.</p> <p>Provided that a submission to create a Premium Plan submission includes all the requisite information, a Premium Plan can be approved in one of two ways through the community governance process,</p> <ul> <li>the Forta Council can approve the Premium Plan (for clarity, the Council may delegate any of its responsibilities as appropriate, e.g. depending on the volume of requests), or</li> <li>majority approval of the Premium Plan by the community via Snapshot voting using the FPP process with at least 1 million FORT votes.</li> </ul> <p>Once and if your proposal gets governance approval, your feed will be included in the Forta Threat Intel page and you will be responsible for maintaining it and managing its users.</p> <p>Can I change the price of my Premium Feed?</p> <p>The price of the premium feed is approved by governance proposal on the Forta forum - and the owner can change it by submitting a follow up proposal (although current subscribers to that plan will keep using it at the same price until the subscription term ends). </p> <p>Do I need to purchase a plan to access the data produced by my own bots?</p> <p>Yes, if a bot owner wishes to receive data from the Forta Network they will need to pay the corresponding plan to access the data generated by their bots. Assuming a bot owner legally owns their own bot, they could run it locally, however this would not garner the benefit of it being run by the decentralized Forta node network.</p> <p>For premium plans, all fees are currently paid directly to the plan owner, so if you are the owner and are required to pay, effectively you will get 100% of that amount back as rewards. </p> <p>If a bot belongs to the General Plan, the fees collected will be part of the general pool and distributed to all the bots in the plan according to the bot rewards formula, so the owner who is paying to access his own bot from the general plan may have their costs offset. </p> <p>Do I need to purchase a plan if my bots read Forta data from other bots?</p> <p>If a detection bot reads Forta data, the bot owner would need to pay respective data fees for the data they rely on (from the corresponding plan) or their bot will not function correctly.</p> <p>Does my bot need a license?</p> <p>Assuming that your bot constitutes an original work of authorship under applicable copyright laws (software typically does), you should automatically garner the right to license the use of your bot as you see fit, whether on the Forta Network or anywhere else. With this in mind, the Forta Foundation funded the development of the \u201cForta Bot License\u201d. You are free to adopt the Forta Bot License if you think it fits your purpose! Alternatively, you can adopt any other license you believe is compatible with the technical architecture and spirit of the Forta Network, or no license at all. However, by deploying your bot to the Network, other participants in the Network will act as if you are giving an implied license to utilize your bot in accordance with the protocol rules (e.g. nodes will run your bot, users may subscribe to your bot, etc). </p>"},{"location":"fees-faqs%20copy/#distribution-of-fees","title":"Distribution of Fees","text":"<p>How are fees distributed among bot owners?</p> <p>Data fees will be collected into the respective Unlock smart contract related to each plan (please check Technical Architecture for further details). These fees will then be programmatically distributed as rewards to the bot developers who create and maintain the detection bots in that plan (bot owners) at the end of each epoch.</p> <p>Rewards are distributed on a weekly basis to align with node rewards, by distributing 23.3% (7/30) of the accumulated fees at the end of each epoch.</p> <p>Distribution of rewards to bot developers among each will be distributed following the bot rewards formulas described in the documentation.</p> <p>Is there any other source of revenue for bot owners?</p> <p>There are several rewards programs in the Forta ecosystem that are independent of the distribution of data fees and compensate developers for developing detection bots. </p> <p>You can find some of the existing rewards programs on forta.org, although a bot developer might also get paid for building a bot for a third party.</p> <p>How to claim fees?</p> <p>Fees will be distributed directly to bot owners.</p>"},{"location":"fees-faqs%20copy/#technical-architecture","title":"Technical Architecture","text":"<p>What is the technical architecture of the Fees Implementation?</p> <p>The Forta Network implements the fee architecture using the Unlock Protocol smart contracts. Unlock offers a number of benefits including: - The Unlock smart contracts are open-source, including the Lock Factory contract, which is used for creating new Locks to enforce fees on-chain in the Forta Network. Locks are time-based, auto-renewable, subscription-enabling smart contracts (each plan in each token would have a respective Lock). - Unlock also offers additional functionality for users (e.g. helpful payment mechanisms), which is currently free. - Unlock is also in use by other established web3 projects.</p> <p>Implementing the initial fee structure in the Forta Network using Unlock does not present significant reliance on Unlock (i.e. switching to an alternative technical solution is feasible).</p>"},{"location":"fees-faqs%20copy/#node-runners-delegators","title":"Node Runners &amp; Delegators","text":"<p>Does the implementation of Data Fees have any impact on node runners and delegators? No, at the moment the implementation of Data Fees doesn\u2019t have any impact on node runners and delegators.</p>"},{"location":"fees-faqs%20copy/#about-premium-feeds","title":"About Premium Feeds","text":""},{"location":"fees-faqs%20copy/#premium-feed-requirements","title":"Premium Feed Requirements","text":"<p>Before a bot can qualify as a Premium Feed, it must meet certain requirements as specified by the Forta community in FP-6, related to technical performance, detection performance and documentation.  </p> <p>Technical performance: the bot must first: - Run on the public Forta Network for without dropping any alerts/labels  - emit public alerts and/or labels such that any user subscribing to the Feed could receive the threat intelligence via real-time notifications or the Forta Graphql API</p> <p>Detection performance: the bot must meet a certain level of precision as determined by the minimum requirements. </p> <p>Documentation: the owner must provide documentation that clearly and sufficiently describes how the bot works and the threat intel it generates, including details about specific alert Id\u2019s and labels, and associated metadata. </p> <p>Staking: There is no distinction between minimum stake for regular bots and for premium feed bots. Premium feed owners can stake more and advertise that as a higher security advantage, but it\u2019s not compulsory.</p> <p>Privacy and IP: For competitive and IP-related reasons, owners may be hesitant to make their detection logic publicly available in the bot itself. Therefore, Feed owners are permitted to keep their detection logic private if they choose.  Owners can host their own logic or models, as long as they relay the findings through a Forta bot (the Premium Feed), such that the intel can be consumed by subscribers. </p>"},{"location":"fees-faqs%20copy/#premium-feeds-pricing","title":"Premium Feeds Pricing","text":"<p>Each Premium Feed has a separate subscription fee (fee plan) set by the owner. Currently, the only fee structure supported by the Forta Network is a flat monthly rate (i.e. FORT 500 per 30 days). While certain community members have requested usage-based pricing in the future, initially both Premium and General plans will have flat monthly pricing and support unlimited API calls.  </p>"},{"location":"fees-faqs%20copy/#collection-of-fees","title":"Collection of Fees","text":"<p>The Forta Network implements the Unlock Protocol to facilitate on-chain payments. Users can purchase monthly subscriptions to a Premium Feed using either USDC or FORT, paid at the time of purchase. Monthly subscriptions expire at the end of each month and will be automatically renewed for another month to the extent there are sufficient assets in the user\u2019s wallet. </p> <p>Currently, 100% of the subscription fees generated by a Premium Feed are paid to the feed owner. This may change in the future based on network governance. </p> <p>Initially, fees will be manually distributed on-chain via a relayer to Feed owners once a week. We expect this process to be automated via smart contracts in the future. </p>"},{"location":"fees-faqs%20copy/#trials-for-premium-feeds","title":"Trials for Premium Feeds","text":"<p>Premium Feed owners should have the ability to offer free trials to their feed, and more details on how this can be funded or enabled will follow. </p>"},{"location":"fees-faqs%20copy/#maintenance-guarantees","title":"Maintenance guarantees","text":"<p>Premium Feeds must be actively maintained. If a maintainer no longer wishes to actively maintain the Feed, it must provide at least 30 days written notice to the Forta community via the governance forum and the Forta Discord. If a Premium Feed is abandoned, it may be removed from the Network in accordance with the community governance process. </p>"},{"location":"fees-faqs%20copy/#support","title":"Support","text":"<p>Premium Feed owners must commit to providing technical support to the Feed\u2019s subscribers. Support options could include: - Each Premium Feed has a dedicated support channel in the Forta Discord moderated by the Feed owner (members of the Forta Foundation team can be asked to support) - Owner provides contact information (i.e. email address, TG handle) on Feed\u2019s profile page so subscribers can reach out directly with questions</p>"},{"location":"fees-faqs%20copy/#sales-and-marketing","title":"Sales and Marketing","text":"<p>Each Feed owner is responsible for promoting and selling their own feed. That said, the Forta Foundation may engage in joint-marketing efforts with owners, and will promote the Forta Marketplace (Launch Date TBD). </p>"},{"location":"fees-faqs/","title":"FAQs about fees","text":"<p>Why is the Forta Network implementing subscription fees?</p> <p>Fees for subscriptions to bot alerts and related data feeds were implemented with overwhelming support of the community (that voted \u201cyes\u201d to FP-5 and FP-6), requiring users to pay for the data they consume, and rewarding the detection bot developers that create and maintain those data feeds. </p> <p>Developer rewards represent a vital component of a sustainable and decentralized Forta Network. These incentives create a flywheel effect in which developers create better data feeds, which bring more users, and that drives more revenue to developers, which again attracts more developers to build on Forta. These will be sustainable incentives, as they will be coming from real demand from users, and not from the protocol\u2019s treasury.</p> <p>What fees are being introduced in the Forta Protocol?</p> <p>At the moment, only fees to consume the Threat Intel Data: users will need to pay to access alerts, findings, and labels generated by the Forta Network. These fees will provide rewards to the participants in the network that generate corresponding data (i.e. bot owners).</p> <p>Will other fees be introduced in the future in the Forta Protocol?</p> <p>Other fees may be added to the Forta Network through future community governance proposals. For example, bot execution fees that could be paid by detection bot owners to directly reward node operators and their delegators for running bots on the network. Members of the Forta community are encouraged to explore how the Forta Network can evolve and explore how other types of fees might promote the long-term health of the network. </p>"},{"location":"fees-faqs/#users","title":"Users","text":"<p>What Threat Intel plans are available?</p> <ol> <li> <p>The General Plan: Forta\u2019s General Subscription Plan plan gives you access to 99%+ of the Network\u2019s hundreds of detection bots (ie. everything except Premium Feeds).You can also browse the 1,000+ other bots on the network here. The General Plan can only be paid in FORT.</p> </li> <li> <p>Premium Plans:  Premium Feeds are owned and maintained by one or more reputable community members (teams and/or individuals) and must meet certain requirements for performance and precision. The price for each Premium Feed is set by the owner. You can see all the Premium Feeds on the homepage of the Forta App once fees are live. Premium plans will be paid in either USDC or FORT. This decision is made by the premium feed\u2019s owner.</p> </li> </ol> <p>How to buy a plan?</p> <p>Plans can be bought directly through the respective Plan\u2019s smart contracts or using the Forta App in the Threat Intel Page that will go live on August 8th. You can also visit the documentation for all the details.</p> <p>How long do plans last?</p> <p>Plans have a duration of 30 days and are automatically renewed until canceled. If you do not hold sufficient funds in the wallet you subscribed with at the time of renewal, the renewal will fail and your subscription will lapse.</p> <p>How to cancel a plan?</p> <p>Users can cancel at any time, however their subscription will continue to give the user access until the end of their current subscription term. Current plans can be reviewed and canceled in the account tab of the Forta App, or directly through the smart contracts.</p> <p>What happens if I don\u2019t have enough funds in my wallet on the renewal date?</p> <p>If the user doesn\u2019t have enough funds in their wallet on the renewal date, the plan will be canceled. The user will need to add funds to the wallet and purchase the plan again to resume it.</p> <p>What happens if I don\u2019t have enough approved funds on the renewal date?</p> <p>If the user doesn\u2019t have enough approved funds on the renewal date, the plan will be canceled. The user will need to purchase the plan again to resume it.</p> <p>In this context, approved funds are the funds (USDC and/or FORT) that you have authorized the Forta dapp to access and move from your wallet. As with other Dapps, the Forta smart contracts need your permission -as the wallet owner- to access and move your tokens. For more information about token approvals, please check here. </p> <p>I already paid for the plan, now what? How can I access the data from the bots that belong to the plan I purchased?</p> <p>Intel from Premium Feeds and the individual bots on the General plan can be accessed either through Forta\u2019s GraphQL API (pull) or by subscribing to a bot directly (push). Purchasing one or more network subscriptions will give you access to both options. </p> <p>How do I manage my API keys?</p> <p>The user can manage their API keys in the API Keys section of the Forta App.</p> <p>I\u2019m subscribed to a bot but I\u2019m not getting notifications. Why?</p> <p>You might not have access to that bot intel on the plan you have purchased. Please, make sure the plan you\u2019ve purchased includes access to the bot you are trying to subscribe to.</p> <p>If the problem persists, you can always get technical support on Discord.</p> <p>I want to try Forta before purchasing, are there free trials?</p> <p>You can apply to gain access to a 1-month free trial of the General Plan here. </p> <p>Each premium feed owner manages their own discounts and free trials, please refer to the premium feed page to learn more or apply for the Scam Detector 1-month free trial here.</p> <p>Are there other terms and conditions applicable to my subscription?</p> <p>Assuming that a bot constitutes an original work of authorship under applicable copyright laws (software typically does), bot owners should automatically garner the right to license the use of their bot as they see fit. By deploying a bot to the Network, other participants in the Network will act as if a bot owner is giving an implied license to utilize their bot in accordance with the protocol rules (e.g. nodes will run your bot, users may subscribe to your bot if they pay the corresponding fees, etc). Bot owners may choose to apply other licensing terms to their bot(s), so be sure to review any such licensing terms (e.g. on Github or other documentation).</p>"},{"location":"fees-faqs/#bot-owners","title":"Bot Owners","text":"<p>I created a bot on the Network, what happens next?</p> <p>By default, any newly created detection bot will be automatically assigned to the General Plan. Anyone who wants to access your bot\u2019s data, will have to purchase the General Plan and subscribe or integrate with your bot.</p> <p>What happens if a premium feed consumes my bot data?</p> <p>Your bot will still be part of the General Plan, and you will collect the revenue it generates for being part of the General Plan. </p> <p>Whether the premium feed owner has funded your bot development or has agreed with you on the bot\u2019s usage, the premium feed belongs to the owner and he can decide to distribute the revenue the Premium feed collects or not.</p> <p>What are the benefits of having a Premium Feed on Forta?</p> <p>The benefits of launching a Premium Feed on Forta are (a) leveraging Forta\u2019s infrastructure, including thousands of node runners, and (b) leverage Forta\u2019s position as the leading network for threat intelligence in Web3 and exposing your data to a larger audience.</p> <p>Do I have to pay to make my bot a premium feed?</p> <p>No, you will have to submit a proposal at the Forta\u2019s forum to get governance approval. Premium Feeds must meet certain requirements for performance and precision, but every bot developer can submit a proposal to make their bots premium feeds.</p> <p>How do I make a premium feed?</p> <p>Every Bot developer and owner can submit a proposal on the Forta forum to make their bots a Premium Feed. </p> <p>The proposal needs to include, - Name of Premium Plan, - Proof of bot ownership and owner name, - Price in FORT or USDC, - Performance data; - Documentation; - Compatible licensing (Forta Bot License 1.0 is compatible, but not required); - Owner\u2019s Polygon wallet address for fee collection</p> <p>Here an example proposal.</p> <p>Provided that a submission to create a Premium Plan submission includes all the requisite information, a Premium Plan can be approved in one of two ways through the community governance process,</p> <ul> <li>the Forta Council can approve the Premium Plan (for clarity, the Council may delegate any of its responsibilities as appropriate, e.g. depending on the volume of requests), or</li> <li>majority approval of the Premium Plan by the community via Snapshot voting using the FPP process with at least 1 million FORT votes.</li> </ul> <p>Once and if your proposal gets governance approval, your feed will be included in the Forta Threat Intel page and you will be responsible for maintaining it and managing its users.</p> <p>Can I change the price of my Premium Feed?</p> <p>The price of the premium feed is approved by governance proposal on the Forta forum - and the owner can change it by submitting a follow up proposal (although current subscribers to that plan will keep using it at the same price until the subscription term ends). </p> <p>Do I need to purchase a plan to access the data produced by my own bots?</p> <p>Yes, if a bot owner wishes to receive data from the Forta Network they will need to pay the corresponding plan to access the data generated by their bots. Assuming a bot owner legally owns their own bot, they could run it locally, however this would not garner the benefit of it being run by the decentralized Forta node network.</p> <p>For premium plans, all fees are currently paid directly to the plan owner, so if you are the owner and are required to pay, effectively you will get 100% of that amount back as rewards. </p> <p>If a bot belongs to the General Plan, the fees collected will be part of the general pool and distributed to all the bots in the plan according to the bot rewards formula, so the owner who is paying to access his own bot from the general plan may have their costs offset. </p> <p>Do I need to purchase a plan if my bots read Forta data from other bots?</p> <p>If a detection bot reads Forta data, the bot owner would need to pay respective data fees for the data they rely on (from the corresponding plan) or their bot will not function correctly.</p> <p>Does my bot need a license?</p> <p>Assuming that your bot constitutes an original work of authorship under applicable copyright laws (software typically does), you should automatically garner the right to license the use of your bot as you see fit, whether on the Forta Network or anywhere else. With this in mind, the Forta Foundation funded the development of the \u201cForta Bot License\u201d. You are free to adopt the Forta Bot License if you think it fits your purpose! Alternatively, you can adopt any other license you believe is compatible with the technical architecture and spirit of the Forta Network, or no license at all. However, by deploying your bot to the Network, other participants in the Network will act as if you are giving an implied license to utilize your bot in accordance with the protocol rules (e.g. nodes will run your bot, users may subscribe to your bot, etc). </p>"},{"location":"fees-faqs/#distribution-of-fees","title":"Distribution of Fees","text":"<p>How are fees distributed among bot owners?</p> <p>Data fees will be collected into the respective Unlock smart contract related to each plan (please check Technical Architecture for further details). These fees will then be programmatically distributed as rewards to the bot developers who create and maintain the detection bots in that plan (bot owners) at the end of each epoch.</p> <p>Rewards are distributed on a weekly basis to align with node rewards, by distributing 23.3% (7/30) of the accumulated fees at the end of each epoch.</p> <p>Distribution of rewards to bot developers among each will be distributed following the bot rewards formulas described in the documentation.</p> <p>Is there any other source of revenue for bot owners?</p> <p>There are several rewards programs in the Forta ecosystem that are independent of the distribution of data fees and compensate developers for developing detection bots. </p> <p>You can find some of the existing rewards programs on forta.org, although a bot developer might also get paid for building a bot for a third party.</p> <p>How to claim fees?</p> <p>Fees will be distributed directly to bot owners.</p>"},{"location":"fees-faqs/#technical-architecture","title":"Technical Architecture","text":"<p>What is the technical architecture of the Fees Implementation?</p> <p>The Forta Network implements the fee architecture using the Unlock Protocol smart contracts. Unlock offers a number of benefits including: - The Unlock smart contracts are open-source, including the Lock Factory contract, which is used for creating new Locks to enforce fees on-chain in the Forta Network. Locks are time-based, auto-renewable, subscription-enabling smart contracts (each plan in each token would have a respective Lock). - Unlock also offers additional functionality for users (e.g. helpful payment mechanisms), which is currently free. - Unlock is also in use by other established web3 projects.</p> <p>Implementing the initial fee structure in the Forta Network using Unlock does not present significant reliance on Unlock (i.e. switching to an alternative technical solution is feasible).</p>"},{"location":"fees-faqs/#node-runners-delegators","title":"Node Runners &amp; Delegators","text":"<p>Does the implementation of Data Fees have any impact on node runners and delegators? No, at the moment the implementation of Data Fees doesn\u2019t have any impact on node runners and delegators.</p>"},{"location":"fees-faqs/#about-premium-feeds","title":"About Premium Feeds","text":""},{"location":"fees-faqs/#premium-feed-requirements","title":"Premium Feed Requirements","text":"<p>Before a bot can qualify as a Premium Feed, it must meet certain requirements as specified by the Forta community in FP-6, related to technical performance, detection performance and documentation.  </p> <p>Technical performance: the bot must first: - Run on the public Forta Network for without dropping any alerts/labels  - emit public alerts and/or labels such that any user subscribing to the Feed could receive the threat intelligence via real-time notifications or the Forta Graphql API</p> <p>Detection performance: the bot must meet a certain level of precision as determined by the minimum requirements. </p> <p>Documentation: the owner must provide documentation that clearly and sufficiently describes how the bot works and the threat intel it generates, including details about specific alert Id\u2019s and labels, and associated metadata. </p> <p>Staking: There is no distinction between minimum stake for regular bots and for premium feed bots. Premium feed owners can stake more and advertise that as a higher security advantage, but it\u2019s not compulsory.</p> <p>Privacy and IP: For competitive and IP-related reasons, owners may be hesitant to make their detection logic publicly available in the bot itself. Therefore, Feed owners are permitted to keep their detection logic private if they choose.  Owners can host their own logic or models, as long as they relay the findings through a Forta bot (the Premium Feed), such that the intel can be consumed by subscribers. </p>"},{"location":"fees-faqs/#premium-feeds-pricing","title":"Premium Feeds Pricing","text":"<p>Each Premium Feed has a separate subscription fee (fee plan) set by the owner. Currently, the only fee structure supported by the Forta Network is a flat monthly rate (i.e. FORT 500 per 30 days). While certain community members have requested usage-based pricing in the future, initially both Premium and General plans will have flat monthly pricing and support unlimited API calls.  </p>"},{"location":"fees-faqs/#collection-of-fees","title":"Collection of Fees","text":"<p>The Forta Network implements the Unlock Protocol to facilitate on-chain payments. Users can purchase monthly subscriptions to a Premium Feed using either USDC or FORT, paid at the time of purchase. Monthly subscriptions expire at the end of each month and will be automatically renewed for another month to the extent there are sufficient assets in the user\u2019s wallet. </p> <p>Currently, 100% of the subscription fees generated by a Premium Feed are paid to the feed owner. This may change in the future based on network governance. </p> <p>Initially, fees will be manually distributed on-chain via a relayer to Feed owners once a week. We expect this process to be automated via smart contracts in the future. </p>"},{"location":"fees-faqs/#trials-for-premium-feeds","title":"Trials for Premium Feeds","text":"<p>Premium Feed owners should have the ability to offer free trials to their feed, and more details on how this can be funded or enabled will follow. </p>"},{"location":"fees-faqs/#maintenance-guarantees","title":"Maintenance guarantees","text":"<p>Premium Feeds must be actively maintained. If a maintainer no longer wishes to actively maintain the Feed, it must provide at least 30 days written notice to the Forta community via the governance forum and the Forta Discord. If a Premium Feed is abandoned, it may be removed from the Network in accordance with the community governance process. </p>"},{"location":"fees-faqs/#support","title":"Support","text":"<p>Premium Feed owners must commit to providing technical support to the Feed\u2019s subscribers. Support options could include: - Each Premium Feed has a dedicated support channel in the Forta Discord moderated by the Feed owner (members of the Forta Foundation team can be asked to support) - Owner provides contact information (i.e. email address, TG handle) on Feed\u2019s profile page so subscribers can reach out directly with questions</p>"},{"location":"fees-faqs/#sales-and-marketing","title":"Sales and Marketing","text":"<p>Each Feed owner is responsible for promoting and selling their own feed. That said, the Forta Foundation may engage in joint-marketing efforts with owners, and will promote the Forta Marketplace (Launch Date TBD). </p>"},{"location":"fees-tut-how-earn/","title":"Tutorial | How to earn developing on Forta","text":"<p>By default, any newly created detection bot will be automatically assigned to the General Plan. Anyone who wants to access your bot\u2019s data, will have to purchase the General Plan and subscribe or integrate with your bot.</p> <ol> <li> <p>Create a bot, deploy it and run it on the Forta Network. Visit the \u201cBuild on Forta\u201d section to learn more about bot development!</p> </li> <li> <p>When deploying your detection bot, make sure the bot has a minimum stake of 100 FORT. Stake is important to protect the Network from spam and malicious bots.</p> </li> <li> <p>Voil\u00e0! The deployed bot is by default part of the general plan. The revenue you make on your bot depends on the number of subscribers the bot gets and the total revenue from the General Plan.</p> </li> <li> <p>Every week, the accumulated revenues will be transferred to your wallet - the one associated with your bot (aka the bot\u2019s owner).</p> </li> </ol> <p>About Premium Plans</p> <p>In FP-6, the community approved the minimum requirements and process for the creation of a Premium Plan. </p> <p>Premium Plans provide paid access to specialized bots or data feeds, purchasable separately at tailored pricing. Any bot owner is able to submit a request to create their own Premium Plan(s) to include the data from their bot(s).</p> <p>Premium Plan Minimum Requirements</p> <p>A Premium Plan proposal must include the following information for the respective bot(s) in order to be created: - desired name of Premium Plan; - proof of bot ownership and owner name(s); - price in FORT or USDC; - performance information; - documentation; - compatible licensing (Forta Bot License 1.0 is compatible, but not required); - owner wallet address for fee receipt (on Polygon);</p> <p>Creation of a Premium Plan</p> <ol> <li> <p>You owned a bot that is running on the Network? You can submit a proposal for it to become a premium plan.</p> </li> <li> <p>Draft a proposal with the description of your Bot following the minimum requirements stated above. Here is one of the proposals that have been submitted to use as an example!</p> </li> <li> <p>Publish it on the Forta Forum on the Premium Feeds Proposals section by clicking on the New Topic button. </p> </li> <li> <p>Although your proposal is live - and will be taken into consideration for governance approval - make sure the community is aware of it by sharing it on your social media, the Forta Network Discord or reaching out to the Foundation\u2019s team to get it posted on the official channels.</p> </li> <li> <p>Provided that a submission to create a Premium Plan submission includes all the requisite information, a Premium Plan can be approved in one of two ways through the community governance process:</p> </li> <li> <p>the Council approves the Premium Plan at its next Council meeting (for clarity, the Council may delegate any of its responsibilities as appropriate, e.g. depending on the volume of requests), or</p> </li> <li>majority approval of the Premium Plan by the community via Snapshot voting using the FPP process with at least 1 million FORT votes.</li> <li>If the minimum requirements have not reasonably been demonstrated, the proposal to create a Premium Plan may not be approved. Any subsequent changes to a Premium Plan (including price) requested by an owner are considered according to the same process as set out above, subject to reasonable limits on change requests.</li> </ol> <p>Slashing</p> <p>As always, anyone has the ability to refer any bot included in any plan (including Premium Plans) to the Arbiter Multisig under the Forta Network Slashing Policy if they believe a bot under any plan presents a security risk to the Network or is otherwise malicious.</p> <p>Other Terms and Conditions applicable to Premium Plans</p> <p>Assuming that your bot constitutes an original work of authorship under applicable copyright laws (software typically does), you should automatically garner the right to license the use of your bot as you see fit, whether on the Forta Network or anywhere else. With this in mind, the Forta Foundation funded the development of the \u201cForta Bot License\u201d. You are free to adopt the Forta Bot License if you think it fits your purpose! Alternatively, you can adopt any other license you believe is compatible with the technical architecture and spirit of the Forta Network, or no license at all. However, by deploying your bot to the Network, other participants in the Network will act as if you are giving an implied license to utilize your bot in accordance with the protocol rules (e.g. nodes will run your bot, users may subscribe to your bot, etc).</p> <p>Given that bot developers typically retain the intellectual property rights in their bots, it is expected that any bot developer could enforce additional licensing terms applicable to their bot and seek legal action against any users that violate their particular licensing terms.</p>"},{"location":"fees-tut-how-pay/","title":"Tutorial | How to Pay for Forta","text":"<p>Users can now purchase new plans on the Forta App.</p> <ol> <li> <p>Discover all the premium plans available on Forta on the Forta App Homepage, you can also explore what is included in the General Plan on the Forta App. </p> </li> <li> <p>Click on any of the premium plans cards to learn more about that specific premium plan (from the bot\u2019s performance, to the number of subscribers it has). </p> </li> <li> <p>Whether it\u2019s on the homepage or on the specific bot\u2019s page, you can click on the \u201cBuy\u201d button to initiate the payment flow from that specific plan.</p> </li> <li> <p>Log in to your account connecting your wallet to access to your \u201cMy Account\u201d section (or sign up if it is the first time you are logging in).</p> </li> <li> <p>You will be redirected to the Forta\u2019s Unlock checkout page to complete the transaction </p> </li> <li> <p>Please, confirm that the wallet that will receive the plan is correct or select a different one. Although optional, we strongly suggest you share an email so that any updates on the Plan you are purchasing can be shared with you!</p> </li> <li> <p>It is also important to complete the company you are part of (or you represent) to better understand how you will be using Forta. Please, fill in the company field if possible! </p> </li> <li> <p>Check that the plan\u2019s price is correct and select \u201cPay via cryptocurrency\u201d. </p> </li> <li> <p>Click \u201cPay using crypto\u201d </p> </li> <li> <p>Next, a wallet popup will appear to approve the plan\u2019s USDC or FORT payment</p> </li> <li> <p>Any purchased plan will auto-renew as long as you have enough approved funds in your wallet.</p> </li> <li> <p>If there are not enough approved funds, the plan will not auto-renew.</p> </li> <li> <p>Select the desired amount you want to approve (calculate additional funds required for future subscriptions) and click \u201cNext\u201d. </p> </li> <li> <p>Review the information and click \u201cApprove\u201d </p> </li> <li> <p>Once the funds are approved, you will get a new wallet notification to confirm the payment. Review and select \u201cConfirm\u201d </p> </li> <li> <p>Once the transaction is confirmed you will see the following confirmation and you can click \u201cReturn to site\u201d to go back to the Forta App. </p> </li> <li> <p>After a few minutes you will see the purchased plan populated under the \u201caccount\u201d tab in the Forta App. </p> </li> </ol>"},{"location":"fees-why/","title":"Why Fees?","text":"<p>Overview on Fees</p> <p>When the Forta Network launched in Fall 2021, a majority of the early detection bots were developed directly by DeFi protocols, or third party developers working under a grant from a DeFi project. Their incentive was to protect the protocols they worked for. As the network expanded to more threat-focused detection bots, the Forta Foundation launched the Threat Research initiative (TRi) to incentivize developers to participate in a variety of threat detection-related activities including bot development, exploit analysis and threat hunting. TRi participants were rewarded with a variety of one-time bounties. </p> <p>All of these incentives have proven useful to bootstrap an initial developer community, but they offer limited upside to individual developers and are not sustainable over a long time horizon. In order to attract and reward developers to build high quality detection bots, the network needs native incentive mechanisms. </p> <p>Allowing bot developers to collect fees from users has several important advantages:</p> <ol> <li>Uncapped upside potential. High quality bots with broad appeal can attract hundreds, even thousands of subscribers. The more effort a bot developer is willing to put towards maintaining and promoting a bot also increases the likelihood of attracting more paying subscribers. For individual developers that may not want to build and operate a security company, Forta offers an opportunity to monetize their skills in an asymmetric way. For security teams, building on Forta offers an opportunity to sell into an existing ecosystem of potential subscribers or users . </li> <li>Recurring revenue. As described below, a monthly subscription model allows bot developers to generate a recurring stream of revenue from their bots. Over time, this could result in an exponential increase in earnings when compared to one-time bounties and grant payouts. </li> <li>Market-based pricing. Bounties and grants compensate the developer for their time at an agreed-upon hourly rate. On the other hand, subscription fees allow  the market to determine a detection bot\u2019s value. The higher the value, or perceived value, the more a bot developer can justifiably charge.  </li> </ol>"},{"location":"fees-why/#forta-subscription-plans","title":"Forta Subscription Plans","text":"<p>Overview</p> <p>As previewed above, fees will come in the form of monthly subscriptions. Users that want to receive alerts and other intelligence generated by Forta detection bots will need to purchase one or more monthly subscription plans. Initially, there will be two types of plans: Premium and General.</p> <ul> <li> <p>Premium Plans: A handful of high quality, high value detection bots that meet minimum requirements set forth in FP-6 (i.e. Scam Detector). Access to these premium bots feeds? will each require a separate subscription, the price of which will be set by the bot\u2019s owner. The bot owner can also specify whether the monthly subscription is paid for in FORT or USDC.</p> <p>Note: If you are a developer and want your detection bot to be available as a Premium plan on the Forta Network, you can submit a forum proposal by following the instructions here.  </p> </li> <li> <p>General Plan: Grants a user access to alerts and other intel generated by all bots on the network other than premium bots. Given the likely number of premium bots, the General Plan effectively gives users access to over 99% of bots on the network, including all protocol-specific bots (i.e. Lido, MakerDAO, Compound, etc.). As part of FP-6, the Forta community voted to initially price the General Plan at 250 FORT/month. If you are a DeFi protocol team and only subscribed to your protocol\u2019s bot, your total monthly cost to continue using those bots will be 250 FORT (or approximately $32 at the time of publishing). This price of the General Plan may change in the future based on community governance. </p> </li> </ul> <p>Impact on Bot Developers</p> <p>Because bot developers are the primary value creators on the network, 100% of subscription revenue will be distributed to bot developers. Premium bot owners will receive 100% of Premium plan revenue for their bot. Example, if Premium Plan A is priced at $100 USDC/mo and receives 10 subscribers in August, the bot\u2019s owner will receive $1,000 USDC. General Plan revenue will be distributed pro-rata based on a bot\u2019s subscriber count for a given week.</p> <p>Impact on Users</p> <p>Subscription plan purchases will occur on chain in either FORT or USDC using Unlock Protocol. For simplicity\u2019s sake, all subscriptions will be monthly and can be auto-renewed to the extent there are sufficient assets in your wallet. We are currently evaluating different ways to implement usage based pricing which has been requested by certain community members. Currently, both the Premium and General plans will be available for a flat monthly price and will support unlimited API calls. </p> <p>Post-fees launch, accessing Forta data will continue to work the same. Users who purchase one or more plans can access alerts and other intel by subscribing directly to a bot or via Forta\u2019s GraphQL API. </p>"},{"location":"fort-holder-staking-guide/","title":"Delegate Your FORT Using the Forta App","text":"<p>Delegated staking is an essential part of the Forta Network, and choosing the right scanner pool is crucial if you want to maximize your potential for rewards. This guide will walk you through the process of choosing a scanner pool, depositing stake, and withdrawing stake using the Forta App. As always, you can also interact with the smart contracts directly on Polygon.</p>"},{"location":"fort-holder-staking-guide/#choosing-a-scanner-pool","title":"Choosing a Scanner Pool","text":"<p>To choose a scanner pool, you can visit the pools page in the Forta App and consider the following factors:</p> <ol> <li> <p>Yield Score: This is the output of a formula (APY Pool_i = {1 + ( LastEpochRewardsForDelegators_i / LastEpochDelegatorsTotalStake_i )} ^ 52 -1) that nodes and other community members have found helpful when thinking about potential rewards from delegation. The formula extrapolates potential rewards on an annual basis, based on the pool\u2019s rewards from the last epoch.</p> </li> <li> <p>SLA Score: Higher SLA scores in an epoch result in higher rewards. This metric is viewable in each pool profile.</p> </li> <li> <p>Uptime: More time online in an epoch results in higher rewards. This metric is viewable in each pool profile.</p> </li> <li> <p>Commission:  Lower node commissions result in higher rewards for delegators. Note that pool owners can modify their commissions periodically each epoch.</p> </li> <li> <p>Available stake allocation capacity: Unallocated stake does not generate rewards.</p> </li> </ol> <p>Remember to monitor your delegations and engage with the Forta Discord community to identify reputable Pool Operators. Although the factors above may inform your decision, they are based on past performance and are no guarantee about future results.</p> <p></p>"},{"location":"fort-holder-staking-guide/#depositing-stake","title":"Depositing Stake","text":"<p>Delegated stake must be deposited to make scan nodes operational and generate rewards.</p>"},{"location":"fort-holder-staking-guide/#delegating-to-a-pool","title":"Delegating to a Pool","text":"<ol> <li> <p>Discover a node pool on the pools page with a node and enough stake to accommodate your desired delegation amount.</p> </li> <li> <p>Navigate to the node pool page by clicking on the pool id.</p> </li> <li> <p>Click the \"Delegate\" button.</p> </li> <li> <p>Approve the amount of FORT to delegate with your wallet and wait for the transaction to confirm.</p> </li> <li> <p>Delegate the approved FORT with your wallet and wait for the transaction to confirm.</p> </li> </ol> <p>Of course, you can also always interact with the smart contracts directly on Polygon.</p> <p></p>"},{"location":"fort-holder-staking-guide/#depositing-on-your-own-pool","title":"Depositing on Your Own Pool","text":"<ol> <li> <p>In the Forta App, navigate to \"My Node Pools.\"</p> </li> <li> <p>Click on the node pool you want to add stake to.</p> </li> <li> <p>Click \"Add Stake.\"</p> </li> <li> <p>Approve the amount of FORT to stake with your wallet and wait for the transaction to confirm.</p> </li> <li> <p>Stake the approved FORT with your wallet and wait for the transaction to confirm.</p> </li> </ol> <p></p>"},{"location":"fort-holder-staking-guide/#withdrawing-stake","title":"Withdrawing Stake","text":"<p>To withdraw your stake, navigate to the \"My Stakes\" page from the top right menu. Please note that there is a 10-day lockdown period for stake withdrawal.</p> <p>For detailed instructions on how to delegate your stake to a scanner pool and withdraw your stake using the Forta App, visit the pool and stake management page.</p>"},{"location":"fort-holder-staking-guide/#claiming-rewards","title":"Claiming Rewards","text":"<p>To claim rewards, visit the \"My Rewards\" page from the top right menu of the Forta App. You check on the rewards page to see if you have any available rewards and claim rewards from multiple epochs with a single action.</p> <p>Reward calculation starts after the end of each epoch (Monday 00:00:00 UTC). Rewards are written to the rewards distributor contract as soon as the calculation is completed. As soon as the rewards are available in the contract, pool owners and delegators can claim their portion of reward via the Forta App. If you wish to collect rewards manually via Polygonscan, you can follow the guide here.</p>"},{"location":"fort-token/","title":"FORT Token","text":"<p>FORT is an ERC-20 token in the Ethereum network. (Address: 0x41545f8b9472D758bB669ed8EaEEEcD7a9C4Ec29)</p> <p>Staking is only available in Polygon, so anyone who wants to stake needs to bridge FORT to Polygon to do so (https://wallet.polygon.technology/), or acquire FORT tokens directly in Polygon. FORT\u2019s address in Polygon is: 0x9ff62d1FC52A907B6DCbA8077c2DDCA6E6a9d3e1 </p>"},{"location":"fort-token/#how-is-the-fort-token-used-in-forta","title":"How is the FORT token used in Forta?","text":"<p>To ensure the accuracy and integrity of the data provided by the network, Forta adopts a work token model, where both scan node pools and detection bots must have FORT staked above a minimum requirement. This acts as an economic security mechanism of their actions in their network, as the stake can be slashed if participants act maliciously.</p> <p>FORT has the following primary uses that are indispensable to the proper functioning of the network:</p> <ol> <li> <p>Scanner Pool Staking:</p> <ol> <li> <p>Scanner pool owners must deposit FORT tokens on their pools to be discoverable in the network and to provide economic security for the work they are performing, since the staked FORT can be slashed if nodes fail to execute their assigned work or perform their work maliciously. Once FORT is staked, it may only be withdrawn subject to a thawing period, which provides ample opportunity for verification and dispute resolution.</p> </li> <li> <p>Delegators may also stake on a pool, with the same withdrawal restrictions. The Delegators may face a smaller percentage of deduction from the stake in case the pool gets slashed.</p> </li> </ol> </li> <li> <p>Detection Bot Staking: Developers must stake FORT tokens on bots, signaling bot quality to the network and also providing a sybil resistance mechanism.</p> </li> <li> <p>Payment of Data Fees: Users who want to buy Forta\u2019s General Plan to consume data from the network must pay a monthly fee, denominated and paid in FORT. In addition, premium feeds can be denominated and paid either in FORT or in USDC, subject to the feed owner\u2019s decision.</p> </li> </ol> <p>In addition, FORT holders can participate in governance to shape the evolution of Forta. Please read more in the governance section of the docs.</p>"},{"location":"fort-token/#token-distribution","title":"Token Distribution","text":"<p>The total supply of FORT tokens has been capped at 1,000,000,000 FORT.</p> <p></p>"},{"location":"fort-token/#community-allocation","title":"Community Allocation","text":"<p>The FORT Community Allocation is held by the Forta Foundation and is not subject to a specific vesting or distribution schedule.</p> <p>As of August 2023, less than 45 million FORT have been distributed to community members and above 41% of FORT\u2019s total supply is still held by Forta Foundation in the community treasury. Tokens that were distributed belong to: rewards to node pools, FORT\u2019s airdrop to early community members and builders, rewards to node operators during Fortification phase, and grants to community developers under the Threat Research Initiative (TRi) program, to developers under Gitcoin grants and Gitcoin bounties programs, to community contributors like Blocksec and Nethermind, to universities such as OSU and UCSB for academic threat research funding, and to audit firms such as MixBytes, ChainSecurity and OpenZeppelin, among other grants.</p>"},{"location":"fort-token/#other-allocations","title":"Other Allocations","text":"<p>Other FORT token allocations include tokens held by Backers, Initial Core Contributors, and OpenZeppelin. All three groups are subject to transfer restrictions that are removed according to 4-year linear vesting periods with a 1-year cliff. FORT tokens allocated to these groups began vesting on September 1, 2021 and will be fully transferable by September 1, 2025.</p>"},{"location":"fort-token/#backers","title":"Backers","text":"<p>The Forta Network received early support from a group of dedicated backers who not only provided funding for the development of Forta, but also became some of the earliest members of the Forta community, providing key networking and support across various functions. Backers also represented some of the first node operators in the Forta Network. Backers\u2019 transfer restrictions are enforced through on-chain vesting smart contracts. </p>"},{"location":"fort-token/#initial-core-contributors","title":"Initial Core Contributors","text":"<p>The Forta Network was originally developed and brought to the community by an innovative and interdisciplinary team of individuals within OpenZeppelin. 20% of the total FORT token supply has been allocated for these individuals as Initial Core Contributors and is subject to 4-year linear vesting periods with a 1-year cliff, enforced by OpenZeppelin. The earliest vesting commencement date for Initial Core Contributors\u2019 FORT token allocations was September 1, 2021, which aligned with the transfer restrictions for the Backers.</p> <p></p>"},{"location":"fort-token/#openzeppelin","title":"OpenZeppelin","text":"<p>OpenZeppelin is a leading blockchain security company that founded and incubated the Forta Network. 10% of the total FORT token supply has been allocated to OpenZeppelin and is subject to 4-year linear vesting periods with a 1-year cliff. The vesting commencement date for OpenZeppelin\u2019s FORT token allocation was September 1, 2021.</p> <p></p>"},{"location":"forta-quickstart/","title":"Getting started with Forta","text":"<p>In this article you will gain a high-level understanding of Forta detection bot development including myths, development workflows, dApps and SDKs that will lay out a clear path to develop on Forta. This article is intended for developers who are new to Forta and assumes you already have some general knowledge about blockchains such as smart contracts and tokens. Let\u2019s jump right in!</p>"},{"location":"forta-quickstart/#demystifying-forta-development","title":"Demystifying Forta development","text":"<p>The most important thing for new Forta developers to understand is that it is not a requirement to have experience with blockchain development to get started building on Forta. In fact, your web2 development experience transfers directly to detection bot development. In Forta, detection bots are programs running on the Forta Network that scan the blockchain for events of interest and alerts users about them e.g. large token transfers or declining account balances. While detection bots can be written in any language, Forta provides convenient SDKs in Javascript, Typescript and Python for you to get started easily. Detection bots are the heart of the Forta Network as they alert users of any suspicious or anomalous activity. There are currently many bots deployed for users to interact and integrate with.</p>"},{"location":"forta-quickstart/#30000-foot-view","title":"30,000 foot view","text":"<p>Let\u2019s start by understanding the big picture of the Forta Network and the different components involved. Keep in mind that this diagram is an oversimplification to allow for easy understanding.</p> <p></p> <p>On the far left there are the Forta developer tools that are used by detection bot developers to build and deploy bots to the Forta Network. These developer tools are described in more detail later on. Once deployed, the detection bots are run by Forta scan nodes. You can think of scan nodes as servers that provide capacity to the Forta Network. Scan nodes are responsible for running detection bots, providing them blockchain data and publishing any alerts. Detection bots use the blockchain data to detect some condition they are interested in, and can also make network calls to other APIs to combine richer data sources.</p> <p>In the middle of the diagram are the scan nodes that comprise the Forta Network. Anyone can run a scan node as long as they stake the required amount of FORT tokens. Each scan node listens for blocks and transactions from a blockchain. Currently the Forta Network runs scan nodes for EVM (Ethereum Virtual Machine) blockchains such as Ethereum, Polygon, BNB, Avalanche, Arbitrum, Optimism and Fantom. Each scan node is assigned a set of detection bots to run by the Forta Network. The scan node collects any alerts reported by the detection bots and publishes them. You can view the complete list of scan nodes on the Forta App Network page.</p> <p>On the far right of the diagram are the users of the Forta Network who are interested in receiving alerts. Users can subscribe to alerts from a specific detection bot, or alerts about a specific blockchain address using the Forta App. They can also browse and search the latest alerts using the Forta App. Also, more technical users can query for alerts using the Forta API to integrate alert feeds right into their own applications.</p>"},{"location":"forta-quickstart/#forta-development-workflows","title":"Forta development workflows","text":"<p>The primary development workflow for building detection bots involves the <code>forta-agent</code> CLI (command line interface) tool. Using the CLI, you can setup a detection bot project within seconds. As a general overview of the workflow, it starts from initialization, to development and testing, then finally deployment and maintenance.</p> <p>As mentioned earlier, Forta provides easy to use SDKs for detection bot development in Javascript/Typescript and Python. These allow you to focus on your bot\u2019s detection logic while taking care of the rest of the details. Once your bot is ready to deploy, you simply use the CLI to publish it to the Forta Network.</p> <p>A second development workflow involves the use of the Forta Hardhat plugin to create detection bots for your existing smart contract project. Hardhat is a smart contract development framework with a powerful plugin ecosystem. Using the Forta plugin, you can initialize detection bots right into your project. Also, you can choose from a set of low-code templates to setup detection bots for your project quickly.</p> <p>To deploy your bot to the Forta Network you can use the CLI or the Forta App, which provides a convenient UI to deploy and manage your detection bots. Deploying a bot involves making a transaction to the Bot Registry contract on the Polygon blockchain. This requires having MATIC tokens in order to pay the small transaction fee (in the order of a few cents). Developers just need to ensure they have enough MATIC tokens, and the CLI or Forta App will take care of executing the transaction. Once a detection bot is deployed to the Forta Network, users can subscribe to the alerts generated by the bot or consume them through the Forta API.</p>"},{"location":"forta-quickstart/#awesome-how-do-i-begin","title":"Awesome! How do I begin?","text":"<p>Now that you are ready to dive into detection bot development, the best place to start is the build your first detection bot tutorial. You will also find curated resources for developers and node operators throughout this docs website. To see real-world detection bots from well-known protocols check out the Forta App Discover page. Good luck and can\u2019t wait to see what you come up with!</p>"},{"location":"forta-session-10/","title":"Forta session 10","text":"<p>In this session we will cover the following topics:</p> <ul> <li>Smart Contract Security</li> <li>Reentrancy</li> <li>Arithmetic Overflows/Underflows</li> <li>Unexpected Ether</li> <li>DELEGATECALL</li> <li>Default Visibilities</li> <li>Entropy Illusion/ Timestamp Manipulation</li> <li>External Contract Referencing</li> <li>Short Address/ Parameter Attack</li> <li>Unchecked CALL Return Values</li> <li>DoS</li> <li>Constructors with Care</li> <li>Uninitialized Storage Pointers</li> <li>Floating Point and Precision</li> </ul> <p>Session 10 Slides</p>"},{"location":"forta-session-10/#assignments","title":"Assignments","text":"<p>Complete the following assigment: </p> <ul> <li>Assignment 5: Deploy, test, and interact with your second smart contract using Brownie and Web3 API] </li> </ul>"},{"location":"forta-session-11a/","title":"Forta session 11a","text":"<p>In this session we will cover the following topics:</p> <ul> <li>Smart Contract Security Assessment</li> <li>Fuzzing</li> <li>Static Analysis</li> <li>Audits</li> </ul> <p>Slides: None</p>"},{"location":"forta-session-11a/#assignments","title":"Assignments","text":"<p>Complete the following readings: </p> <ul> <li>Mastering Ethereum: Building Smart Contracts and DApps Chapters 8, 10</li> <li>Read about the DAO Attack</li> </ul> <p>Complete the following assigment: </p> <ul> <li>Assignment 6: Ethernaut Challenge Part I</li> </ul>"},{"location":"forta-session-11b/","title":"Forta session 11b","text":"<p>In this session we will cover the following topics:</p> <ul> <li>Blockchain Security Overview</li> </ul> <p>Session 11 Slides</p>"},{"location":"forta-session-11b/#assignments","title":"Assignments","text":"<p>None</p>"},{"location":"forta-session-12/","title":"Forta session 12","text":"<p>In this session we will cover the following topics:</p> <ul> <li>Security Strategies</li> <li>Real Time Monitoring</li> </ul> <p>Session 12 Slides</p>"},{"location":"forta-session-12/#assignments","title":"Assignments","text":"<p>None</p>"},{"location":"forta-session-13/","title":"Forta session 13","text":"<p>In this session we will cover the following topics:</p> <ul> <li>Threat Modelling Excercise</li> </ul> <p>Session 13 Slides</p>"},{"location":"forta-session-13/#assignments","title":"Assignments","text":"<p>Complete the following assigment: </p> <ul> <li>Assignment 7: Threat Model</li> </ul>"},{"location":"forta-session-14/","title":"Forta session 14","text":"<p>In this session we will cover the following topics:</p> <ul> <li>Ethernaut Challenge Walk Through</li> <li>Security Incident Deep Dive</li> </ul> <p>Session 14 Slides</p>"},{"location":"forta-session-14/#assignments","title":"Assignments","text":"<p>Complete the following readings: </p> <ul> <li>Review Forta documentation on developing a detection bot</li> </ul> <p>Complete the following assigments: </p> <ul> <li>Assignment 8: Ethernaut Challenge DoubleEntryPoint</li> <li>Assignment 9: Implement a Forta Detection Bot</li> </ul>"},{"location":"forta-session-15/","title":"Forta session 15","text":"<p>In this session we will cover the following topics:</p> <ul> <li>Ethernaut Challenge Part II</li> <li>Future Research Directions</li> </ul> <p>Session 15 Slides</p>"},{"location":"forta-session-15/#assignments","title":"Assignments","text":"<p>Complete the following readings: </p> <ul> <li>Mastering Ethereum: Building Smart Contracts and DApps Chapter 14</li> </ul> <p>Complete the following assigment: </p> <ul> <li>Assignment 10: Ethernaut Challenge Part II</li> </ul>"},{"location":"forta-session-1a/","title":"Introduction &amp; Goals","text":"<p>In this course, you will learn about blockchain technology with a focus on security. No prior knowledge in blockchain is required as we will cover the basics and theoretical concepts. </p> <p>The course will be applied and a hands interacting with the blockchain in a programmatic fashion (primarily utilizing Python, but JavaScript is also an option) and deploying smart contracts in solidity.</p> <p>In the second half of the course, we will focus on security concepts in blockchain with a general overview followed by a focus on on-chain monitoring and incident response.</p> <p>Note: The course was given in person, therefore it contains in person interactions that are valuable to the listener. Also it contains comments on the assignments which can be valuabe for those doing the assignments by their own. This course does not provide certification or assignment\u00b4s review.</p>"},{"location":"forta-session-1a/#reading-assignments-material","title":"Reading &amp; Assignments material","text":"<p>Textbook 1 - Mastering Ethereum: Building Smart Contracts and DApps by Andreas M. Antonopoulos and Gavin Wood Ph. D. </p> <p>Textbook 2 - Blockchain Foundation: Blockchain And Distributed Ledgers: Mathematics, Technology, And Economics by Alexander Lipton and Adrien Treccani.</p> <p>Assignments - All assignments can be found here</p>"},{"location":"forta-session-1a/#session-1a-overview","title":"Session 1A Overview","text":"<p>In this session we will introduce the instructor, Dr. Christian Seifert, and go over the goals and outline of the course. </p> <p>Session 1 Slides</p>"},{"location":"forta-session-1a/#assignments","title":"Assignments","text":"<p>None</p>"},{"location":"forta-session-1b/","title":"Motivation of Blockchain","text":"<p>In this session we will be going over the following topics:</p> <ul> <li>Financial Crisis 2008 / Monetary Policy 2020-now</li> <li>Impact of poor monetary policy (Turkey/ Argentina)  </li> <li>Bitcoin Whitepaper and History</li> <li>What is Money</li> </ul> <p>Session 1 Slides</p>"},{"location":"forta-session-1b/#assignments","title":"Assignments","text":"<p>Complete the following readings: </p> <ul> <li>Blockchain And Distributed Ledgers: Mathematics, Technology, And Economics Chapters 1 &amp; 2</li> </ul>"},{"location":"forta-session-2a/","title":"Blockchain History","text":"<p>In this session we will cover the following topics:</p> <ul> <li>Student Project Assignments</li> <li>Announcements \u2013 Github Repo</li> <li>Blockchain introduction and history</li> <li>Bitcoin</li> </ul> <p>Session 2 Slides</p>"},{"location":"forta-session-2a/#assignments","title":"Assignments","text":"<p>Complete the following readings: </p> <ul> <li>Blockchain And Distributed Ledgers: Mathematics, Technology, And Economics Chapter 3</li> </ul>"},{"location":"forta-session-2b/","title":"Ethereum &amp; Blockchain Use Cases","text":"<p>In this session we will cover the following topics:</p> <ul> <li>Ethereum</li> <li>Blockchain Use Cases</li> </ul> <p>Session 2 Slides</p>"},{"location":"forta-session-2b/#assignments","title":"Assignments","text":"<p>Complete the following readings: </p> <ul> <li>Blockchain And Distributed Ledgers: Mathematics, Technology, And Economics Chapter 3</li> </ul>"},{"location":"forta-session-3/","title":"Forta session 3","text":"<p>In this session we will cover the following topics:</p> <ul> <li>Cryptographic Foundation to Build a Blockchain</li> <li>Encryption</li> </ul> <p>Session 3 Slides</p>"},{"location":"forta-session-3/#assignments","title":"Assignments","text":"<p>Complete the following readings: </p> <ul> <li> <p>Blockchain And Distributed Ledgers: Mathematics, Technology, And Economics Chapters 4 &amp; Chapter 5</p> </li> <li> <p>Mastering Ethereum: Building Smart Contracts and DApps Chapter 4</p> </li> </ul>"},{"location":"forta-session-4a/","title":"Forta session 4a","text":"<p>In this session we will cover the following topics:</p> <ul> <li>Cryptographic Foundation to Build a Blockchain - Continuation</li> <li>Hashing</li> <li>Merkle Trees</li> <li>Advanced Cryptographic Concepts</li> <li>Zero Knowledge Proofs</li> <li>Homomorphic encryption</li> <li>Differential privacy</li> <li>Secure Multiparty Computation</li> <li>Building a blockchain</li> </ul> <p>Session 3 Slides</p> <p>Session 4 Slides</p>"},{"location":"forta-session-4a/#assignments","title":"Assignments","text":"<p>Complete the following assignment: </p> <ul> <li>Assignment 1: Install Metamask</li> </ul>"},{"location":"forta-session-4b/","title":"Forta session 4b","text":"<p>In this session we will cover the following topics:</p> <ul> <li>Cryptographic Foundation to Build a Blockchain - Continuation</li> <li>Hashing</li> <li>Merkle Trees</li> <li>Advanced Cryptographic Concepts</li> <li>Zero Knowledge Proofs</li> <li>Homomorphic encryption</li> <li>Differential privacy</li> <li>Secure Multiparty Computation</li> <li>Building a blockchain</li> </ul> <p>Session 4 Slides</p>"},{"location":"forta-session-4b/#assignments","title":"Assignments","text":"<p>None</p>"},{"location":"forta-session-5/","title":"Forta session 5","text":"<p>Start this session having a wallet installed and funded with ETH on the Rinkeby test net</p> <p>In this session we will cover the following topics:</p> <ul> <li>Ethereum Scratching the surface</li> <li>Nodes (Geth) and Infra Providers (Infura)</li> <li>Blockchain Explorer </li> <li>Gas/ EVM</li> <li>Smart Contracts</li> <li>Dapps</li> </ul> <p>Session 5 Slides</p>"},{"location":"forta-session-5/#assignments","title":"Assignments","text":"<p>Complete the following readings: </p> <ul> <li>Blockchain And Distributed Ledgers: Mathematics, Technology, And Economics (optional) Chapters 6, 9</li> <li>Mastering Ethereum: Building Smart Contracts and DApps Chapters 1-3, 5, 6</li> </ul>"},{"location":"forta-session-6/","title":"Forta session 6","text":"<p>In this session we will cover the following topics:</p> <ul> <li>Blockchain Explorer </li> <li>Devcon Bogota Summary</li> </ul> <p>Session 6 Slides</p>"},{"location":"forta-session-6/#assignments","title":"Assignments","text":"<p>Complete the following readings: </p> <ul> <li>Read documentation of web3py and ethers.js or web3.js (all content in class will be based on web3py)</li> </ul> <p>Complete the following assigment: </p> <ul> <li>Assignment 2: Install Development Environment I</li> </ul>"},{"location":"forta-session-7/","title":"Forta session 7","text":"<p>In this session we will cover the following topics:</p> <ul> <li>Start this session having development environment I installed</li> <li>Web3 API introduction</li> <li>Reading blockchain state</li> <li>Writing blockchain state</li> <li>Tools where web3 APIs fall short</li> <li>Etherscan API</li> <li>Dune.com / luabase.com</li> </ul> <p>Session 7 Slides</p>"},{"location":"forta-session-7/#assignments","title":"Assignments","text":"<p>Complete the following assigment: </p> <ul> <li>Assignment 2: Install Development Environment II</li> </ul>"},{"location":"forta-session-8a/","title":"Forta session 8a","text":"<p>Start this session having with development environment II installed</p> <p>In this session we will cover the following topics:</p> <ul> <li>Smart Contracts</li> </ul> <p>Session 8 Slides</p>"},{"location":"forta-session-8a/#assignments","title":"Assignments","text":"<p>Complete the following readings: </p> <ul> <li>Mastering Ethereum: Building Smart Contracts and DApps Chapter 7</li> </ul> <p>Complete the following assigment: </p> <ul> <li>Assignment 4: Dune / Luabase Query</li> </ul>"},{"location":"forta-session-8b/","title":"Forta session 8b","text":"<p>In this session we will cover the following topics:</p> <ul> <li>Solidity Programming 101</li> <li>Language Fundamentals</li> </ul> <p>Session 8 Slides</p>"},{"location":"forta-session-8b/#assignments","title":"Assignments","text":"<p>None</p>"},{"location":"forta-session-9/","title":"Forta session 9","text":"<p>In this session we will cover the following topics:</p> <ul> <li>Solidity Programming 102</li> <li>Inheritance</li> <li>Storage Slots</li> <li>Smart Contract Patterns</li> <li>Smart Contract Libraries</li> <li>Introduction to Development Env </li> <li>Remix</li> <li>Deploying, testing and interacting with your first smart contract using Remix</li> <li>Brownie</li> <li>Tenderly</li> </ul> <p>Session 9 Slides</p>"},{"location":"forta-session-9/#assignments","title":"Assignments","text":"<p>None</p>"},{"location":"getting-started-old/","title":"Getting Started","text":"<p>Welcome to the Forta Network! We\u2019re excited you\u2019re here. </p> <p>The Forta Network monitors on-chain activity in real-time, detecting threats and other security-related events. The network is made up of thousands of detection bots developed by a community of Web 3 developers and security experts. Each bot acts like a little security camera monitoring something specific on-chain. What the Forta Network detects is a direct result of the bots being run. Some bots monitor generic threats (i.e. phishing attacks), and others monitor protocol-specific activity (i.e. Lido).</p> <p>The output of all this monitoring and detection is what we refer to as threat intelligence - data that tells you the \u201cwho, what, when, where and how\u201d about Web3 threats and security events.   </p> <p>There are two primary users of the Forta Network:</p> <ul> <li>Consumers, who use threat intel generated by the network. You might be a Web3 wallet, a DeFi protocol, or a centralized exchange looking for the latest threat intel to protect your customers.</li> <li>Developers, who create and maintain detection bots. You might be an engineer interested in contributing to the overall security of Web3, or a DeFi core dev interested in using Forta to monitor your protocol.</li> </ul> <p>You may be a consumer, a developer, or both!</p>"},{"location":"getting-started-old/#consumers","title":"Consumers","text":"<p>As a consumer, you can access threat intel from individual bots, or use Forta\u2019s curated Threat Intel Feeds, which provide easy access to threat intel from a bundle of underlying bots. Bots included in the curated Threat Intel Feeds have met certain performance and precision requirements, are actively maintained and have higher staking requirements.</p> <p>There are two curated Threat Intel Feeds today:</p> <ul> <li>Scam Detector: an ideal source of intel about threats impacting end users (phishing, rug pulls, etc.). Users of the Scam Detector include Web3 wallets, end-user security tools, centralized exchanges, crypto compliance platforms and many others. Learn More and Integrate with the API.</li> <li>Attack Detector: a real-time feed of alerts about smart contract exploits impacting DeFi protocols and bridges. Learn More and Subscribe.</li> </ul> <p>You can also explore the 1,000+ individual bots running on the network using the Forta App. </p>"},{"location":"getting-started-old/#developers","title":"Developers","text":"<p>As a developer, you can use a suite of tools to develop new detection bots. </p> <ul> <li>Build Detection Bots with the SDK: Use the flexible Forta SDK to develop customized Detection Bots for your monitoring needs. Get started here.</li> <li>Build Detection Bots with the Bot Wizard: Create and deploy a Detection Bot through a UI, no code required. Learn how to create your custom bot.</li> <li>Commission Bots to the Community: Get connected to community members and development partners who have vast experience developing taylormade bots based on your requirements. Reach out to andy@forta.org for more details.</li> </ul>"},{"location":"getting-started/","title":"Getting Started","text":"<p>Welcome to the Forta Network! We\u2019re excited you\u2019re here. </p> <p>The Forta Network monitors on-chain activity in real-time, detecting threats, security-related events and other noteworthy activity. The network is made up of thousands of detection bots developed by a community of Web3 developers and security experts. Each bot acts like a little security camera monitoring something specific on-chain. Some bots monitor generic threats (i.e. phishing attacks, rug pulls), and others monitor protocol-specific activity (i.e. Lido, Compound).</p> <p>The output from all this monitoring and detection is what we call threat intelligence - data that tells you the \u201cwho, what, when, where and how\u201d about threats and security events.   </p> <p>There are two primary actors in the Forta Network:</p> <ul> <li>Users, who consume threat intel generated by the network. Users could be Web3 wallets, DeFi protocols, or centralized exchanges looking for the latest threat intel to protect their customers.  </li> <li>Developers, who create and maintain detection bots. They could be a leading Web3 security team, an independent security researcher or a DeFi core dev using Forta to monitor their protocol. </li> </ul>"},{"location":"getting-started/#users","title":"Users","text":"<p>Users can access threat intel generated by any bot on the network. Certain bots the community feels are particularly high value have been packaged up into Premium Feeds, like the Scam Detector. Premium Feeds are owned and maintained by one or more reputable community members (teams and/or individuals) and must meet certain requirements for performance and precision. The price for each Premium Feed is set by the owner. Intel from the other bots on the network can be accessed under the network\u2019s General subscription plan option.</p> <p>You can see all the Premium Feeds &lt;here&gt;. You can also browse the 1,000+ other bots on the network here.</p> <p>Intel from Premium Feeds and individual bots can be accessed either through Forta\u2019s GraphQL API (pull) or by subscribing to a bot directly (push) to receive notifications via email, Slack, or Telegram, among other options. Purchasing one or more network subscriptions allows you to access both options. </p>"},{"location":"getting-started/#developers","title":"Developers","text":"<p>Developers can use a suite of tools to build new detection bots. </p> <ul> <li> <p>Build Detection Bots with the SDK: Use the flexible Forta SDK to develop customized Detection Bots for your monitoring needs. Get started here. </p> </li> <li> <p>Build Detection Bots with the Bot Wizard: Create and deploy a Detection Bot through a UI, no code required. Learn how to create your custom bot. </p> </li> <li> <p>Want to outsource your bot development? Get connected to community members with experience developing custom bots. Reach out to andy@forta.org for more details.</p> </li> </ul>"},{"location":"governance-starter-kit/","title":"Governance Threat Detection Kit","text":"<p>Frequent Doc Updates</p> <p>Forta will continue to add more curated security bots in the coming months, so stay tuned and come check this page frequently for new updates!</p> Bot Name Bot Details/Template Link Bot Description Anomalous Token Transfers Detection Machine Learning Bot Bot Details Alerts on anomalous transactions with erc2 token transfers. Anomalous Transaction Volume Bot Details Alerts on anomalous transaction volume (both successful and failed). Attack Detector Feed (aka Alert Combiner) Bot Details Combines past alerts under a common address to emit a high precision alert around protocol attacks. Chainalysis Sanctioned Addresses Bot Details Alerts when a Chainalysis sanctioned account interacts with the address monitored. Exploiter Addresses Bot Details Alerts when known exploiter address interacts with the address monitored. FlashBots Detector Bot Details Alerts when a transaction is routed through FlashBots framework bypassing the mempool. Flash Loan Detector Bot Details Alerts when a flash loan results in large profits indicative of an attack Ice Phishing Detection Bot Bot Details Alerts when ice phishing (social engineer users into token approvals) for a token contract monitored. Large Balance Decreases Template available on Bot Wizard \ud83e\uddd9 Identifies when the balance of an account decreases significantly. Note, this template has been deployed for the following bridges: Polygon, Avalanche, Arbitrum, Near/Aurora, Optimism, Harmony, xDAI, Boba, Ronin, THORChain and Multychain/Anyswap. Mint/Borrow Value Anomalies Bot Details Alerts when mint/borrow volume is changing in a statistically significant way. Monitor Events Template available on Bot Wizard \ud83e\uddd9 Monitors blockchain transactions for specified events emitted from specified contract addresses. This template can be used to alert events emitted from functions that should only be callable by privileged roles. Monitor Function Calls Template available on Bot Wizard \ud83e\uddd9 This bot monitors blockchain transactions for specific function calls to specific contract addresses. This template can be used to alert on function calls that should only be callable by privileged roles. OpenZeppelin-Gnosis Safe Contract Events Bot Details Alerts on security relevant events of the OZ contract library/ Gnosis Safe contact instances. Price Change Anomalies Bot Details Re-entrancy counter Bot Details Alerts when reentrancy on the contract monitored is detected. Sneak Governance Proposal Template Link Identifies when a governance proposal with only a few EOA voting is about to be approved. Suspicious Contract Creation Bot Details Alerts on contract creation that contained the address monitored. Time Series Analyzer Template Template available on Bot Wizard \ud83e\uddd9 This template turns an underlying noisy alert representing a time series into a statistically meaningful alert when values become abnormal. Token Impersonation Bot Details Alerts when an existing token is being impersonated by a newly created contract. Tornado Cash Funded Account Interaction Bot Details Alerts when a Tornado Cash funded account interacts with the address monitored. Unreasonable Governance Parameters Template Link Identifies when a governance proposal will change the protocol's parameters outside of a reasonable range. Unverified Contract Creation Bot Details Alerts on contract creation that isnt verified on Etherscan. Voting Power Changes Template Link] Identifies when the voting power changes signficantly."},{"location":"governance/","title":"Governance","text":"<p>The decentralized architecture of the Forta Network supports its growing community of node operators, detection bot developers and the ecosystem built on top. The vision of Forta posits that only a community-based platform will be powerful enough to address the rapidly evolving risk landscape on blockchains, where every new smart contract deployed introduces novel risk vectors that could affect thousands of interconnected protocols and millions of users.</p> <p>It is integral that governance over the architecture of the Forta Network is also decentralized, to ensure that Forta persists as an open, permissionless platform available to anyone who wants to use or build on it. Further, the Forta community should be able to influence the evolution of the Network alongside the evolution of Web3.</p> <p>The Forta Foundation is an independent, non-profit organization (the \u201cFoundation\u201d) that holds certain assets (e.g. public and open source IP, Github repos, and FORT tokens) in the Network and will facilitate governance of Forta by its community members. To further decentralize governance over Forta, the Foundation introduced a community governance framework with two primary components:</p> <ol> <li>Forta Proposal Process \u2013 a formal, yet flexible framework designed for the community to self-organize and advance proposals and signal support by FORT token holder voting; and</li> <li>Forta Governance Council \u2013 decision making authority was delegated by the community to an initial council of representatives elected by FORT token holders, always allowing the community to provide input and share sentiment through the Forta Proposal Process.</li> </ol> <p>Forta\u2019s initial community governance is simple by design, shaped by key learnings from the current state of Web3 governance:</p> <ul> <li>Complex governance systems can lead to voter fatigue and voter apathy</li> <li>Radical democracy invites plutocracy and it takes time for tokens to become widely dispersed amongst a network\u2019s users</li> <li>Governance should be flexible enough to meet the unique needs of each community, as such needs emerge</li> <li>The stakeholders of a network like Forta extend outside of token holders and should be represented</li> <li>Proposals to alter the protocol should be public and permissionless and decision makers should be accountable to the community</li> <li>Governance should minimize over time as the protocol hardens</li> </ul> <p>The initial community governance framework should allow anyone to easily participate in shaping the evolution of Forta, allowing the Network to evolve naturally over time. It should also maintain the security and robustness of the Network needed for Forta to further its mission to monitor all transactions and protect all assets in Web3.</p>"},{"location":"governance/#forta-governance-council","title":"Forta Governance Council","text":"<p>The Council\u2019s mission is to steward the continued evolution of the Forta Network by facilitating the collective action of its community. The initial council is a group of early Forta community members and ecosystem experts, elected by FORT token holder vote.</p> <p>The Council reduces the need for individual voters to actively participate in every single governance matter. This saves an individual\u2019s attention for when it really matters, mitigating the risk of community members feeling voter fatigue and apathy. Importantly, any community member can always share sentiment, make proposals, and/or signal support by voting with FORT tokens in the Forta Proposal Process on changes and issues that are important to them. This doesn\u2019t preclude any other forms of community participation, including direct outreach to other members of the community or to the Council directly.</p> <p>The Council Bylaws set out the Council governance authority and responsibilities, which in short allow the Council to:</p> <ul> <li>Support initiatives that contribute to the growth and sustainability of Forta</li> <li>Facilitate the development of features and changes in the Network, or adjacent products and services</li> <li>Enable Forta security programs to ensure the long-term security of the Network and security procedures so Forta can react to potential vulnerabilities</li> <li>Educate the Web3 ecosystem about the importance of decentralized runtime security and advocate for the vision of Forta and the decentralized web</li> <li>Attract and retain node runners, bot developers, core developers and other community members through community-building and marketing initiatives</li> <li>Carry out actions that would otherwise further the Council\u2019s mission</li> </ul> <p>The Council generally may exercise its authority under the Bylaws on a majority vote basis, although appointment or removal of other council members requires a two-thirds majority vote. If Council members do not stay aligned with the community and represent their interests well, the community may lobby the Council to remove a council member, through an FPP proposal or directly.</p> <p>The Council also holds admin signing privileges on the Forta multi-signature wallets on a majority M-of-N basis, as well as authority over any Foundation custodial accounts.</p> <p>The Council should help reduce the real problems that would be created by a more complex governance system introduced at the outset that requires FORT token holder voting on every single issue. An initial governance council should reduce the attention-taxing process of FORT holders needing to keep up with an ever-changing system, which provides them more time and attention that can be used to provide value in the Forta Network, furthering its mission to monitor all transactions and protect all assets in Web3.</p>"},{"location":"governance/#current-forta-governance-council","title":"Current Forta Governance Council","text":"<p>The current Forta Governance Council consists of the following members. They were elected by FP-1 on June 5th 2022.</p> <ol> <li>Demian Brener - Founder &amp; CEO @ OpenZeppelin, the company that founded and incubated Forta</li> <li>Hart Lambur - Co-Founder @ UMA, proven Web3 protocol and active Forta user</li> <li>Jeremy Sklaroff - GC @ Celestia, seasoned crypto lawyer passionate about decentralized technology</li> <li>Jonathan Alexander - CTO @ OpenZeppelin, the company that founded and incubated Forta</li> <li>Juan Garre - Director @ the Forta Foundation, a serial entrepreneur running operations for the Forta Foundation since its inception</li> <li>Mat Travizano - Founder @ Rewilder, serial entrepreneur now focused on tackling environmental issues with blockchain technology</li> <li>Tomasz Sta\u0144czak - Founder @ Nethermind, one of the earliest members of the Forta community, developing detection bots, contributing to core development, running scan nodes and actively involved in the ecosystem</li> </ol>"},{"location":"governance/#forta-proposal-process","title":"Forta Proposal Process","text":"<p>The goal of the Forta Proposal Process (or FPP) is to create a more formal public framework to empower the growing Forta community to contribute to the evolution of the Forta Network and its ecosystem. The Forta Forum was created as a public space for all things Forta governance, where the community can have considered, long-form discussions, share best practices, and shape ideas for the future of the Network and the underlying protocol. The FPP will live in the Forum, where you can read about the framework in detail.</p> <p>The FPP is simple, but defines a clear path for community members to champion a given idea for the Forta ecosystem. It also provides the Council a way to gauge the viability and community support for a proposal by way of FORT token holder voting on Snapshot. Like other governance processes in the decentralized ecosystem, the FPP process is only a starting point and is expected to evolve over time.</p> <p>The FPP is divided into four distinct phases, but it is not a rigid framework that must be strictly followed in order for a proposal to be implemented. Rather, the FPP is a suggested workflow for community proposals. To contribute to Forta, anyone can rally the community or lobby the Council at any time and in the way they find most effective.</p> <p>Within the FPP, Phase 3 or the \u201cCommunity Vote\u201d is the most consequential phase, because if a proposal successfully passes this phase, then the Council must deliberate and decide on whether or not to implement the respective proposal. In the beginning, successful Community Votes will be persuasive but not strictly binding on the Council. This allows the Council to act as a check and balance on whether a community proposal is in the best interests of Forta, until the community matures and strengthens its governance muscles over time.</p>"},{"location":"governance/#links","title":"Links","text":"<ul> <li>Governance Forum</li> <li>Forta Proposal Process</li> </ul>"},{"location":"governance/#proposals","title":"Proposals","text":"<ul> <li>FP-1 (Governance Forum / Snapshot Voting)</li> <li>FP-2 (Governance Forum / Snapshot Voting)</li> <li>FP-3 (Governance Forum / Snapshot Voting)</li> <li>FP-4 (Governance Forum / Snapshot Voting)</li> <li>FP-5 (Governance Forum / Snapshot Voting)</li> <li>FP-6 (Governance Forum / Snapshot Voting)</li> </ul>"},{"location":"handle-alert/","title":"Consuming bot alerts","text":"<p>With the addition of the new <code>handleAlert</code> handler, bots are now able to subscribe to alerts from the Forta network. This enables increased composability and higher reuse of existing bots when building your own bot.</p> <p>Prior to this change, developers could manually query for alerts using the <code>getAlerts</code> SDK method or directly using the Forta Alerts GraphQL API. With the <code>handleAlert</code> function, Forta makes threat detection more modular by treating bot reuse as a first-class feature. When developing locally, you will need to set the <code>fortaApiKey</code> property in your forta.config.json to consume alerts (and also have a paid plan). This page will cover how to use this powerful new handler function.</p> <p>Apply for subsidy</p> <p>Developers building this type of bots that consume data from other bots can apply for a subsidy to receive free use of the General Plan until their bots earn enough recurring revenue. Please fill this form to submit your application</p>"},{"location":"handle-alert/#specifying-bots-to-subscribe","title":"Specifying bots to subscribe","text":"<p>In order to specify which bot's alerts you want to receive, you need to implement the <code>initialize</code> handler function and return an <code>InitializeResponse</code> object describing the desired alerts:</p> <pre><code>const BOT_ID_1 =\n  \"0x77281ae942ee1fe141d0652e9dad7d001761552f906fb1684b2812603de31049\";\nconst BOT_ID_2 =\n  \"0x55636f5577694c83b84b0687eb77863850c50bd9f6072686c8463a0cbc5566e0\";\n\nconst initialize: Initialize = async () =&gt; {\n  return {\n    alertConfig: {\n      subscriptions: [\n        {\n          botId: BOT_ID_1,\n          alertIds: [\"ALERT-1\", \"ALERT-2\"],\n        },\n        {\n          botId: BOT_ID_2,\n          chainId: 137,\n        },\n      ],\n    },\n  };\n};\n</code></pre> <p>In the above code snippet, we are specifying 2 bots to subscribe to. For the first bot, we are also specifying the <code>alertIds</code> we are interested in. If no <code>alertIds</code> are specified, then all the alerts generated by that bot will be received. For the second bot, we are also specifying the <code>chainId</code> we are interested in (i.e. only alerts generated by the bot on Polygon chain (137) will be received). If no <code>chainId</code> is specified, then all the alerts generated for all chains will be received.</p> <p>Also, remember to export the <code>initialize</code> and <code>handleAlert</code> (described below) handlers:</p> <pre><code>export default {\n  initialize,\n  handleAlert,\n};\n</code></pre>"},{"location":"handle-alert/#consuming-alerts","title":"Consuming alerts","text":"<p>All subscribed alerts will be received as <code>AlertEvent</code> objects passed into the <code>handleAlert</code> function:</p> <pre><code>const handleAlert: HandleAlert = async (alertEvent: AlertEvent) =&gt; {\n  const findings: Finding[] = [];\n\n  if (alertEvent.botId === BOT_ID_1) {\n    // do something\n  } else if (alertEvent.botId === BOT_ID_2) {\n    // do something else\n  }\n  return findings;\n};\n</code></pre> <p>Upon receiving the alert, your bot can do further processing to detect scenarios you are interested in.</p>"},{"location":"handle-alert/#testing-alerts","title":"Testing alerts","text":"<p>New CLI commands were also added to support development of bots using <code>handleAlert</code>. You can test your bot against a specific alert using the <code>forta-agent run --alert</code> command (or <code>npm run alert</code>) by providing the alert hash e.g. <code>npm run alert 0xabc123</code>. You can provide a comma-delimited list to run multiple alerts.</p> <p>Additionally, you may want to run a sequence of transactions/blocks/alerts to test your bot which can be done using the <code>forta-agent run --sequence</code> command (or <code>npm run sequence</code>). This allows for testing more complex scenarios that involve multiple handlers. Syntax is important here to distinguish between transactions/blocks/alerts i.e.</p> <ul> <li>alerts are specified by their hash (<code>0xabc123</code>)</li> <li>blocks are specified by their block number (<code>1234</code>)</li> <li>transactions are specified by their hash prefixed with \"tx\" (<code>tx0xdef567</code>)</li> </ul> <p>An example sequence run could then be <code>npm run sequence 0xabc123,1234,tx0xdef567</code> which would first run the alert, followed by the block, followed by the transaction.</p>"},{"location":"hardhat/","title":"Integrating with Hardhat","text":"<p>Integrating Forta in your existing Hardhat project is easier than ever with the Forta Hardhat plugin. You can now keep your security/operational monitoring logic right next to the smart contracts they will be monitoring. The plugin provides convenient access to the Forta bot development tools to manage the bot lifecycle using Hardhat tasks.</p> <p>This plugin uses the <code>forta-agent</code> package to programmatically invoke commands. For a more comprehensive walkthrough of bot development, we recommend going through the build your first detection bot guide as well.</p>"},{"location":"hardhat/#installation","title":"Installation","text":"<p>You can install the Forta Hardhat plugin with the following command:</p> <pre><code>npm install -D hardhat-forta\n</code></pre> <p>Remember to import the plugin in your hardhat.config.js with the line:</p> <pre><code>require(\"hardhat-forta\");\n</code></pre> <p>Or if you are using Typescript, then update your hardhat.config.ts instead:</p> <pre><code>import \"hardhat-forta\";\n</code></pre> <p>To verify the installation, run <code>npx hardhat</code> to see the available tasks. You should see the following tasks:</p> <ul> <li><code>forta:init</code> - initialize a sample bot project</li> <li><code>forta:init:template</code> - initialize a bot project from existing templates</li> <li><code>forta:run</code> - run a bot project with blockchain data</li> <li><code>forta:test</code> - execute unit tests for a bot project</li> <li><code>forta:publish</code> - publish a bot to the Forta network</li> <li><code>forta:push</code> - build a bot Docker image and push it to the repository</li> <li><code>forta:disable</code> - disable a bot on the Forta network</li> <li><code>forta:enable</code> - enable a bot on the Forta network</li> <li><code>forta:keyfile</code> - print out keyfile information</li> </ul>"},{"location":"hardhat/#getting-started","title":"Getting started","text":"<p>You can initialize a sample project using the <code>forta:init</code> task, but to create something more useful you can use the <code>forta:init:template</code> task:</p> <pre><code>npx hardhat forta:init:template\n</code></pre> <p>This will prompt you with a list of templates (i.e. low-code bots) to choose from. Some examples include monitoring whether an account's ETH balance has fallen below a threshold, or if an address that recently interacted with Tornado Cash is now interacting with your contracts.</p> <p>You can select one or more templates from the list. They will be unpacked into a folder called <code>agents</code> in your Hardhat project. Each template comes with a SETUP.md file that you should use to configure the bot's behaviour. All you need to do is modify a single JSON config file.</p> <p>If this is your first time initializing a Forta bot project on your machine, a keyfile and a forta.config.json file will be generated for you. You will be prompted to enter a password for the keyfile (to be used later for bot deployment).</p>"},{"location":"hardhat/#testing-your-bot","title":"Testing your bot","text":"<p>You can now run the bot against real blockchain data using the command:</p> <pre><code>npx hardhat forta:run\n</code></pre> <p>If you have multiple bots, you will be prompted to select which one to run. By default, the bot will point to Ethereum mainnet using the public Cloudflare RPC endpoint (you can change this by setting the <code>jsonRpcUrl</code> value in the forta.config.json file located at ~/.forta). Once running, you should see output printed to the console showing the bot scanning blocks and transactions. Awesome! You can also use this command to run the bot against specific blocks and transactions using commandline args.</p> <p>There is also a command to run unit tests of the bot project:</p> <pre><code>npx hardhat forta:test\n</code></pre> <p>Again, you may be prompted to select a specific bot. This command will run any unit tests present in the bot folder.</p> <p>To learn more about testing bots, check out this section.</p>"},{"location":"hardhat/#deploying-your-bot","title":"Deploying your bot","text":"<p>Once you are happy with the bot behaviour, you can deploy this bot to the production Forta network using the command:</p> <pre><code>npx hardhat forta:publish\n</code></pre> <p>You may be prompted to select a specific bot if you have multiple. This command builds a Docker image for the bot and pushes it to a public repository. The image will then be registered in the Bot Registry smart contract. This step requires having MATIC tokens on Polygon mainnet (see here on how to acquire MATIC tokens).</p> <p>Another way to deploy your bot is using the Forta App. To learn more about deploying bots (including how to enable logging), check out this section.</p>"},{"location":"hardhat/#subscribing-to-alerts","title":"Subscribing to alerts","text":"<p>After your bot is deployed, you can view the alerts it generates using Forta App. You can search by your bot's ID or a contract address.</p> <p>Alternatively, you can query for alerts programmatically using the Forta API.</p> <p>To learn more about subscribing to alerts, check out this section.</p>"},{"location":"hardhat/#maintaining-your-bot","title":"Maintaining your bot","text":"<p>You may need to update your bot code at some point in the future, or even disable it. This can all be done using the provided Hardhat tasks as well e.g <code>npx hardhat forta:disable</code>.</p> <p>To learn more about maintaining your bot, check out this section.</p>"},{"location":"help/","title":"Getting help","text":"<p>For any questions or feedback you may have, please go to the Forta Discord server.</p>"},{"location":"how-forta-works/","title":"How Forta works","text":"<p>The Forta Network has two main components \u2013 detection bots and scan nodes. Detection bots are pieces of logic (scripts) that look for certain transaction characteristics or state changes (e.g. anomaly detection) on smart contracts across any supported chain. Nodes run detection bots against each block of transactions. When the bots detect a specific condition or event, the network emits an alert which is stored on IPFS. Forta will also maintain an automated public registry of all alerts, and anyone interested in the security of a contract can consume relevant alerts via the Forta App or API.</p> <p>There is value in the negative signal too \u2013 knowing that detection bots are running 24/7 and not triggering alerts. Forta will maintain an automated record of the detection bots run by each node, for each block.</p>"},{"location":"how-forta-works/#roles-in-the-network","title":"Roles in the network","text":""},{"location":"how-forta-works/#subscribers-to-alerts","title":"Subscribers to alerts","text":"<p>Protocols, DAOs, investors and individuals can use Forta to monitor transaction activity and receive alerts on security, financial, operational and governance related events on Layer 1s, Layer 2s and sidechains.</p> <p>You can subscribe to the Forta data feeds through a variety of applications, including the Forta App, OpenZeppelin Defender, or directly by using the public Forta API.</p>"},{"location":"how-forta-works/#notification-channels","title":"Notification channels","text":"<p>By default, detection bot alerts are sent from Scan Nodes to a Forta maintained ElasticSearch database and then displayed in the Forta App dashboard. If the detection bot is specified as private, the alerts will not appear in the Forta App dashboard, but they will still be accessible through the Forta Public GraphQL API via queries specifying the detection bot ID. For accessing alerts, Forta detection bots have a few built-in options and a number of extended options:</p> <ol> <li>Subscriptions through the Forta App - Currently email address and/or a Slack webhook, but you can request that other options be added by the Forta Foundation.</li> <li>OpenZeppelin Defender Forta Sentinels - Monitors the Forta Public API for new alerts and delivers those alerts to Defender Autotasks and/or Defender Notifications (email, Discord, Slack, Datadog, Telegram, other webhooks).</li> <li>Custom solution - Manually polling the Forta Public API on a local or cloud hosted machine.</li> <li>Pushing data directly from the Forta detection bot to an External API Endpoint - As in the case of the data sources, there is no mechanism for keeping an API key secret. This is ill-advised.</li> </ol>"},{"location":"how-forta-works/#reacting-to-alerts","title":"Reacting to alerts","text":"<p>Performing on-chain actions from within a Forta detection bot is not advised, given the public nature of the Forta detection bot code and any keys it may use. However, Forta detection bot alerts can be monitored by OpenZeppelin Defender Forta Sentinels, where the Defender account is private (i.e. password protected). When a Forta Sentinel detects a new alert from a specific Forta detection bot, it can execute a Defender Autotask to initiate on-chain transactions to call specific contract methods, such as <code>pause()</code>. Defender Autotasks are JavaScript scripts that may perform similar operations that Forta detection bots can, including interacting with external APIs to retrieve or post data.</p>"},{"location":"how-forta-works/#private-monitoring","title":"Private monitoring","text":"<p>There are multiple options for users who prefer private monitoring. Forta bots are not required to publish their source code, and the bot code in the deployed container can be obfuscated in a variety of ways, as described in the Forta docs. Alert findings output from bots can be coded or encrypted. For users who prefer to deploy bots to a private environment without any public exposure, or who simply want redundancy for their bots on the public network, Forta also can support these users running private nodes, which remain completely independent of the public Forta network and do not participate in public detection bot assignment or public broadcast of detection bot findings.</p>"},{"location":"how-forta-works/#detection-bot-developers","title":"Detection bot developers","text":"<p>The vehicles for monitoring smart contracts on Forta are called detection bots \u2013 virtual security cameras that broadcast a public feed. Any developer can write and publish a detection bot on the Forta network, and anyone can subscribe to a bot and receive its alerts. The more detection bots running on Forta, the safer Web3 becomes.</p> <p>You can develop and deploy your own detection bots on Forta using the SDK. There are many templates and examples you can work from. There are also a growing number of development teams who you can hire to develop Forta bots for your project (visit the Bot Development Marketplace or contact the Forta Foundation at info@forta.org for more information).</p> <p>If you are an independent dev that wants to develop detection bots, you can visit Forta\u2019s Bot Development Marketplace to discover RFPs, apply for Grants or participate in Forta Development Contests, which are announced in the Forta Discord.</p>"},{"location":"how-forta-works/#scan-node-operators","title":"Scan node operators","text":"<p>Scan node operators run the detection bots that Forta\u2019s work assigner directs to them, against each block of transactions. When the bots detect a specific condition or event, the network emits an alert which is stored on IPFS. If you want to become a node operator, please check out the following link.</p>"},{"location":"how-forta-works/#security","title":"Security","text":"<p>Staking will be required for scan nodes to be discoverable in the network and emit alerts, and Forta detection bots may be staked on to signal quality.</p> <p>Bots are executed in individual containers and are not able to affect scan nodes or other bots. Detection bots are further restricted in a variety of ways by scan nodes during execution, and bot output can be validated by users and community members, and malicious, redundant, or inaccurate detection bots are slashed and disabled.</p> <p>Scan nodes must produce proof of scan for every block, which provides the ability for community monitoring. Malicious or inaccurate scan nodes can be slashed and disabled.</p> <p>The Forta smart contracts, node software, and other components of the network receive regular security reviews and the reports will be made public.</p>"},{"location":"how-forta-works/#how-does-forta-ensure-reliable-monitoring","title":"How does Forta ensure reliable monitoring?","text":"<p>Reliability on Forta is solved through detection bot redundancy and the monitoring and enforcement of scan node service levels by the community. On the public network, Forta detection bots are assigned to multiple scan nodes with periodic re-assignment. Scan nodes are required to provide a stake and must produce a proof of scan for every block. Scan nodes are monitored for reliability and are slashed for failure to meet the community-established service levels.</p>"},{"location":"how-forta-works/#how-are-forta-alerts-and-findings-validated","title":"How are Forta alerts and findings validated?","text":"<p>Forta scan nodes gather findings from detection bots for each block and then store a proof of scan on IPFS and broadcast the finding details to the Forta analyzer node. Users can obtain detailed information from the Forta analyzer node via the public API, which can be validated against the proof of scan data on IPFS. The analyzer node performs data indexing and may provide additional analysis.</p>"},{"location":"how-forta-works/#fees","title":"Fees","text":"<p>At the moment, no fees are required for subscribing to receive Forta alerts or for the execution of bots, although Forta encourages projects to fund experienced developers to create quality Forta detection bots for their specific use cases.</p>"},{"location":"how-to-pay-for-forta/","title":"How to pay for forta","text":"<p>Fees Tutorial for Users</p> <p>Users can now purchase new plans on the Forta App.</p> <p>1-  Discover all the premium plans available on Forta on the Forta &lt;App Homepage&gt;, you can also explore what is included in the General Plan on the &lt;Forta App&gt;.</p> <p></p> <p>2- Click on any of the premium plans cards to learn more about that specific premium plan (from the bot\u2019s performance to the number of subscribers it has).</p> <p></p> <p>3- Whether it\u2019s on the homepage or on the specific bot\u2019s page, you can click on the \u201cBuy\u201d button to initiate the payment flow from that specific plan. </p> <p>4- Log in to your account connecting your wallet to access to your \u201cMy Account\u201d section (or sign up if it is the first time you are logging in).</p> <p>5- You will be redirected to Forta\u2019s Unlock checkout page to complete the transaction</p> <p></p> <p>6- Please, confirm that the wallet that will receive the plan is correct or select a different one. Although optional, we strongly suggest you share an email so that any updates on the Plan you are purchasing can be shared with you!     1. It is also important to complete the company you are part of (or you represent) to better understand how you will be using Forta. Please, fill the company field if possible!</p> <p></p> <p>7- Check that the plan\u2019s price is correct and select \u201cPay via cryptocurrency\u201d.</p> <p></p> <p>8- Click \u201cPay using crypto\u201d</p> <p></p> <p>9- Next, a wallet popup will appear to approve the plan\u2019s USDC or FORT payment     a. Any purchased plan will auto-renew as long as you have enough approved funds in your wallet.     b. If there are not enough approved funds, the plan will not auto-renew.     c. Select the desired amount you want to approve (calculate additional funds required for future subscriptions) and click \u201cNext\u201d.</p> <p></p> <p>10-  Review the information and click \u201cApprove\u201d</p> <p></p> <p>11- Once the funds are approved, you will get a new wallet notification to confirm the payment. Review and select \u201cConfirm\u201d</p> <p></p> <p>12-  Once the transaction is confirmed you will see the following confirmation and you can click \u201cReturn to site\u201d to go back to the Forta App.</p> <p></p> <p>13-  After a few minutes you will see the purchased plan populated under the \u201caccount\u201d tab in the Forta App.</p> <p></p>"},{"location":"intro-to-bot-dev/","title":"Introduction to Bot Development","text":"<p>Introduction</p> <p>In this article you will gain a high-level understanding of Forta detection bot development including myths, development workflows, dApps and SDKs that will lay out a clear path to develop on Forta. This article is intended for developers who are new to Forta and assumes you have some general knowledge about blockchains, smart contracts and tokens. Let\u2019s jump in!</p> <p>Demystifying Forta development</p> <p>The most important thing for new Forta developers to understand is that it is not a requirement to have experience with blockchain development to get started building on Forta. In fact, your web2 development experience transfers directly to detection bot development. In Forta, detection bots are programs running on the Forta Network that scan the blockchain for events of interest and alerts users about them e.g. large token transfers or declining account balances. While detection bots can be written in any language, Forta provides convenient SDKs in Javascript, Typescript and Python for you to get started easily. Detection bots are the heart of the Forta Network as they alert users of any suspicious or anomalous activity. There are currently many bots deployed for users to interact and integrate with.</p> <p>Forta development workflows</p> <p>The primary development workflow for building detection bots involves the forta-agent CLI (command line interface) tool. Using the CLI, you can setup a detection bot project within seconds. As a general overview of the workflow, it starts from initialization, to development and testing, then finally deployment and maintenance.</p> <p>As mentioned earlier, Forta provides easy to use SDKs for detection bot development in Javascript/Typescript and Python. These allow you to focus on your bot\u2019s detection logic while taking care of the rest of the details. Once your bot is ready to deploy, you simply use the CLI to publish it to the Forta Network.</p> <p>A second development workflow involves the use of the Forta Hardhat plugin to create detection bots for your existing smart contract project. Hardhat is a smart contract development framework with a powerful plugin ecosystem. Using the Forta plugin, you can initialize detection bots right into your project. Also, you can choose from a set of low-code templates to setup detection bots for your project quickly.</p> <p>To deploy your bot to the Forta Network you can use the CLI or the Forta App, which provides a convenient UI to deploy and manage your detection bots. Deploying a bot involves making a transaction to the Bot Registry contract on the Polygon blockchain. This requires having MATIC tokens in order to pay the small transaction fee (in the order of a few cents). Developers just need to ensure they have enough MATIC tokens, and the CLI or Forta App will take care of executing the transaction. Once a detection bot is deployed to the Forta Network, users can subscribe to the alerts generated by the bot or consume them through the Forta API.</p> <p>Great! How do I begin?</p> <p>Now that you are ready to dive into bot development, the best place to start is the Quickstart guide. If you want to browse examples, check out the repo. Good luck and we can\u2019t wait to see what you develop on Forta!</p>"},{"location":"introduction-to-subscription-tiers/","title":"Introduction to Subscription Tiers","text":"<p>The Forta Network\u2019s intelligence is generated by hundreds of bots maintained by developers around the globe. With the implementation of fees and developer rewards, developers can earn subscription revenue from their bots. 100% of network subscription revenue flows back to the bot developers.</p> <p>Subscription to the Forta Network is currently available in 2 options; the General Plan and the Premium Plan. Currently, the General Plan costs 250 FORT per month and will provide subscribers with access to all bots except those designated as Premium Feeds, which are individually priced. Users can purchase a subscription by connecting their wallet to the Forta App and the transaction will be facilitated by the Unlock Protocol.</p>"},{"location":"introduction-to-subscription-tiers/#general-plan","title":"General Plan","text":"<p>The General Plan provides users with the ability to access 99%+ of the bots available on the Network, you can browse the available bots here. Developers interested in building their own detection bot and start earning rewards can check out the developer page here. </p>"},{"location":"introduction-to-subscription-tiers/#premium-feeds","title":"Premium Feeds","text":"<p>Premium Feeds provide users with the ability to access specific feeds that must meet certain requirements as outlined in FP-6. In order for a feed to be included as a Premium Feed, they must undergo approval by the Forta Governance Council or request a community Snapshot vote. More information on that can be found here. Premium Feeds are individually priced by their developers in either USDC or FORT. </p> <p>The currently available Premium Feeds are: </p> <p>Scam Detector: This feed is maintained by the Forta Foundation, in collaboration with the Forta community, including Blocksec and Nethermind. </p> <p>Spam Detector: This feed is built and maintained by Artem Kovalchuk, a Forta community developer.</p> <p>Rull Pull Detector: This feed is built and maintained by Solidus Labs. </p> <p>Attack Detector: This feed is maintained by the Forta Foundation, in collaboration with the Forta community, including Blocksec and Nethermind. </p> <p>Sybil Defender: This feed is maintained by Fwrd Labs, a community team.</p>"},{"location":"jwt-auth/","title":"JWT authentication for bots","text":"<p>There may be cases where you need to call a private API, perhaps to save some state or load some secret. The SDK provides the following methods for generating a JWT token which enables bots to make authorized requests to external APIs:</p> <ul> <li><code>fetchJwt(claims, expiresAt)</code> See method details javascript/python</li> <li><code>decodeJwt(token)</code> See method details javascript/python</li> <li><code>verifyJwt(token)</code> See method details javascript/python</li> </ul> <p>It is up to the external API to verify the returned JWT. See an example here.</p>"},{"location":"jwt-auth/#generate-a-token","title":"Generate a token","text":"<p>You can generate a JWT token using the <code>fetchJwt</code> method which will contain the standard JWT fields, as well as an additional field called <code>bot-id</code> which will be the bot ID of your detection bot. The returned JWT is signed by the scan node that is running the bot (the <code>sub</code> field contains the scan node address). Here is an example of a detection bot generating a JWT during its initialization and decoding it:</p> Typescript<pre><code>import { fetchJwt, decodeJwt } from 'forta-agent'\n\nconst initialize: Initialize = async () =&gt; {\n  const token = await fetchJwt()\n  const decodedTokenData = decodeJwt(token)\n  ...\n}\n</code></pre> Python<pre><code>from forta_agent import fetch_jwt, decode_jwt\n\ndef initialize(block_event):\n    token = fetch_jwt({})\n    decoded_token_data = decode_jwt(token)\n    ...\n</code></pre> <p>In this case <code>token</code> would be a JWT and <code>decodedTokenData</code> will look something like this:</p> <pre><code>{\n  \"bot-id\": \"0x13k387b37769ce24236c403e76fc30f01fa774176e1416c861yfe6c07dfef71f\",\n  \"exp\": 1660119443,\n  \"iat\": 1660119413,\n  \"jti\": \"qkd5cfad-1884-11ed-a5c9-02420a639308\",\n  \"nbf\": 1660119383,\n  \"sub\": \"0x556f8BE42f76c01F960f32CB1936D2e0e0Eb3F4D\"\n}\n</code></pre> <p>Additional claims can also be encoded in the JWT using the <code>claims</code> parameter. You can also specify when the token should expire as the second parameter:</p> Typescript<pre><code>const initialize: Initialize = async () =&gt; {\n  const token = await fetchJwt({key: \"value\"}, new Date(Date.now() + 5000 /*5 seconds*/))\n  const decodedTokenData = decodeJwt(token)\n  ...\n}\n</code></pre> Python<pre><code>def initialize():\n    token = fetch_jwt({'key': 'value'})\n    decoded_token_data = decode_jwt(token)\n    ...\n</code></pre> <p>A useful tool for manually decoding tokens is this web app provided by Auth0.</p>"},{"location":"jwt-auth/#verify-the-token","title":"Verify the token","text":"<p>The JWT token will need to be verified by the receiving server/API. The SDK provides a convenient method called <code>verifyJwt</code> that will ensure the token is not expired, the signature is valid, and that the bot is currently assigned to the scan node. </p> <p>Here is an example Express API that uses the JWT for authentication. The server has a GET endpoint that returns data from some database:</p> <pre><code>import express, { Request, Response } from \"express\";\nimport { verifyJwt } from \"forta-agent\";\n\nconst app = express();\nconst router = express.Router();\n\nrouter.get('/example-endpoint', async (request: Request, response: Response) =&gt; {\n    // Assuming the JWT token is passed in the \"x-access-token\" header\n    const token = request.headers[\"x-access-token\"];\n\n    const isValidJwt: boolean = await verifyJwt(token);\n\n    // If you add additional claims you can verify those as well\n    if (isValidJwt) {\n      // Fetch data from database and return it in response\n    } else {\n      // return 401 error for invalid JWT\n    }\n})\n\napp.use(\"/\", router)\n\napp.listen(8080, () =&gt; {\n  console.log(`Server starting`)\n})\n</code></pre> <p>Your bot could call this endpoint like the following:</p> <pre><code>let token: string\n\nconst initialize: Initialize = async () =&gt; {\n  token = await fetchJwt({key: \"value\"}, new Date(Date.now() + 5000 /* 5 seconds */))\n}\n\nconst handleBlock: HandleBlock = async (blockEvent: BlockEvent) =&gt; {\n  const response = await axios.get('https://yourapi.com/example-endpoint', {\n    headers: {\n      'x-access-token': token\n    }}\n  )\n  ... // Do other stuff\n}\n</code></pre>"},{"location":"labels/","title":"Adding labels to findings","text":"<p>Labels provide a way to add more contextual data to findings generated by Forta bots. This information can be used to answer questions like \"which addresses have been involved in flashloan attacks?\" or \"which blocks contain exploits?\". The Forta bot SDK provides an easy way to specify labels which this page will describe.</p>"},{"location":"labels/#adding-labels","title":"Adding labels","text":"<p>Bots return <code>Finding</code> objects from their handler functions, which now include a <code>labels</code> field to specify a list of labels to add. Here is an example of adding labels:</p> <pre><code>Finding.from({\n  name: \"High Tether Transfer\",\n  description: \"High amount of USDT transferred\",\n  alertId: \"FORTA-1\",\n  severity: FindingSeverity.High,\n  type: FindingType.Suspicious,\n  labels: [\n    {\n      entityType: EntityType.Address,\n      entity: \"0x062dB680e5DCA653248432fC1B4F788E41c83234\",\n      label: \"attacker\",\n      confidence: 0.9,\n    },\n    {\n      entityType: EntityType.Transaction,\n      entity:\n        \"0xfb141d179b40d895ba227c26860d7f49744fe50bdf89a6e6e21978c09c7ac05f\",\n      label: \"flashloan-attack\",\n      confidence: 0.7,\n      metadata: {\n        exploitedProtocol: \"someDAO\"\n      }\n    },\n  ],\n});\n</code></pre> <p>The first label in the above code snippet is saying with 90% certainty that the specified address is an attacker. The second label is saying with 70% certainty that the specified transaction is a flashloan attack. You can also optionally add more data using the <code>metadata</code> field.</p> <p>You can add one or more label objects to a Finding. Each label object should specify all 4 required fields: <code>entity</code>, <code>entityType</code>, <code>label</code> and <code>confidence</code>. The <code>label</code> field can be any string you choose to allow flexibility of supporting many different types of labels. The <code>entity</code> is the item being described and is of <code>entityType</code> which supports 5 different types: <code>Address</code>, <code>Transaction</code>, <code>Block</code>, <code>Url</code> and <code>Unknown</code>. The <code>confidence</code> level should be a number between 0 and 1.</p>"},{"location":"labels/#removing-labels","title":"Removing labels","text":"<p>You can also remove labels from entities which works very similarly to adding labels. The only difference is setting the <code>remove</code> field to the boolean true value on the label. For example, if we wanted to now remove the \"flashloan-attack\" label from the transaction that we specified above, we can do this in a subsequent finding like so:</p> <pre><code>Finding.from({\n  name: \"High Tether Transfer\",\n  description: \"High amount of USDT transferred\",\n  alertId: \"FORTA-1\",\n  severity: FindingSeverity.High,\n  type: FindingType.Suspicious,\n  labels: [\n    {\n      entityType: EntityType.Transaction,\n      entity:\n        \"0xfb141d179b40d895ba227c26860d7f49744fe50bdf89a6e6e21978c09c7ac05f\",\n      label: \"flashloan-attack\",\n      confidence: 0.7,\n      remove: true,\n    },\n  ],\n});\n</code></pre> <p>Notice that all values of the label are the same, but we just added <code>remove: true</code>.</p>"},{"location":"labels/#querying-labels","title":"Querying labels","text":"<p>You can query for labels using the Forta GraphQL API. </p>"},{"location":"long-running-tasks/","title":"Long running tasks","text":"<p>Both <code>handleBlock</code> and <code>handleTransaction</code> functions are required to return within a timeout specified by the network (currently 30 seconds). This should be enough time for most bots to complete, but if you need longer for your bot (e.g. you need to execute many network calls) you can still return findings asynchronously.</p> <p>This page covers how to execute long running tasks using a Javascript example bot. The code for this example can be found here.</p>"},{"location":"long-running-tasks/#triggering-an-asynchronous-task","title":"Triggering an asynchronous task","text":"<p>The main concept behind this technique is to fire an asynchronous function inside of the <code>handleBlock</code> handler and cache any generated findings in-memory. Each time <code>handleBlock</code> is called, we check whether our long running task should be triggered and also whether there are any findings in our cache to return:</p> <pre><code>let findingsCache = [];\nlet isTaskRunning = false;\n\nasync function runLongTask(blockNumber) {\n  isTaskRunning = true;\n\n  // long-running code goes here and adds any findings to findingsCache\n\n  isTaskRunning = false;\n}\n\nasync function handleBlock(blockEvent) {\n  // make sure only one task is running at a time\n  if (!isTaskRunning) {\n    runLongTask(blockEvent.blockNumber);\n  }\n\n  let findings = [];\n\n  // check if we have any findings cached\n  if (findingsCache.length &gt; 0) {\n    findings = findingsCache;\n    findingsCache = [];\n  }\n\n  return findings;\n}\n</code></pre> <p>The <code>runLongTask</code> function above is declared as <code>async</code> and is where the long running code would be placed. Note that when it is invoked in <code>handleBlock</code>, we are not <code>await</code>ing it (so that it runs in the background). The <code>isTaskRunning</code> flag also ensures that there is only ever one long running task executing.</p>"},{"location":"long-running-tasks/#other-considerations","title":"Other considerations","text":"<ul> <li>Since the finding may be returned at a later point in time, it will not be associated with the block that triggered it. To get around this, you can store all the information you need from the block inside the <code>metadata</code> of the finding</li> <li>The long running task is being triggered from <code>handleBlock</code> in the example, which should fire on average every 15 seconds for Ethereum mainnet. You may want more regular fixed intervals to trigger your task, in which case you can use the Node.js <code>setInterval</code> function and invoke it from the bot's <code>initialize</code> handler</li> <li>The above example uses a simple flag (i.e. <code>isTaskRunning</code>) to ensure only one task is running, but based on your requirements you may customize this logic further e.g. making sure a minimum amount of time has passed before triggering the next task</li> </ul> <p>Great! You now have a bot that can execute tasks longer than Forta's specified timeout and return findings.</p>"},{"location":"maintaining/","title":"Maintaining your bot","text":""},{"location":"maintaining/#verifying-bot-health","title":"Verifying bot health","text":"<p>When your bot is published and picked up by a scan node, you can view the findings it generates using Forta App. You can filter findings using your bot ID (which looks like a SHA-256 hash e.g. <code>0x855b1556a45637abf05c63407437f6f305b4627c4361fb965a78e5731999c0c7</code>) using the search bar near the top of the page.</p> <p>Also, you can verify that your bot is healthy by visiting the bot status page on Forta App. The URL for this page looks like <code>https://app.forta.network/bot/YOUR_BOT_ID</code>. You can see various information about the bot including how many transactions it processed, the different severities of alerts it produced and how long it took to respond to requests.</p>"},{"location":"maintaining/#viewing-bot-logs","title":"Viewing bot logs","text":"<p>If logging is enabled, bot logs are updated by scan nodes every minute. You can view your bot's logs via Forta App, Forta API, or the CLI. Only logs from the past 30 days are stored.</p> <p>In the Forta App, you can view the latest logs from your bot's health page (i.e. <code>https://app.forta.network/bot/YOUR_BOT_ID</code>). Simply click on the 'Log Data' button near the top of the page.</p> <p>Using the Forta API, you can programmatically fetch the latest logs from <code>https://api.forta.network/logs/agents/YOUR_BOT_ID</code>. To enable JSON format responses, you can specify the <code>Accept: application/json</code> header in your request. By default, the logs API will return the most recent logs but you can query previous logs using the <code>minute</code> query param. By specifying a minute in RFC3339 format (e.g. <code>https://api.forta.network/logs/agents/YOUR_BOT_ID?minute=2023-04-12T07:20:00.00Z</code>), you can view previous logs. Note that not every minute may have logs.</p> <p>You can also use the CLI command <code>npm run logs</code> to see recent logs.</p>"},{"location":"maintaining/#disablingenabling-your-bot","title":"Disabling/enabling your bot","text":"<p>If you will not be using the alerts your bot generates (i.e. you were just testing out Forta, which we encourage), we ask that you please disable the bot. You can use Forta App or the CLI to enable or disable your bot. In Forta App, go to the Detection Bots page (from the menu at the top right) and click on the options menu to the right of your bot. From the options menu, you can choose to disable or enable your bot.</p> <p>You can also use the CLI command <code>npm run disable</code>. Just make sure to set the <code>agentId</code> property in your project folder's forta.config.json before running the command (you should create the forta.config.json if it doesn't exist). You will also need to ensure you have Polygon MATIC tokens in your keyfile address to execute the disable transaction (you can get the keyfile address using <code>npm run keyfile</code>). See this guide on how to acquire Polygon MATIC tokens. Similarly, you can re-enable a disabled bot using <code>npm run enable</code>.</p>"},{"location":"maintaining/#updating-your-bot","title":"Updating your bot","text":"<p>You may want to update the code for your bot from time to time (e.g. if you found a bug, or there is a new scenario you want to detect). You can use Forta App or the CLI to update your bot. In Forta App, go to the Detection Bots page (from the menu at the top right) and click on the options menu to the right of your bot. From the options menu, you can choose to edit your bot.</p> <p>You can also use the CLI command <code>npm run publish</code> to update your bot. If you have already deployed a bot, the CLI will know to update the existing bot. Ensure that the keyfile used for updating is the same one you used for creating the bot. Make sure to set the <code>agentId</code> property in your project folder's forta.config.json before running the command (you should create the forta.config.json if it doesn't exist). You will also need to ensure you have Polygon MATIC tokens in your keyfile address to execute the update transaction (you can get the keyfile address using <code>npm run keyfile</code>). See this guide on how to acquire Polygon MATIC tokens.</p>"},{"location":"maintaining/#viewing-the-state-of-your-bot","title":"Viewing the state of your bot","text":"<p>If you want to inspect the current or historic state of your bot, for example checking the last time your bot was updated, you can use the CLI command <code>npm run info</code>.</p>"},{"location":"matic/","title":"Acquiring Polygon MATIC","text":"<p>As of October 18th 2021, Forta smart contracts (including the Bot Registry) have been moved to Polygon, a blockchain scaling solution that enables faster and cheaper transactions. You will need MATIC tokens in order to pay gas fees on Polygon when deploying your bot. This guide will walk you through converting your ETH (on Ethereum mainnet) to MATIC (on Polygon mainnet). To learn more about Polygon, visit their website.</p> <p>If you already have MATIC tokens on Ethereum mainnet, you can transfer them over to Polygon using the bridge in step 3.</p>"},{"location":"matic/#1-import-your-keyfile-into-metamask","title":"1. Import your keyfile into Metamask","text":"<ol> <li>In Metamask, click the Accounts dropdown and then click on Import Account</li> <li>Select the JSON File option from the Type dropdown</li> <li>Click on Choose File and navigate to your keyfile (in ~/.forta) and select it</li> <li>Enter the password for your keyfile in the Password box</li> <li>Click the Import button</li> </ol> <p>Your keyfile should now be in Metamask. Make sure there is some ETH in this account.</p>"},{"location":"matic/#2-add-polygon-network-to-your-metamask","title":"2. Add Polygon network to your Metamask","text":"<ol> <li>In Metamask, click the Network dropdown and then click on Custom RPC</li> <li>Fill in the following fields:<ul> <li>Network Name: <code>Polygon Mainnet</code></li> <li>RPC URL: <code>https://polygon-rpc.com/</code></li> <li>Chain ID: <code>137</code></li> <li>Currency Symbol: <code>MATIC</code></li> <li>Explorer URL: <code>https://polygonscan.com/</code></li> </ul> </li> <li>Click the Save button</li> </ol> <p>You can now interact with the Polygon network using your Metamask.</p>"},{"location":"matic/#3-move-eth-to-polygon-using-the-bridge","title":"3. Move ETH to Polygon using the bridge","text":"<ol> <li>Navigate to the Polygon bridge</li> <li>Connect your Metamask wallet if needed (you will be prompted to sign a message)</li> <li>Select Ether from the dropdown as the token to transfer</li> <li>Enter how much ETH you want to transfer (for reference, 1 MATIC will allow you to publish ~80 bots)</li> <li>Click the Transfer button, then click Continue on the following dialogs</li> <li>In the Metamask transaction dialog, review the gas fees and click Confirm</li> <li>Wait for the transaction to complete on Ethereum mainnet</li> <li>Verify your account balance on Polygon mainnet using the Polygon block explorer. You should have received WETH as an ERC-20 transfer (may take a few minutes to complete)</li> </ol> <p>You have now transferred ETH from Ethereum mainnet over to Polygon mainnet.</p>"},{"location":"matic/#4-swap-eth-for-matic-using-the-swap-tool","title":"4. Swap ETH for MATIC using the swap tool","text":"<ol> <li>Navigate to the Polygon swap tool</li> <li>Connect your Metamask wallet if needed (you will be prompted to sign a message)</li> <li>Select how much MATIC you want to receive (for reference, 1 MATIC will allow you to publish ~80 bots)</li> <li>Select WETH as the token to swap (will be labelled \"Ether (PoS-WETH)\")</li> <li>Click the Approve button</li> <li>Click the Swap button</li> <li>Wait for the transaction to complete on Polyon mainnet</li> <li>Verify your account balance on Polygon mainnet using the Polygon block explorer. You should have received the specified amount of MATIC</li> </ol> <p>You should now have MATIC tokens on Polygon mainnet in order to pay gas fees! You can now continue deploying your bot.</p>"},{"location":"ml-data-resources/","title":"Datasets and Resources","text":""},{"location":"ml-data-resources/#detection-bots-and-templates-utilizing-ml","title":"Detection Bots and Templates Utilizing ML","text":"<ul> <li>Anomalous Gas Usage Bot</li> <li>Anomalous Token Transfers Detection Machine Learning Bot</li> <li>Smart Price Changes Bot</li> <li>Time Series Analyzer Bot Template</li> <li>Malicious Smart Contract ML Bot</li> <li>Token Impersonation ML Bot</li> <li>Text Message Sentiment Analysis Deep Learning Bot</li> </ul> <p>Did you create an ML bot? Share it with the community on the ML Discord Channel!</p>"},{"location":"ml-data-resources/#sources-for-training-data","title":"Sources for Training Data","text":"<p>Do you see any missing resources the community can use below? Contribute to the docs.</p>"},{"location":"ml-data-resources/#datasets","title":"Datasets","text":"<ul> <li>Forta Datasets on Huggingface - Training datasets for malicious smart contract detection uploaded on HuggingFace.</li> <li>Forta Labelled datasets - Web3 threat related labelled datasets for data analysis and machine learning developments.</li> <li>EtherScamDB - Open-source db that keeps track of ethereum scams and involved addresses.</li> <li>Forta API - Query critical alerts via the Forta API and use them as weak labels.</li> <li>web3rekt.com - Query known blockchain incidents and scams.</li> <li>XBlock - Access to all blockchain datasets used in academic research.</li> </ul>"},{"location":"ml-data-resources/#blockchain-data","title":"Blockchain Data","text":"<ul> <li>BigQuery Public Blockchain Datasets - Available to query using BigQuery on Google Cloud Platform.</li> <li>Ethereum ETL - Tool to convert blockchain data into CSV formats and relational databases.</li> <li>Transaction event and block event is available in Forta Bot Container. You can also collect training data on the fly and train periodically like this Re-entrancy on Uniswap Time Series Bot</li> </ul>"},{"location":"ml-data-resources/#data-science-competitions","title":"Data Science Competitions","text":"<ul> <li>(Completed) Ethereum Phishing Scam Detection Competition</li> </ul>"},{"location":"ml-data-resources/#blog-posts-and-guides","title":"Blog posts and Guides","text":"<ul> <li>Blog: Deep Learning with Forta</li> <li>Blog: How Forta\u2019s Predictive ML Models Detect Attacks Before Exploitation</li> <li>Blog: Leveraging Machine Learning with Forta to Improve Web3 Security</li> <li>Blog: Time Series Analysis with Forta</li> <li>Blog: Predicting Phishing Scams: A Kaggle Competition</li> <li>Guide: Implementing Time Series Analysis</li> <li>Guide: Deploying ML Models in Detection Bots</li> </ul>"},{"location":"ml-data-resources/#ml-best-practices","title":"ML Best Practices","text":"<ul> <li>Secure your machine learning with Semgrep</li> <li>Never a dill moment: Exploiting machine learning pickle files</li> </ul>"},{"location":"ml-data-resources/#join-the-forta-ml-discord","title":"Join the Forta ML Discord","text":"<p>Do you have ideas on how machine learning can be used on the Forta Network? Share your thoughts and ideas on the ML Discord Channel</p>"},{"location":"ml-with-forta/","title":"Why Machine Learning?","text":"<p>Machine learning is an essential tool in a defender\u2019s toolbox. The Forta Network supports a broad range of machine learning approaches, which are manifested in several bots deployed on the network today, which empowers the network to identify similar attacks as well as completely unknown attacks.</p> <p>While Forta\u2019s focus is threat monitoring, these capabilities can also be used more generically for any scenario where machine learning may be valuable as Forta\u2019s network represents a distributed inference engine on on-chain activity.</p> <p>Today, the following machine learning capabilities exist:</p> <ul> <li> <p>Deep Learning   Deep Learning is a machine learning technique that can learn representations from large amounts of data without any feature engineering. It can develop knowledge about a particular domain and use it for a variety of tasks. For example, a deep learning model can go through vast amounts of blockchain transactions and develop knowledge of transaction metadata and patterns. With this knowledge, it can start detecting anomalous or malicious transactions.  </p> <p>Here\u2019s an example of how a deep learning model can learn facial features from profile pictures and use that knowledge to distinguish or recognize individuals in the photos:      Deep Learning has made tremendous strides in the last few years. In the area of natural language processing, ChatGPT has received lots of attention in the last few months. A deep learning bot utilizing a pre-trained natural language model (BERT) classifies sentiment and topics of on-chain text messages. (bot link)</p> </li> <li> <p>Supervised Classification   Supervised classification is a machine learning approach to classify unknown instances based on labeled instances seen during the training phase. An example is a malicious contract classifier, which predicts whether a newly deployed contract is malicious. This approach identifies characteristics associated with malicious and benign contracts and uses those in its prediction. The advantage of supervised classification over simple heuristics is that the classifier is able to utilize many characteristics in its decision making than a bot author could capture in a manually created heuristic. (bot link / blog post link)</p> </li> <li> <p>Anomaly Detection   Supervised classification is great when trying to identify attacks that share characteristics of previously observed attacks. However, when faced with a novel attack, supervised classification fails. This is where anomaly detection comes; the algorithm learns what is considered normal and alerts on deviation of normal.  </p> <p>However, abnormal doesn\u2019t necessarily mean malicious, so these approaches are generally noisy (aka alert on abnormal that is not necessarily malicious). To filter out this noise, anomaly detectors are combined in such a way that they are consistent with attack behavior (e.g. anomaly detectors for each stage of the web3 attack chain trigger).    </p> </li> <li> <p>Time-series Anomaly Detection   Anomaly detection can look at a transaction in isolation and identify whether it is anomalous. However, some anomalies are anomalies over time, such as a rise in error rates. Time-series anomaly detectors are suited for identifying these types of anomalies. Given there may be variance and seasonality contained in the data, the model needs to take those into account for an accurate model. Prophet is a library utilized by several deployed bots to identify such anomalies. (bot link, bot link, blog post link)    </p> </li> <li> <p>Clustering   Lastly, clustering is a method to group similar items together. For instance, for attack detection, one may be interested in grouping related addresses together that belong to the same person. This can be accomplished, for instance, by creating a connected graph to identify connected subcomponents or by a distance metric that takes into account characteristics of the addresses. (bot link)    </p> </li> </ul> <p>Machine learning is not a silver bullet when it comes to threat detection. However, it is an important tool in the defender\u2019s arsenal. Forta supports a broad range of machine learning approaches that identify attacks every single day to ultimately secure web3.</p>"},{"location":"network-overview/","title":"Network Overview","text":"<p>Introduction</p> <p>The Forta Network acts like a giant, shared security camera and alarm system, monitoring public blockchains in real-time for threats, anomalies, security-related events and other noteworthy activity. Put differently, Forta is the \u201creal-time monitoring layer\u201d in the Web3 tech stack. The Network is comprised of two primary components - detection bots and scan nodes. </p> <p>Forta Network Metrics Dashboard </p> <p>Detection Bots</p> <p>Detection bots are the equivalent of tiny cameras, built by developers and published on the network. What each bot monitors for is determined by the logic written by its developer. Bots vary in complexity, with some monitoring for a single condition (ex: a multi-sig transaction above a certain amount threshold), and others monitoring for a combination of different factors (ex: scam activity using a combination of advanced heuristics and machine learning models). When a bot finds what it\u2019s looking for, it emits an alert. </p> <p>To prevent spam and malicious bots from being published and consuming network resources, developers are required to stake at least 100 FORT on each detection bot they publish. Bots without the minimum stake will be inactive. </p> <p>Scan Nodes</p> <p>The other component of the network is scan nodes, and you can think of scan nodes as servers that provide capacity to the Forta Network. Scan nodes are responsible for running detection bots, providing them with blockchain data and publishing any alerts. </p> <p>Anyone can run a scan node as long as they stake the required amount of FORT tokens. Each scan node listens for blocks and transactions from a blockchain. Currently, the Forta Network runs scan nodes for EVM blockchains such as Ethereum, Polygon and BNB Chain (complete list of supported chains here). Each scan node is assigned a set of detection bots to run by the Forta Network. </p> <p>When a new bot is published, it is randomly assigned to one or more scan nodes and begins running shortly thereafter. The scan node collects any alerts reported by the detection bots and publishes them.</p> <p>To hold scan node operators accountable for operating in the best interest of the network, each scan node must be staked with at least 2,500 FORT. </p> <p>Network Intelligence</p> <p>Collectively, the detection bots on the Forta Network are generating hundreds of thousands of alerts and other data points every hour. Users can subscribe to alerts from a specific detection bot using the Forta App. They can also browse and search the latest alerts using the Forta App. Also, more technical users can query for alerts using the Forta API to integrate alert feeds right into their own applications.</p>"},{"location":"nft-starter-kit/","title":"NFT Threat Detection Kit","text":"<p>Frequent Doc Updates</p> <p>Forta will continue to add more curated security bots in the coming months, so stay tuned and come check this page frequently for new updates!</p> Bot Name Bot Details/Template Link Bot Description Anomalous Token Transfers Detection Machine Learning Bot Bot Details Alerts on anomalous transactions with erc2 token transfers. Anomalous Transaction Volume Bot Details Alerts on anomalous transaction volume (both successful and failed). Attack Detector Feed (aka Alert Combiner) Bot Details Combines past alerts under a common address to emit a high precision alert around protocol attacks. Chainalysis Sanctioned Addresses Bot Details Alerts when a Chainalysis sanctioned account interacts with the address monitored. Exploiter Addresses Bot Details Alerts when known exploiter address interacts with the address monitored. Ice Phishing Detection Bot Bot Details Alerts when ice phishing (social engineer users into token approvals) for a token contract monitored. OpenZeppelin-Gnosis Safe Contract Events Bot Details Alerts on security relevant events of the OZ contract library/ Gnosis Safe contact instances. Price Change Anomalies Bot Details Monitor Events Template available on Bot Wizard \ud83e\uddd9 Monitors blockchain transactions for specified events emitted from specified contract addresses. This template can be used to alert events emitted from functions that should only be callable by privileged roles. Monitor Function Calls Template available on Bot Wizard \ud83e\uddd9 This bot monitors blockchain transactions for specific function calls to specific contract addresses. This template can be used to alert on function calls that should only be callable by privileged roles. NFT Sleep Minting Detection Bot Details Alerts when an NFT is created in a way that appears to be minted from another account. NFT Wash Trading Template available on Bot Wizard \ud83e\uddd9 Alerts on evidence of wash trading. Suspicious Contract Creation Bot Details Alerts on contract creation that contained the address monitored. Time Series Analyzer Template Template available on Bot Wizard \ud83e\uddd9 This template turns an underlying noisy alert representing a time series into a statistically meaningful alert when values become abnormal. Token Impersonation Bot Details Alerts when an existing token is being impersonated by a newly created contract. Tornado Cash Funded Account Interaction Bot Details Alerts when a Tornado Cash funded account interacts with the address monitored. Unverified Contract Creation Bot Details Alerts on contract creation that isnt verified on Etherscan."},{"location":"private-alerts/","title":"Private alerts","text":"<p>In certain usecases bot developers may want to keep their generated alerts private. Using encryption, bot developers can publish alerts that are unreadable to anyone but themselves. An alternative to encryption is obscurity i.e. use some sort of error code in the finding, like \"42\", which only the bot developer would understand.</p> <p>In addition to encrypting the alerts, you likely also want to obfuscate the bot logic (as done in the example code). Bot images are stored in a public repository where anyone can inspect the contents of the image as well as the bot logic to see what is being scanned for. Check out the pattern for protecting sensitive data to understand how this is implemented.</p> <p>This page describes how to write a Javascript bot that emits private alerts using encryption. You can find the code for this example here.</p>"},{"location":"private-alerts/#generating-keys","title":"Generating keys","text":"<p>OpenPGP public key encryption will be used in this example, but you can use any public key encryption algorithm you prefer (just make sure you understand the tradeoffs). The first step is to generate the keypair you will use for encryption. This example uses the OpenPGP.js library, but you can use any library you prefer. The project has an npm script to generate public and private keys: <code>npm run keygen</code>. This will run the <code>generate-keys.js</code> file and output a public and private key file in the project folder: public.pem and private.pem, respectively.</p> <p>The public key can be distributed with the bot, so let's copy paste it into agent.js (be careful with formatting as there should be no spaces at the beginning of each line). Alternatively, you can load the public key from a secure server using the pattern described in JWT authentication for bots. The private key should be secured and kept in a secret place i.e. do not commit private.pem into version control. If you view the bot code in agent.js, you will see that the public key is set up inside the <code>initialize</code> handler function:</p> <pre><code>let publicKey;\nconst publicKeyString = `-----BEGIN PGP PUBLIC KEY BLOCK-----\n\nxjMEYaX/KBYJKwYBBAHaRw8BAQdAS373U8tIP2ZjYfzY2tBVzmXgl8UWafEW\n...\nEi3R2xv3QQEA3Luc1EhUZGuSdvjWhg7YZXJVTOCISdTNrdnodw99kQI=\n=YYoH\n-----END PGP PUBLIC KEY BLOCK-----\n`;\n\nasync function initialize() {\n  publicKey = await openpgp.readKey({\n    armoredKey: publicKeyString,\n  });\n}\n</code></pre>"},{"location":"private-alerts/#encrypting-findings","title":"Encrypting findings","text":"<p>In this example, a regular finding is created the way you normally would in <code>handleTransaction</code>, and then passed through the <code>encryptFindings</code> function. This will return a list of new encrypted findings with most attributes set to \"omitted\". The original finding will be encrypted using the public key and then stored in the <code>metadata</code> field of the encrypted finding as a base64 string:</p> <pre><code>async function encryptFindings(findings) {\n  return Promise.all(\n    findings.map(async (finding) =&gt; {\n      // encrypt the original finding\n      const originalFindingString = JSON.stringify(finding);\n      const message = await openpgp.createMessage({\n        text: originalFindingString,\n      });\n      const encryptedOriginalFinding = await openpgp.encrypt({\n        message,\n        encryptionKeys: publicKey,\n      });\n\n      // create a new finding with most fields replaced with the string 'omitted'\n      const omittedString = \"omitted\";\n      const encryptedFinding = Finding.fromObject({\n        name: omittedString,\n        description: omittedString,\n        alertId: omittedString,\n        protocol: omittedString,\n        severity: FindingSeverity.Unknown,\n        type: FindingType.Unknown,\n        metadata: {\n          data: encryptedOriginalFinding.toString(\"base64\"), // nest the original finding into the metadata\n        },\n      });\n\n      return encryptedFinding;\n    })\n  );\n}\n</code></pre> <p>Try and run this bot using <code>npm start</code> and verify that the findings are printed. The <code>data</code> field will look like a gibberish string e.g.</p> <pre><code>\"metadata\": {\n  \"data\": \"-----BEGIN PGP MESSAGE-----\\n\\nwV4DnxOp2TR9DQISAQdAu9EkgSitn74NvrbYS6bCLUt0wzEgSY3ttXBVo/cF\\ntE0w34HroEIRL4CjIrDJnZxaKoQXTIHw5zFqUHKcROwX8g27IDfilxg2i21B\\nq2780NHy0sAJAQQtXuyjo7r+oN/H1Kl/KgB+OzBg1Jd5M0Bjx5brBXOMt30j\\n52KB+4Q68VnqO5tUFc4+Cc35+ZfYzxwpNWQy7JH0q+iHuVNwk8HpU+jmR98q\\nfqEIKTN1IDUM1zbZRsogPBbgjjT/kR5RnQS+Vw66TItV8ciGtSUYSF/UJBN4\\nnskwMYxL/3NZzwlEw+NxplsYAu9W5AJXZiEYfDTJ6OJq9jCGWDWLIi9DsjL+\\n0Nf1qwByGhuLAMdsFkLNIDhOe9vUdNFZs14umrK6\\n=8WDC\\n-----END PGP MESSAGE-----\\n\"\n}\n</code></pre> <p>Great! Now that you have a bot generating encrypted findings, let's go over how to decrypt the data and use it.</p>"},{"location":"private-alerts/#decrypting-findings","title":"Decrypting findings","text":"<p>In order to decrypt the finding, you would make use of the private key in private.pem. In practice, you would subscribe to findings from your particular bot using the Forta App and receive its contents via some webhook. Upon receiving the finding, you can decrypt the data using the private key.</p> <p>For this example's sake, the project has a <code>decrypt.js</code> file to help you decrypt your finding data and verify that it's what you expect. If you open a <code>node</code> console from your project folder, you can decrypt the data string from your finding:</p> <pre><code>$ node\n&gt; const { decrypt } = require(\"./decrypt\")\n&gt; decrypt(\"-----BEGIN PGP MESSAGE-----\\n\\nwV4DnxOp2TR...s14umrK6\\n=8WDC\\n-----END PGP MESSAGE-----\\n\").then(r =&gt; console.log(r))\n</code></pre> <p>The above code should print out the finding that was passed into the <code>encryptFindings</code> function.</p>"},{"location":"private-alerts/#setprivatefindings","title":"setPrivateFindings","text":"<p>As an added layer of security, bots can indicate that they do not want their findings indexed by Forta App. An adversary could potentially look for alerts that use encryption and with enough alerts could infer what condition the bot is looking for. To avoid this, simply invoke <code>setPrivateFindings(true)</code> in the <code>initialize</code> handler:</p> <pre><code>const { setPrivateFindings } = require(\"forta-agent\")\n\nasync function initialize() {\n  ...\n  setPrivateFindings(true)\n}\n</code></pre> <p>This will tell the Forta network not to display the emitted alerts in Forta App, as well as not to associate the alert with any block/transaction. If you would like to reference the block/transaction, you would need to set the data yourself in the finding <code>metadata</code>.</p>"},{"location":"private-alerts/#other-considerations","title":"Other considerations","text":"<ul> <li>Make sure to modify the README.md documentation to not reveal anything about the bot since it will be published in the bot manifest. You can keep a separate file (e.g. README_private.md) for your own internal documentation</li> <li>Be careful when populating the package.json <code>name</code> and <code>description</code> fields as these will get published in the bot manifest. You may not want these to reveal anything about the bot</li> <li>For bots with several files, you can encrypt all findings in the top-level agent.js file. This way you don't need to repeat encryption code across multiple files</li> <li>Do not programmatically read the public key from the public.pem file as this would make your bot vulnerable to an exploit where an attacker can replace the public.pem file with their own public key and decrypt your bot's findings on their own machine</li> <li>Make sure that unit tests are also obfuscated, or better yet, just not included in the final image. This could easily reveal what the bot is doing</li> </ul> <p>Awesome! You now have a bot that encrypts findings which do not appear in Forta App.</p>"},{"location":"python/","title":"Python SDK","text":"<p>The Forta bot Python SDK comes with a set of classes to provide a consistent interface for developers to write their bots. There are also some utility functions available for your convenience to do common operations like searching for an event in the transaction logs. Check out the Python bots in our examples repo to learn more.</p> <p>NOTE: while you can write bots in Python, you would still use the Node.js <code>forta-agent</code> CLI tool to run the bot.</p>"},{"location":"python/#handlers","title":"Handlers","text":"<p>The most relevant functions for bot developers are the handler functions: <code>initialize</code>, <code>handle_block</code>, <code>handle_transaction</code> and <code>handle_alert</code>.</p> <p>Your <code>agent.py</code> file must declare at least one of the <code>handle_block</code>, <code>handle_transaction</code> or <code>handle_alert</code> functions. You can implement one or all of these depending on your use case, but at least one must be provided. These functions take a <code>BlockEvent</code>, <code>TransactionEvent</code> or <code>AlertEvent</code> as their input, respectively, and return an array of zero or more <code>Finding</code> objects.</p> <p>You can also optionally declare an <code>initialize</code> function that will be executed on bot startup. This is useful for fetching some data from the network or parsing some file before your bot begins. If you are using the <code>handle_alert</code> handler, then the <code>initialize</code> function is required to return which bot's alerts you want to subscribe to (see the pattern for consuming bot alerts for more information). If you don't want to subscribe to any bot alerts, don't return anything.</p>"},{"location":"python/#blockevent","title":"BlockEvent","text":"<p>When a block is mined and detected by a Forta scan node, it will generate a <code>BlockEvent</code> containing information such as the block hash and block number. It contains the following fields:</p> <ul> <li><code>type</code> - specifies whether this was a block reorg or a regular block</li> <li><code>network</code> - specifies which network the block was mined on (e.g. mainnet, ropsten, rinkeby, etc)</li> <li><code>block_hash</code> - alias for <code>block.hash</code></li> <li><code>block_number</code> - alias for <code>block.number</code></li> <li><code>block</code> - data object containing the following fields:<ul> <li><code>difficulty</code></li> <li><code>extra_data</code></li> <li><code>gas_limit</code></li> <li><code>gas_used</code></li> <li><code>hash</code></li> <li><code>logs_bloom</code></li> <li><code>miner</code></li> <li><code>mix_hash</code></li> <li><code>nonce</code></li> <li><code>number</code></li> <li><code>parent_hash</code></li> <li><code>receipts_root</code></li> <li><code>sha3_uncles</code></li> <li><code>size</code></li> <li><code>state_root</code></li> <li><code>timestamp</code></li> <li><code>total_difficulty</code></li> <li><code>transactions</code></li> <li><code>transactions_root</code></li> <li><code>uncles</code></li> </ul> </li> </ul>"},{"location":"python/#transactionevent","title":"TransactionEvent","text":"<p>When a transaction is mined and detected by a Forta scan node, it will generate a <code>TransactionEvent</code> containing various information about the transaction. It contains the following fields:</p> <ul> <li><code>type</code> - specifies whether this was from a block reorg or a regular block</li> <li><code>network</code> - specifies which network the transaction was mined on (e.g. mainnet, ropsten, rinkeby, etc)</li> <li><code>hash</code> - alias for <code>transaction.hash</code></li> <li><code>from_</code> - alias for <code>transaction.from_</code></li> <li><code>to</code> - alias for <code>transaction.to</code></li> <li><code>gas_price</code> - alias for <code>transaction.gas_price</code></li> <li><code>timestamp</code> - alias for <code>block.timestamp</code></li> <li><code>block_number</code> - alias for <code>block.number</code></li> <li><code>block_hash</code> - alias for <code>block.hash</code></li> <li><code>addresses</code> - map of addresses involved in the transaction (generated from transaction to/from address, any event log address and trace data address if available)</li> <li><code>block</code> - data object containing the following fields:<ul> <li><code>hash</code></li> <li><code>number</code></li> <li><code>timestamp</code></li> </ul> </li> <li><code>transaction</code> - data object containing the following fields:<ul> <li><code>hash</code></li> <li><code>from_</code></li> <li><code>to</code></li> <li><code>nonce</code></li> <li><code>gas</code></li> <li><code>gas_price</code></li> <li><code>value</code></li> <li><code>data</code></li> <li><code>r</code></li> <li><code>s</code></li> <li><code>v</code></li> </ul> </li> <li><code>logs</code> - list of log objects with following fields:<ul> <li><code>address</code></li> <li><code>topics</code></li> <li><code>data</code></li> <li><code>log_index</code></li> <li><code>block_number</code></li> <li><code>block_hash</code></li> <li><code>transaction_index</code></li> <li><code>transaction_hash</code></li> <li><code>removed</code></li> </ul> </li> <li><code>traces</code> - only with tracing enabled; list of trace objects with the following fields:<ul> <li><code>block_hash</code></li> <li><code>block_number</code></li> <li><code>subtraces</code></li> <li><code>trace_address</code></li> <li><code>transaction_hash</code></li> <li><code>transaction_position</code></li> <li><code>type</code></li> <li><code>error</code></li> <li><code>action</code> - object with the following fields:<ul> <li><code>call_type</code></li> <li><code>to</code></li> <li><code>from_</code></li> <li><code>input</code></li> <li><code>value</code></li> <li><code>init</code></li> <li><code>address</code></li> <li><code>balance</code></li> <li><code>refund_address</code></li> </ul> </li> <li><code>result</code> - object with the following fields:<ul> <li><code>gas_used</code></li> <li><code>address</code></li> <li><code>code</code></li> <li><code>output</code></li> </ul> </li> </ul> </li> </ul>"},{"location":"python/#filter_log","title":"filter_log","text":"<p><code>filter_log</code> is a convenience function on <code>TransactionEvent</code> to filter and decode transaction logs. For example, you can use it to get all of the Transfer logs in a transaction from a particular ERC-20 token:</p> <pre><code>erc20_token_address = '0x123abc'\ntransfer_event_abi = '{\"name\":\"Transfer\",\"type\":\"event\",\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}]}'\ntransfers = transaction_event.filter_log(transfer_event_abi, erc20_token_address)\nprint(f'found {transfers.length} transfer events')\n</code></pre> <p>The underlying library used for decoding event logs is web3.py. The Python SDK uses the web3.py <code>processLog</code> method and returns an array of <code>Event Log</code> objects. To better understand usage, see the Python filtering example bot.</p>"},{"location":"python/#filter_function","title":"filter_function","text":"<p><code>filter_function</code> is a convenience function on <code>TransactionEvent</code> to filter and decode function calls in the transaction or traces. For example, you can use it to get all of the transferFrom function calls on a particular ERC-20 token:</p> <pre><code>erc20_token_address = '0x123abc'\ntransferFrom_function_abi = '{\"name\":\"transferFrom\",\"type\":\"function\",\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\"}'\ntransfers = transaction_event.filter_function(transferFrom_function_abi, erc20_token_address)\nprint(f'found {transfers.length} function calls')\n</code></pre> <p>The underlying library used for decoding function calls is web3.py. The Python SDK uses the web3.py <code>decode_function_input</code> method and returns an array of (<code>ContractFunction</code>, <code>dict</code>) tuples. To better understand usage, see the Python filtering example bot.</p>"},{"location":"python/#alertevent","title":"AlertEvent","text":"<p>When an alert is fired from a Forta bot and is detected by the network, any subscribing bots will receive an <code>AlertEvent</code> containing various information about the alert (see the pattern for consuming bot alerts for more information). It contains the following fields:</p> <ul> <li><code>alert</code> - data object containing an Alert</li> <li><code>alert_id</code> - alias for <code>alert.alert_id</code></li> <li><code>name</code> - alias for <code>alert.name</code></li> <li><code>hash</code> - alias for <code>alert.hash</code></li> <li><code>bot_id</code> - alias for <code>alert.source.bot.id</code></li> <li><code>transaction_hash</code> - alias for <code>alert.source.transaction_hash</code></li> <li><code>block_hash</code> - alias for <code>alert.source.block.hash</code></li> <li><code>block_number</code> - alias for <code>alert.source.block.number</code></li> <li><code>chain_id</code> - alias for <code>alert.chain_id</code></li> <li><code>has_address</code> - alias function for <code>alert.has_address</code></li> </ul>"},{"location":"python/#finding","title":"Finding","text":"<p>If a bot wants to flag a transaction/block/alert because it meets some condition (e.g. flash loan attack), the handler function would return a <code>Finding</code> object. This object would detail the results of the finding and provide metadata such as the severity of the finding. A <code>Finding</code> object accepts the following properties:</p> <ul> <li><code>name</code> - required; human-readable name of the finding e.g. \"High Gas\"</li> <li><code>description</code> - required; brief description e.g. \"High gas used: 1,000,000\"</li> <li><code>alert_id</code> - required; unique string to identify this class of finding, primarily used to group similar findings for the end user</li> <li><code>protocol</code> - required; name of the protocol being reported on e.g. \"aave\", defaults to \"ethereum\" if left blank</li> <li><code>type</code> - required; indicates type of finding:<ul> <li>Exploit</li> <li>Suspicious</li> <li>Degraded</li> <li>Info</li> </ul> </li> <li><code>severity</code> - required; indicates impact level of finding:<ul> <li>Critical - exploitable vulnerabilities, massive impact on users/funds</li> <li>High - exploitable under more specific conditions, significant impact on users/funds</li> <li>Medium - notable unexpected behaviours, moderate to low impact on users/funds</li> <li>Low - minor oversights, negligible impact on users/funds</li> <li>Info - miscellaneous behaviours worth describing</li> </ul> </li> <li><code>metadata</code> - optional; dict (both keys and values as strings) for providing extra information</li> <li><code>labels</code> - optional; array of <code>Label</code> objects to attach to this finding</li> </ul>"},{"location":"python/#alert","title":"Alert","text":"<p>When an <code>Alert</code> is fired by a Forta bot, it can be consumed using an AlertEvent or manually queried using the <code>get_alerts</code> method. <code>Alert</code> objects have the following properties:</p> <ul> <li><code>alert_id</code> -  unique string to identify this class of finding</li> <li><code>chain_id</code> - chain ID where this alert was fired</li> <li><code>addresses</code> -  list of addresses involved in the alert (currently truncated at 50 addresses)</li> <li><code>labels</code> - list of Labels associated to the alert</li> <li><code>contracts</code> -  list of contracts related to the alert</li> <li><code>created_at</code> -  timestamp when the alert was published</li> <li><code>description</code> - text description of the alert</li> <li><code>name</code> - alert name</li> <li><code>protocol</code> - name of the protocol being reported on</li> <li><code>scan_node_count</code> - number of scanners that found the alert</li> <li><code>source</code> - source where the alert was detected<ul> <li><code>transaction_hash</code> - transaction where the alert was detected</li> <li><code>block</code> - block where the alert was detected<ul> <li><code>timestamp</code></li> <li><code>chain_id</code></li> <li><code>hash</code></li> <li><code>number</code></li> </ul> </li> <li><code>bot</code> - bot that triggered the alert<ul> <li><code>id</code></li> <li><code>reference</code></li> <li><code>image</code></li> </ul> </li> <li><code>sourceAlert</code> - alert that triggered this alert<ul> <li><code>hash</code></li> <li><code>bot_id</code></li> <li><code>timestamp</code></li> <li><code>chain_id</code></li> </ul> </li> </ul> </li> <li><code>projects</code> - list of Web3 projects related to the alert<ul> <li><code>contacts</code> - list of contact info</li> <li><code>id</code> - project identifier</li> <li><code>name</code> - user-friendly name of the project</li> <li><code>token</code></li> <li><code>social</code></li> <li><code>website</code> - main website of the project</li> </ul> </li> <li><code>finding_type</code> -  indicates the type of finding:<ul> <li>Exploit</li> <li>Suspicious</li> <li>Degraded</li> <li>Info</li> <li>Unknown</li> </ul> </li> <li><code>severity</code> - indicates impact level of finding:<ul> <li>Critical - exploitable vulnerabilities, massive impact on users/funds</li> <li>High - exploitable under more specific conditions, significant impact on users/funds</li> <li>Medium - notable unexpected behaviours, moderate to low impact on users/funds</li> <li>Low - minor oversights, negligible impact on users/funds</li> <li>Info - miscellaneous behaviours worth describing</li> </ul> </li> <li><code>metadata</code> - key-value map (both keys and values as strings) for providing extra information</li> </ul>"},{"location":"python/#has_address","title":"has_address","text":"<p><code>has_address</code> is a convenience function on <code>Alert</code> meant for checking the existence of an address involved in the alert. The <code>addresses</code> array is truncated for space efficiency, so this method uses a bloom filter to check for existence. It accepts a single string parameter: the address to check</p>"},{"location":"python/#label","title":"Label","text":"<p>Labels can be used to add more contextual data to a <code>Finding</code> e.g. \"is this address an attacker?\". The <code>Label</code> object has the following properties:</p> <ul> <li><code>id</code> - string identifier of this label</li> <li><code>entity_type</code> - enum indicating type of entity:<ul> <li><code>Address</code></li> <li><code>Transaction</code></li> <li><code>Block</code></li> <li><code>Url</code></li> <li><code>Unknown</code></li> </ul> </li> <li><code>entity</code> - string identifier of the entity being labelled e.g. transaction hash</li> <li><code>label</code> - string label to attach to the entity e.g. \"exploit\"</li> <li><code>confidence</code> - confidence level of label between 0 and 1</li> <li><code>metadata</code> - key-value map (both keys and values as strings) for providing extra information</li> <li><code>created_at</code> - string containing the timestamp of label creation</li> <li><code>source</code> - object with information about where this label came from<ul> <li><code>alert_hash</code></li> <li><code>alert_id</code></li> <li><code>id</code></li> <li><code>chain_id</code></li> <li><code>bot</code><ul> <li><code>id</code></li> <li><code>image</code></li> <li><code>image_hash</code></li> <li><code>manifest</code></li> </ul> </li> </ul> </li> </ul>"},{"location":"python/#get_json_rpc_url","title":"get_json_rpc_url","text":"<p>A convenience function called <code>get_json_rpc_url</code> can be used to load a JSON-RPC URL for your bot. When running in production, this function will return a URL injected by the scan node that is running the bot. When running locally in development, this function will return the <code>jsonRpcUrl</code> property specified in your forta.config.json file (or <code>https://cloudflare-eth.com/</code> by default).</p>"},{"location":"python/#get_web3_provider","title":"get_web3_provider","text":"<p><code>get_web3_provider</code> is a convenience function that returns a web3.py Provider which can be used to interact with the blockchain. The value from <code>get_json_rpc_url</code> will be used as the JSON-RPC endpoint to connect to.</p>"},{"location":"python/#get_transaction_receipt","title":"get_transaction_receipt","text":"<p>A convenience function called <code>get_transaction_receipt</code> can be used to fetch the entire receipt of a transaction and returned in a format matching the SDK <code>Receipt</code> interface.</p>"},{"location":"python/#get_alerts","title":"get_alerts","text":"<p>The <code>get_alerts</code> method can be used to fetch alerts based on input <code>AlertQueryOptions</code>. The <code>get_alerts</code> method accepts the following input filter properties:</p> <ul> <li><code>bot_ids</code> required; list of bot ids to fetch alerts for</li> <li><code>addresses</code> -  indicates a list of addresses, alerts returned will have those addresses involved.</li> <li><code>alert_id</code> - filter alerts by alert-id</li> <li><code>chain_id</code> - EIP155 identifier of the chain alerts returned will only be from the specific chain Id Default is 1 = Ethereum Mainnet</li> <li><code>created_since</code> - indicates number of milliseconds, alerts returned will be alerts created since the number of milliseconds indicated ago (note: if not specified, the query will only search the past 24 hours)</li> <li><code>first</code> - indicates max number of results.</li> <li><code>starting_cursor</code> - query results after the specified cursor</li> <li><code>project_id</code> - indicates a project id, alerts returned will only be from that project.</li> <li><code>scan_node_confirmations</code> - filter alerts by number of scan nodes confirming the alert</li> <li><code>severities</code> - filter alerts by severity levels</li> <li><code>transaction_hash</code> - indicates a transaction hash, alerts returned will only be from that transaction</li> <li><code>block_sort_direction</code> - indicates sorting order by block number, 'desc' or 'asc'. The default is 'desc'.</li> <li><code>block_date_range</code> - alerts returned will be between the specified start and end block timestamp dates when the threats were detected</li> <li><code>block_number_range</code> - alerts for the block number range will be returned</li> </ul> <p>The returned alerts are formatted to match the SDK <code>AlertsResponse</code> class, below is an example using this method:</p> <pre><code>from forta_agent import get_alerts\n\nresponse = get_alerts({\n    'bot_ids': [\"0x79af4d8e0ea9bd28ed971f0c54bcfe2e1ba0e6de39c4f3d35726b15843990a51\"],\n})\nhas_next = response.page_info.has_next_page\nalerts = response.alerts\n</code></pre>"},{"location":"python/#send_alerts","title":"send_alerts","text":"<p>The <code>send_alerts</code> method enables submitting alerts via the GraphQL API. See the external bots page for more information.</p>"},{"location":"python/#get_labels","title":"get_labels","text":"<p>The <code>get_labels</code> method can be used to fetch labels based on input <code>LabelQueryOptions</code>. The <code>get_labels</code> method accepts the following input filter properties (at least one of <code>entities</code>, <code>labels</code> or <code>source_ids</code> is required):</p> <ul> <li><code>entities</code> - string array to filter by label entities (e.g. wallet addresses, block/tx hashes)</li> <li><code>labels</code> - string array to filter the label value (e.g. \"attacker\")</li> <li><code>source_ids</code> - string array to filter the label sources (e.g. bot IDs)</li> <li><code>entity_type</code> - string to filter labels by <code>EntityType</code> (see label section for possible types)</li> <li><code>state</code> - boolean, set to <code>true</code> if only the current state is desired</li> <li><code>created_since</code> - integer timestamp in milliseconds, labels returns will be created after this timestamp</li> <li><code>created_before</code> - integer timestamp in milliseconds, labels returned will be created before this timestamp</li> <li><code>first</code> - integer indicating max number of results</li> <li><code>starting_cursor</code> - query results after the specified cursor object</li> </ul> <p>The returned labels are formatted to match the SDK <code>LabelsResponse</code> class, below is an example using this method:</p> <pre><code>from forta_agent import get_labels\n\nresponse = get_labels({\n    'source_ids': [\"0x79af4d8e0ea9bd28ed971f0c54bcfe2e1ba0e6de39c4f3d35726b15843990a51\"],\n})\nhas_next = response.page_info.has_next_page\nlabels = response.labels\n</code></pre>"},{"location":"python/#fetch_jwt","title":"fetch_jwt","text":"<p>Scan nodes allow bots to make authorized requests to external APIs by using the scan node's identity, without letting the scan node modify the requests. You can use the <code>fetch_jwt</code> utility function to generate a jwt token from a scan node.</p> <p>This method will only generate a token if the bot is running on a scan node</p> <p>If running a bot locally or in a stand-alone environment (ie. outside of a scanner node), this method will throw an error. For local testing, you can run a local scan node and run your bot on it.</p> <p>The function signature is <code>fetch_jwt(claims, expiresAt)</code>: - <code>claims</code> [required]:  a dictionary of any data you would like to include in the data portion of the JWT - <code>expiresAt</code>:  an optional <code>datetime</code> that sets when the JWT will expire</p> <p>The returned JWT can be decoded using the <code>decode_jwt</code> method.</p>"},{"location":"python/#verify_jwt","title":"verify_jwt","text":"<p>A utility method intended to be used on an external server for verifying the claims and signature of a JWT generated by a scan node. This method verifies that the JWT was generated and signed by the same scan node the bot is running on. See an example usage of verifying a JWT</p> <ul> <li><code>token</code> - required  a JWT token generated by <code>fetch_jwt</code></li> </ul>"},{"location":"python/#decode_jwt","title":"decode_jwt","text":"<p>A utility method for decoding the header and payload of a JWT returned from a scan node</p> <p>The function signature is <code>decode_jwt(token)</code>:</p> <p>This method will not verify the signature of a JWT</p>"},{"location":"python/#create_block_event","title":"create_block_event","text":"<p>A utility function for writing tests. You can use <code>create_block_event</code> to easily generate a mock <code>BlockEvent</code> object when writing unit tests for your <code>handle_block</code> handler. To better understand usage, see the Python unit test example.</p>"},{"location":"python/#create_transaction_event","title":"create_transaction_event","text":"<p>A utility function for writing tests. You can use <code>create_transaction_event</code> to easily generate a mock <code>TransactionEvent</code> object when writing unit tests for your <code>handle_transaction</code> handler. To better understand usage, see the Python unit test example.</p>"},{"location":"querying-chains/","title":"Querying other chains","text":"<p>Forta currently supports scanning on several chains including Ethereum, Polygon, BNB Chain, Avalanche, Arbitrum, Optimism and Fantom. More chains will inevitably be added in the future, but some bots may need to scan data from chains that are not yet officially supported (could be mainnet or testnet). To achieve this, bots can manually read data from any other chain themselves.</p> <p>This page will describe how to interact with any blockchain using a Javascript example bot. This example builds on the long running task pattern to query the Rinkeby testnet and find transactions with high gas usage. The complete code for this example can be found here.</p>"},{"location":"querying-chains/#setting-up-the-rpc-endpoint","title":"Setting up the RPC endpoint","text":"<p>We start by initializing the current Rinkeby block number using the <code>initialize</code> handler:</p> <pre><code>const RINKEBY_RPC_URL = \"https://rinkeby.infura.io/v3/YOUR_API_KEY\";\nconst rinkebyProvider = new ethers.providers.JsonRpcProvider(RINKEBY_RPC_URL);\nlet currentRinkebyBlockNumber;\n\nasync function initialize() {\n  currentRinkebyBlockNumber = await rinkebyProvider.getBlockNumber();\n}\n</code></pre> <p>Note that the RPC URL is hardcoded in the bot since it will not be passed in by the scan node. When using an API key, you probably also want to use obfuscation as shown in the pattern for protecting sensitive data or load the API key securely using JWT authentication.</p>"},{"location":"querying-chains/#scanning-blocks","title":"Scanning blocks","text":"<p>Now we can manually fetch blocks from Rinkeby and scan over each one to detect whatever condition we are interested in:</p> <pre><code>async function scanRinkebyBlocks() {\n  isScanningRinkeby = true;\n\n  const latestRinkebyBlockNumber = await rinkebyProvider.getBlockNumber();\n  // for each unprocessed block\n  while (currentRinkebyBlockNumber &lt;= latestRinkebyBlockNumber) {\n    // fetch rinkeby block\n    const rinkebyBlock = await rinkebyProvider.getBlock(\n      currentRinkebyBlockNumber\n    );\n    // fetch receipt for each transaction in block\n    for (const tx of rinkebyBlock.transactions) {\n      const receipt = await rinkebyProvider.getTransactionReceipt(tx);\n      // check if gas usage is higher than 1 million\n      if (receipt.gasUsed.gt(\"1000000\")) {\n        findingsCache.push(\n          Finding.fromObject({\n            name: \"High gas used\",\n            description: `Transaction with high gas usage: ${receipt.gasUsed.toString()}`,\n            alertId: \"RINK-1\",\n            severity: FindingSeverity.Info,\n            type: FindingType.Info,\n            metadata: {\n              txHash: tx,\n            },\n          })\n        );\n      }\n    }\n    currentRinkebyBlockNumber++;\n  }\n\n  isScanningRinkeby = false;\n}\n</code></pre> <p>The above code fetches block data given a block number which also includes transaction hashes. We then fetch the receipt for each transaction to get its gas usage. If gas usage is higher than 1 million, we add a finding to the <code>findingsCache</code>. The <code>scanRinkebyBlocks</code> function will be invoked by the <code>handleBlock</code> handler (not shown above), which will return any cached findings.</p>"},{"location":"querying-chains/#other-considerations","title":"Other considerations","text":"<ul> <li>Since the findings returned will be for a different chain than what the scan node is scanning, the block hash associated to the finding will be incorrect. To get around this, you can store all the information you need from the Rinkeby block/transaction inside the <code>metadata</code> of the finding</li> <li>The cost of the RPC endpoint usage (if any) will be covered by you, the bot developer. This is not the case when consuming data passed in from the scan node itself. Also, there may be multiple instances of your bot running across Forta scan nodes. Keep this in mind when estimating the costs of running such a bot</li> <li>The long running task (i.e. <code>scanRinkebyBlocks</code>) is being triggered from <code>handleBlock</code> in the example, which should fire on average every 15 seconds for Ethereum mainnet. You may want more regular fixed intervals to trigger your task based on the speed of the chain you are querying, in which case you can use the Node.js <code>setInterval</code> function and invoke it from the bot's <code>initialize</code> handler</li> <li>The above example uses a simple flag (i.e. <code>isScanningRinkeby</code>) to ensure only one task is running, but based on your requirements you may customize this logic further e.g. making sure a minimum amount of time has passed before triggering the next task</li> <li>A minor drawback of this approach is that the developer tools (i.e. CLI commands) are not usable. For instance, you cannot specify a transaction/block from Rinkeby using <code>npm run tx/block</code>. You would have to do this by manually modifying the code.</li> </ul> <p>Great! You now have a bot that can scan blocks and transactions from any blockchain whether or not it's officially supported by Forta.</p>"},{"location":"quicknode-partnership/","title":"Scan with Quicknode","text":"<p>Disclosure</p> <p>The following documentation was written by the team at QuickNode and does not reflect the views of the Forta Foundation.</p>"},{"location":"quicknode-partnership/#scan-with-quicknode","title":"Scan With QuickNode","text":""},{"location":"quicknode-partnership/#why-use-quicknode","title":"Why Use QuickNode?","text":"<p>QuickNode powers blockchain-enabled internet for the modern world. As the most performant end-to-end Web3 development platform, QuickNode makes it easy to build and scale dApps with globally-balanced blockchain infrastructure, best-in-class elastic APIs, powerful analytics and tools, an abundance of valuable developer resources, and 24/7 customer support. QuickNode uses multiple client implementations and usage-specific node clusters for consistent performance at any scale \u2014 successfully handling billions of blockchain calls daily with 2.5x faster response times than competitors. </p> <p>With QuickNode, blockchain developers can instantly unlock multi-chain scaling with access to 22+ chains and 35+ networks \u2014 including all major testnets. Since 2017, QuickNode has empowered hundreds of thousands of top developers and companies to focus on innovation by accelerating dApp build times and offering enterprise-grade solutions to businesses of every size. As a result, leading Web3 companies like Nansen, Copper, Adobe, Magic Eden, and Dune Analytics trust QuickNode to power their businesses and deliver exceptional results.</p>"},{"location":"quicknode-partnership/#quicknodes-core-api","title":"QuickNode\u2019s Core API","text":"<p>QuickNode's Core API provides seamless interaction with blockchain networks for both reading and writing data \u2014 leverage QuickNode's elastic API for lightning-fast responses and frictionless Web3 development.</p> <p>Quick, powerful, and reliable, our Core API is your launchpad into frictionless web3 development:</p> <p>Speed: QuickNode's blockchain API responses are on average 2.5x faster than competitors.</p> <p>Reliability: With an uptime service-level agreement (SLA), QuickNode ensures that your application is up and running when you need it.</p> <p>Scalability: QuickNode offers unlimited scalability. Whether you have ten users today or billions tomorrow, it scales with your needs, irrespective of the volume.</p> <p>Real-time analytics: Quickly fetch metrics that matter, including method calls over time, response statuses, method response time, and more.</p> <p>Security: QuickNode offers world-class security features, including token-based authentication, referrer whitelisting, domain masking, and more to ensure your endpoints are safe and secure.</p> <p>Archive: QuickNode's Core API allows developers to access all historical states of values in smart contracts as well as all account balances.</p> <p>Trace &amp; Debug: The API provides a feature to request the node to re-execute the desired transaction with varying degrees of data collection.</p> <p>With QuickNode's Core API, the blockchain experience is simplified. It allows you to streamline your development process without the added cost of dealing with bug fixes, uptime, customer complaints, and more. Built for developers, by developers, QuickNode's tools are designed with user-friendliness in mind. Connect to the blockchain in one line of code, and learn the rest from our best-in-class documentation.</p>"},{"location":"quicknode-partnership/#special-offer","title":"Special Offer","text":"<p>Together, QuickNode and Forta are committed to protecting Web3 users and supporting the developers that are building solutions to make blockchain safer for everyone. Thanks to this new partnership, Forta scan node runners can enjoy a discount on QuickNode\u2019s Build Plan.</p> <p>Now that we know how QuickNode helps your Forta nodes be more reliable and performant, let's dive into how to create a new QuickNode account completely for free.</p> <p>On top of the best-in-class infrastructure, QuickNode users will also get access to:</p> <ul> <li>Access to 22+ chains and 35+ networks</li> <li>QuickAlerts</li> <li>Graph API</li> <li>NFT Fetch API</li> <li>Token API</li> <li>One-click add-ons from the QuickNode Marketplace</li> <li>24/7 support</li> </ul> <p>Claim this discount - \u201cForta20\u201d (don\u2019t add the quotes into the coupon section, just Forta20).</p>"},{"location":"quicknode-partnership/#getting-started-with-quicknode","title":"Getting Started with QuickNode","text":"<p>Let\u2019s get started and see how easy and painless it is to create an RPC endpoint in just a few minutes. To build on any of QuickNode\u2019s supported blockchains, you'll need an API endpoint to connect with the network. Let\u2019s follow a few short steps to create our custom endpoint:</p> <p>Go to\u00a0https://QuickNode.com/ and click \u201cCreate account\u201d</p> <p></p> <p>Enter your information and click the button to \u201cCreate a free account\u201d</p> <p></p> <p>Next, specify which type of project you are building. Choose \u201cOther\u201d and enter scan node. </p> <p></p> <p>Once you click \u201cFinish,\u201d you\u2019ll see this screen. You\u2019ll need to check your email inbox to complete the next step.</p> <p></p> <p>Check your email to verify your QuickNode account. Click \u201cVerify Your Account\u201d</p> <p></p> <p>Clicking verify in the above email will take you back to the developer portal. Next, you\u2019ll click \u201cCreate an endpoint.\u201d</p> <p></p> <p>Select the chain you\u2019d like to build on.</p> <p></p> <p>And select the network</p> <p></p> <p>Next, you\u2019ll be prompted to select add-ons from the QuickNode Marketplace to add. There are many free add-ons available to supercharge your dApp \u2014 along with several paid add-ons from industry leaders.</p> <p>This step is optional. You can continue without selecting any add-ons.</p> <p></p> <p>Next, select a plan. Choose the \u201cBuild\u201d plan to apply your discount.</p> <p></p> <p>Finalize your Build plan and enter your coupon code \u201cForta20\u201d here before completing your purchase (don\u2019t add the quotes into the coupon section, just Forta20).</p> <p></p> <p>Select your endpoint.</p> <p></p> <p>From here, you\u2019ll need to grab the RPC URL required to set up your Forta node.</p> <p>You can copy the HTTP Provider or WSS Provider URL to use in your web3 application. On your endpoint's page, you can view Metrics, manage Add-ons, and control Security features such as token authentication, JSON Web Tokens (JWT), referrer whitelisting, and more.</p> <p></p> <p>Now that you have your HTTPS RPC URL, we\u2019ll need to connect QuickNode to the Forta scan node running on your terminal.</p>"},{"location":"quicknode-partnership/#configure-your-quicknode-chain-apis","title":"Configure your QuickNode Chain APIs","text":"<p>If you haven\u2019t already installed Forta on your terminal, make sure to go through the\u00a0quickstart guide\u00a0for kickstarting your Forta scan node.</p> <p>Once your Forta directory has been initialized, you\u2019ll find a file named \u00a0<code>config.yml</code>. We\u2019ll need to configure that file so that our scan node knows how to pull data from the blockchain.</p> <p>Forta detection bots are able to call JSON-RPC APIs using the RPC endpoints and the chain ID configured in the\u00a0<code>config.yml</code>\u00a0file, to do so, we\u2019ll need to initialize the\u00a0<code>scan.jsonRpc.url</code>\u00a0property in the config.yml file, with the QuickNode HTTP RPC URL from your account.</p> <p>Open the config.yml file in your Forta directory, and copy your QuickNode RPC URL in the jsonRpc property:</p> <pre><code>chainId: 1\n\nscan:\n  jsonRpc:\n    url: https://{Your QuickNode RPC URL}\n</code></pre> <p>That\u2019s it! Your Forta node will now scan blockchain transactions at lightning speed using QuickNode\u2019s Core API.</p> <p>Please note that we\u2019ve set the chainId property to one in the above code. This is because we provided guidance to create an Ethereum application, and the Ethereum Mainnet chain ID is one.</p> <p>If you want to scan other chains like Polygon, Arbitrum, or Optimism, please refer to the following section!</p>"},{"location":"quickstart/","title":"Quick start","text":"<p>This guide will explore the basics of creating a Forta detection bot.</p>"},{"location":"quickstart/#prerequisites","title":"Prerequisites","text":"<p>Before you start, please make sure you have the following:</p> <ul> <li>High-level understanding of Forta detection bot development</li> <li>Node.js v12+ (which includes the Node package manager i.e. npm)</li> <li>Python v3.6+ (only if you want to use Python SDK)</li> <li>Docker v20+ (including the buildx plugin)</li> <li>Basic understanding of Ethereum and smart contracts</li> <li>MATIC tokens for deploying your bot (see this guide)</li> </ul>"},{"location":"quickstart/#initializing-a-project","title":"Initializing a project","text":"<p>To initialize a Forta detection bot, you can use the Forta Hardhat plugin, the Forta Detection Bot Wizard or the <code>forta-agent</code> CLI tool:</p> <pre><code>$ mkdir my-new-bot\n$ cd my-new-bot\n$ npx forta-agent@latest init --typescript\n</code></pre> <p>The above snippet creates a new project directory called <code>my-new-bot</code>, and then uses <code>npx</code> (a package runner tool that is part of npm 5.2+) to invoke the <code>init</code> command of the <code>forta-agent</code> CLI tool. By passing the <code>--typescript</code> option, you can initialize a Typescript project (default is Javascript, and <code>--python</code> is also an option).</p> <p>Using @latest version</p> <p>We recommend always initializing projects with <code>@latest</code> version to ensure you have the latest and greatest SDK features. Otherwise, you may end up using an older previously cached version.</p> <p>The <code>init</code> command will initialize a forta.config.json and a keyfile for you in the ~/.forta folder (you will be prompted for a password for the keyfile). The forta.config.json file will be used throughout the development lifecycle of your bots. Several files will also be created inside of your project folder, including a package.json file, tsconfig.json (for Typescript) and a src folder. Dependencies of the project will also be installed for you by running <code>npm install</code>.</p> <p>Protecting your keyfile</p> <p>Make sure you do not forget the password for your keyfile as we have no way to recover it! We also recommend keeping a backup of it. The keyfile is located in the ~/.forta folder and named in the format <code>UTC--&lt;created_at UTC ISO8601&gt;--&lt;address hex&gt;</code> (an example name would be <code>UTC--2021-07-12T01:37:55.270Z--577022b59d1c25623ac523fe78d2f6347b5c69f2</code>). This keyfile will primarily be used for publishing your bot. You can get the absolute path to your keyfile using the <code>npm run keyfile</code> command from the project folder.</p> <p>Awesome! You have successfully completed setting up your project. See below for ideas/examples of bots, or continue to testing your bot.</p>"},{"location":"quickstart/#ideas-for-bots","title":"Ideas for bots","text":"<p>We\u2019re excited to see what sort of innovative bots the community comes up with! A good place to start is to choose a specific protocol that you use or would love to build bots for. You could also choose based on TVL ranking as listed on DeFi Pulse. If you\u2019re looking for some inspiration to get started, here are possible ideas for bots:</p> <ul> <li>Detect admin functions</li> <li>Detect high gas transactions</li> <li>Detect ownership transfers of contracts</li> <li>Detect high volume of failed transactions from an account</li> <li>Detect flash loan attacks</li> <li>Detect sandwich attacks</li> <li>Detect when an oracle is returning bad values</li> <li>Detect transactions from a known list of blacklisted addresses</li> </ul> <p>Be sure to check out useful libraries for developing your bots, including a set of low-code templates you can use. To learn more about what makes a good bot, see our FAQ section.</p>"},{"location":"quickstart/#examples","title":"Examples","text":"<p>You can find some example implementations of Forta bots in our examples repo. Another great place to see real bots in action is on the Forta App Discover page.</p>"},{"location":"scam-detector-bot/","title":"Scam Detector Docs","text":""},{"location":"scam-detector-bot/#overview","title":"Overview","text":"<p>The Scam Detector is an ideal source of threat intel for Web3 wallets and dashboard tools, as well as for security and compliance solutions serving a retail or institutional audience. Use the Scam Detector to build or supplement a blacklist, or as a transaction analysis tool by querying the Scam Detector at the point of approval or transaction to determine whether they are malicious. </p> <p>The Scam Detector provides threat intelligence about malicious smart contracts, EOAs, and URLs engaging in scams and other end-user attacks. It relies on a bundle of underlying Forta bots, each monitoring for a specific threat type (ex: Ice Phishing). </p> <p>The Scam Detector and its underlying bots are collectively maintained by the Forta community, including the Forta Foundation, Nethermind, and dozens of individual security researchers and developers.</p>"},{"location":"scam-detector-bot/#how-it-works","title":"How it works","text":"<p>Forta bots are monitoring on-chain activity 24/7/365. Some bots leverage a heuristic-based approach, others leverage machine learning to identify malicious activity. When bots identify an attack or scam on-chain, they create two types of threat intelligence:</p> <p>Labels. A persistent tag placed on an entity (smart contract, EOA, URL) responsible for a scam or attack. Today, the Scam Detector assigns one label: \u201cscammer\u201d (additional labels, like \"victim\" and \"stolen asset\" may follow). The label will contain the following information:</p> <ul> <li>label/entity - the address (either EOA or contract address) or URL</li> <li>label/entityType - EntityType.ADDRESS or EntityType.Url</li> <li>label/confidence - a confidence score from 0-1.0 with 1.0 being the most confident the label is correct</li> <li>label/remove - a flag indicating whether the label is being added or removed</li> <li>label/label - a string denoting the label that was placed on the entity. It currently is set to 'scammer'</li> <li>label/metadata/bot_version - version of the bot when the label was added</li> <li>label/metadata/threat_category - (see below)</li> <li>label/metadata/address_type - EOA or contract (addresses only)</li> <li>label/metadata/logic - (passthrough, ml, manual)</li> <li>label/metadata/threat_description_url - URL that describes the threat_category in more detail</li> </ul> <p>The Scam Detector currently monitors on-chain activity for the following threat categories:</p> <ul> <li>sleep-minting - Fired when an alert combination is observed that points to a sleep minting attack</li> <li>ice-phishing - Fired when an alert combination is observed that points to an ice phishing attack</li> <li>wash-trading - Fired when an NFT wash trade has been observed</li> <li>fraudulent-nft-order - Fired when an alert combination is observed that points to a fraudulent NFT order</li> <li>native-ice-phishing-social-engineering - Fired when an alert combination is observed that points to an native ice phishing involving social engineering techniques (e.g. SecurityUpdate() function sig in the input data field)</li> <li>native-ice-phishing - Fired when an alert combination is observed that points to a native ice phishing without a social engineering component</li> <li>hard-rug-pull - Fired when a contract with hard rug pull techniques is identified</li> <li>soft-rug-pull - Fired when a contract with soft rug pull techniques is identified</li> <li>rake-token - Fired when a contract with a rake is identified</li> <li>impersonating-token - Fired when a token contract has been identified that is impersonating a known established token (e.g. USDC or USDT)</li> <li>address-poisoning - Fired when an alert combination is observed that points to address poisoning attack; this threat category is used for labeling poisoning addresses</li> <li>address-poisoner - Fired when an alert combination is observed that points to address poisoning attack; this threat category is used for labeling poisoner addresses, aka the address that is initiating the poisoning and the contract performing the poisoning</li> <li>attack-stages - Fired when an alert combination is observed that points to an attack on-chain that spans the 4 stages of an attack (funding, preparation, exploitation, and money laundering) Many of the alerts here point to rug pulls and rake tokens.</li> <li>similar contract - Fired when a similar contract to a previously identified scammer contract has been identified</li> <li>scammer association - Fired when an EOA is associated with a known scammer account (e.g. receiving or sending funds)</li> <li>scammer-deployed-contract - When a known scammer deploys a contract</li> </ul> <p>New threat types are regularly added to the Scam Detector by the Forta community. </p> <p>Here\u2019s a glossary defining threat types in more detail. </p>"},{"location":"scam-detector-bot/#using-the-scam-detector","title":"Using the Scam Detector","text":"<p>The Scam Detector labels are each available via Forta's GraphQL API. For accessing threat intel from the Scam Detector, we recommend querying labels generated by this bot (sourceIds parameter needs to be set to [\"0x1d646c4045189991fdfd24a66b192a294158b839a6ec121d740474bdacb3ab23\"].) The primary label is 'scammer'. </p>"},{"location":"scam-detector-bot/#labels","title":"Labels","text":"<p>Labels allow a contributor to tag an entity (like an address) with a label.  Labels are available via our GraphQL API. This API allows one to search by date range and page over results.</p> <p>A recent one month sample of the labels can be downloaded here (prod, V1 label format) and here (beta, V2 label format).</p> <p>Note: </p> <p>To request entries that are currently accurate (and not later removed), pass state: true as part of the input.  Otherwise, the response will contain point-in-time events (which may contain removal (remove:true) events). </p> <p>At least one of:  labels, sourceIds, or entities is required.</p> <p>Example Query <pre><code>query Labels($input: LabelsInput) {\n  labels(input: $input) {\n    labels {\n      label {\n        label\n        entity\n        metadata\n      }\n      createdAt\n    }\n    pageInfo {\n      endCursor {\n        pageToken\n      }\n      hasNextPage\n    }\n  }\n}\n</code></pre></p> <p>Example Input <pre><code>{\n  \"input\": {\n    \"sourceIds\": [\n      \"0x1d646c4045189991fdfd24a66b192a294158b839a6ec121d740474bdacb3ab23\"\n    ],\n    \"labels\": [\n      \"scammer\"\n    ],\n    \"state\": true,\n    \"first\": 5,\n    \"metadata\": {\n      \"chain_id\": 56\n    },\n    \"afterCreatedAtDate\": \"2023-04-03T15:01:33Z\",\n    \"beforeCreatedAtDate\": \"2023-04-03T15:10:45Z\",\n    \"after\": {\n      \"pageToken\": \"29427820\"\n    }\n  }\n}\n</code></pre></p> <p>For a complete list of options, see the LabelsInput specification</p> <p>Example Response <pre><code>{\n \"data\": {\n   \"labels\": {\n     \"pageInfo\": {\n       \"hasNextPage\": true,\n       \"endCursor\": {\n         \"pageToken\": \"21193\"\n       }\n     },\n     \"labels\": [\n       {\n          \"createdAt\": \"2023-07-04T23:09:35.614989763Z\",\n          \"id\": \"0x97555444ff87aa9a56431571c906c6ef7ab25a24165fed6b72969964d455dadb\",\n          \"label\": {\n            \"label\": \"scammer\",\n            \"metadata\": [\n              \"address_type=contract\",\n              \"base_bot_alert_hashes=0x8f5e07151a1666d387a163bf91efdb346bc65c53c260e9e043125e762437ea84\",\n              \"base_bot_alert_ids=SOFT-RUG-PULL-SUS-POOL-REMOVAL\",\n              \"bot_version=2.15.3\",\n              \"chain_id=1\",\n              \"deployer_info=Deployer 0x02caf8b1e4b59529c9c100e8f0f90a3faeeeb2e4 involved in SCAM-DETECTOR-SOFT-RUG-PULL scam; this contract has been associated with this scam.\",\n              \"feature_vector=\",\n              \"label_version=2.1.0\",\n              \"logic=passthrough\",\n              \"model_name=v3_scammer_model.joblib\",\n              \"threat_category=soft-rug-pull\",\n              \"threat_description_url=https://forta.org/attacks#rug-pull\"\n            ],\n            \"remove\": false,\n            \"entityType\": \"ADDRESS\",\n            \"entity\": \"0x9bc388edeeb94c8017e0a6e178a8e7cb40f3d1f3\",\n            \"confidence\": 0.477\n          },\n          \"source\": {\n            \"chainId\": 1,\n            \"alertId\": \"SCAM-DETECTOR-SOFT-RUG-PULL\",\n            \"bot\": {\n              \"id\": \"0x47c45816807d2eac30ba88745bf2778b61bc106bc76411b520a5289495c76db8\"\n            },\n            \"alertHash\": \"0x1b11901bfca2873e83a1cba50ee937a35279b873eff56214eaaefbe068c3582a\"\n          }\n        }\n     ]\n   }\n  }\n}\n</code></pre></p> <p>Example as curl <pre><code>curl --request POST \\\n    --header 'content-type: application/json' \\\n    --url 'https://api.forta.network/graphql' \\\n    --data '{\"query\":\"query Labels($input: LabelsInput) {\\n  labels(input: $input) {\\n    labels {\\n      label {\\n        label\\n        entity\\n        metadata\\n      }\\n      createdAt\\n    }\\n    pageInfo {\\n      endCursor {\\n        pageToken\\n      }\\n      hasNextPage\\n    }\\n  }\\n}\",\"variables\":{\"input\":{\"sourceIds\":[\"0x1d646c4045189991fdfd24a66b192a294158b839a6ec121d740474bdacb3ab23\"],\"labels\":[\"scammer\"],\"state\":true,\"first\":5,\"metadata\":{\"chain_id\":56},\"afterCreatedAtDate\":\"2023-04-03T15:01:33Z\",\"beforeCreatedAtDate\":\"2023-04-03T15:10:45Z\",\"after\":{\"pageToken\":\"29427820\"}}}}'\n</code></pre></p> <p>More details on querying labels can be found in our Forta GraphQL API  documentation. </p>"},{"location":"scam-detector-bot/#matching-threat-intelligence","title":"Matching Threat Intelligence","text":"<p>Forta\u2019s threat intelligence indicators consist of scammer contracts, EOAs, and Urls that can be matched against transaction data (either pre-signing, during transaction simulation, or after block building.) </p> <p>Independent on the type of transaction data that will be used to match Forta's threat intelligence, specific matching logic need to be applied to obtain all relevant transactions based on the threat category observed as outlined below:</p>"},{"location":"scam-detector-bot/#ice-phishing","title":"ice-phishing","text":"<p>Ice phishing involves a user issuing an approval, approvalForAll, increaseApproval or permit transaction. The to address is a benign token contract, but approval is granted to the scammer address specified in the input data of the transaction. As such, the input data or corresponding emitted events for approvals, approval for all and permit transactions need to be parse and the spender value ought to be matched against Forta\u2019s threat intelligence.</p>"},{"location":"scam-detector-bot/#fraudulent-nft-order","title":"fraudulent-nft-order","text":"<p>Fraudulent NFT orders are challenging to match against the Forta\u2019s threat intelligence as the order is merely signed by a user, collected through web2 infrastructure (such as a web site) and then submitted by the scammer on the user\u2019s behalf. The order itself does not include the scammer address. </p> <p>However, the order gets executed by the scammer, so matching the from field will match those transactions. Once executed, the seaport protocol will transfer the digital assets to the scammer (which could be a different address from the invoking EOA) and matching emitted events for transfers would yield all relevant transactions. </p>"},{"location":"scam-detector-bot/#address-poisoning","title":"address-poisoning","text":"<p>Address poisoning results in a user\u2019s address history to be poisoned using token transfers or native asset dust. Matching should happen at two levels: 1. Match on any parsed transfer input data fields or corresponding event emissions for tokens. Note, either the to or the from could match the scammer. 2. Match on the from address for native assets transfers. </p>"},{"location":"scam-detector-bot/#address-poisoner","title":"address-poisoner","text":"<p>Address poisoners are the initiator of the address poisoning activity. A simple matching of the from and to field (if a contract) would yield the relevant transactions.</p>"},{"location":"scam-detector-bot/#native-ice-phishing-native-ice-phishing-social-engineering","title":"native-ice-phishing/ native-ice-phishing-social-engineering","text":"<p>Native ice phishing are straight transfers of native assets to the scammer. Matching the to address of the transaction against Forta threat intelligence yield transactions for this type of scam.</p>"},{"location":"scam-detector-bot/#hard-rug-pull-soft-rug-pull-token-impersonation-rake-token","title":"hard-rug-pull/ soft-rug-pull/ token-impersonation/ rake-token","text":"<p>These threat categories are indicative of malicious token contracts that can be matched based on the transaction to address and/or log fields (e.g. transfer logs) post tx simulation. </p>"},{"location":"scam-detector-bot/#wash-trading","title":"wash-trading","text":"<p>Wash trading artificially inflates the value and trading volume of digital assets the user may hold. In order identify transactions associated with these wash traded digital assets, the scammer addresses need to be matched against to/ from/ input data fields/ and emitted events. </p> <p>In addition, however, the actual wash traded digital asset is tainted and can be tracked by the transfer function. Note, given the contract could emit events with incorrect information - if created by the scammer; it is not a reliable data source. </p>"},{"location":"scam-detector-bot/#sleep-minting","title":"sleep minting","text":"<p>Sleep minting is similar to wash trading in that the provenance of an NFT is no longer guaranteed. In order track the sleep minted token by the transfer function. Note, given the contract could emit events with incorrect information, which is prevalent in sleep minting attacks; it is not a reliable data source. </p>"},{"location":"scam-detector-bot/#what-chains-are-supported","title":"What chains are supported?","text":"<ul> <li>Ethereum</li> <li>BNB Chain</li> <li>Polygon</li> <li>Avalanche</li> <li>Arbitrum</li> <li>Optimism </li> <li>Fantom </li> </ul> <p>The Forta community evaluates new chains on an ongoing basis.</p>"},{"location":"scam-detector-bot/#false-positives","title":"False Positives","text":"<p>While the Scam Detector maintains high precision, it\u2019s possible that it identifies a false positive. To address this risk, the Forta community manually verifies certain Scam Detector alerts within one business day. If a false positive is identified during the manual verification process, an FP alert will be emitted by the Scam Detector and the label will be removed. If you\u2019re accessing the Labels API via the state endpoint, all labels are up to date and take into account the latest FP information.  </p>"},{"location":"scam-detector-bot/#confidence-scores","title":"Confidence Scores","text":"<p>The confidence score associated with a label is hard coded and based on the precision analysis performed by the Forta community or derived from the machine learning score. The hard coded score is updated on a monthly basis, and reflects the precision of the Scam Detector for a particular threat-category before manual verification. </p>"},{"location":"scan-with-chainstack/","title":"Scan with Chainstack","text":"<p>Disclosure</p> <p>The following documentation was written by the team at Chainstack and does not reflect the views of the Forta Foundation.</p>"},{"location":"scan-with-chainstack/#scan-with-chainstack","title":"Scan With Chainstack","text":""},{"location":"scan-with-chainstack/#why-use-chainstack","title":"Why Use Chainstack?","text":"<p>Chainstack\u2019s managed blockchain services make it simple to join, launch, and scale decentralized networks and applications. The best way for builders, enterprises, and service providers to deploy, manage, and scale while reducing the time, cost, and the risk involved with leveraging decentralized technologies. With a secure API, membership management, and flexible deployment options, you can immediately accelerate and future-proof your development.</p> <p>Enjoy lightning-fast node performance and synchronization across an ever-growing list of supported networks with a\u00a010% slash to Forta node runner\u2019s subscription costs in Business and Enterprise plans (note the 10% discount will be applied manually by Chainstack after account creation).</p> <p>It is Chainstack\u2019s mission to provide maximal value for Web3 builders across the world with every new protocol available on the platform. Considering just how rampant blockchain exploits, hacks, and anomalous activity can be, especially as of late, their team saw Forta as a perfect fit for the needs of their customers.</p> <p>\u201cWith exploits, hacks, and other malicious activity plaguing protocols or DApps from day one, having access to a set of security and detection tools is becoming ever more critical to a Web3 developer. This makes Forta a critical contributor to the healthy functioning of any project and a welcome addition to Chainstack\u2019s list of supported protocols,\u201d Eugene Aseev, Founder and CTO of Chainstack.</p>"},{"location":"scan-with-chainstack/#embrace-the-power-of-hybrid-hosting","title":"Embrace The Power Of Hybrid Hosting","text":"<p>Ever wanted to have your very own data center to house your entire blockchain operation? Well\u2026 now you can! But that\u2019s not even half the story \u2013 you will get to have your cake and eat, as an expert team of Chainstack engineers will be there to lift the burden of managing it all yourself.</p> <p></p> <p>So, grab a cold drink and kick your feet up on the table, as you witness the problem taking care of itself right before your very own eyes. With Chainstack\u2019s hybrid hosting, this will no longer be a distant dream for you but a welcome sense of reality knocking on your door to get things started.</p> <p>Start a convo here and their team will gladly show you just how deep the Chainstack rabbit hole goes\u2026</p>"},{"location":"scan-with-chainstack/#special-offer","title":"Special Offer","text":"<p>Claim your special Forta promo rate by clicking here for a 10% discount on Chainstack Business and Enterprise Plans (note the 10% discount will be applied manually by Chainstack after account creation).</p> <p>Chainstack\u2019s exceptional engineering and sturdy infrastructure now make lower overhead costs and optimal efficiency when running Forta scan nodes a reality for all. Reap the benefits of flexible affordable commitments that are a perfect fit for your budget, use case, and the needs of your project.</p> <p>Give it a shot and take advantage of the critical security and threat detection features the Forta network offers with a commitment-free introduction rate for full elastic nodes via the Developer plan. And while you\u2019re at it, make use of up to 3M requests that come with the subscription.</p> <p>Want to get more bang for your buck? Chainstack\u2019s pricing tiers are designed with maximum efficiency in mind, so you can get everything you need at a predictable rate that fits your budget. This adaptable and price-competitive structure makes Forta scan node deployment with Chainstack a perfect opportunity for a project of any size, or stage.</p> <p></p> <p>Even with the most affordable subscription plan \u2013 Growth, you get to enjoy a whopping four times as many requests (8M). And should you prefer to up the ante, you will discover 20M or 10x more requests available with the added bonus of having no restrictions for dedicated nodes with the Business plan and above.</p> <p>Reached your limit? Worry not, for you can always snatch some more at the affordable rate of $0.1 per 10K for the first 20M extra requests you claim. And should you want some more, you get to reap a 50% discount or $0.05 per 10K for every request above the first 20M. Too much math? Just let Chainstack\u2019s handy pricing calculator do the talking.</p>"},{"location":"scan-with-chainstack/#create-a-new-chainstack-account","title":"Create A New Chainstack Account","text":"<p>Getting started with Forta on Chainstack is as straightforward as counting 1-2-3:</p> <ul> <li>Log into the Chainstack console</li> <li>Select a preferred cloud provider</li> <li>Pick a node location with low latency</li> </ul> <p>And now that you know just how easy it is to get the ball rolling, you will be even more pleasantly surprised to hear that all details and operations are available within a single seamless Chainstack dashboard. Deploying a Forta scan node is truly a walk in the park with the Chainstack platform and something you are sure to enjoy as a Web3 developer.</p> <p>So, take point! Reserve your spot among the early adopters of the Forta network and start leveraging the priceless security and threat detection features it brings to the table. There is so much you can do with Forta once you have a reliable Web3 infrastructure partner to support you every step of the way.</p>"},{"location":"scan-with-chainstack/#get-a-custom-power-user-quote","title":"Get A Custom Power-User Quote","text":"<p>Let\u2019s face it \u2013 as a high-roller or a large enterprise, it is often the case that the preset mold just doesn\u2019t quite fit your needs and setup. Instead, it just leaves you craving for that much more\u2026 And that\u2019s okay!</p> <p>Chainstack understands your drive to break new ground with every step you take, which is why they have a dedicated team of Web3 pros standing at the ready for your case. Come talk to their team about your use case so they can help you move closer to your goals.</p> <p>Get a priceless consultation that will point you in the right direction and start from pole-position with a custom-tailored quote that is sure to offer you the best in stock. Gain access to robust enterprise-grade infrastructure and dedicated nodes with unlimited requests for your demanding use case. And while you\u2019re at it, take a moment to enjoy absolute freedom in selecting the cloud provider that will suit you best.</p>"},{"location":"scanner-direct-withdrawal/","title":"Direct Withdrawal","text":"<p>If you wish to withdraw directly from your non-migrated scan node that still exists in the ScannerRegistry contract, you can follow the old steps to do this.</p> <p>Delay</p> <p>Please take into account the 10 days of withdrawal delay while completing this. This is the time to wait after initiating a withdrawal.</p> <p>Deprecated</p> <p>This is a deprecated way of withdrawing stake. Please see this guide to manage your own or delegated stake on a scanner pool.</p>"},{"location":"scanner-direct-withdrawal/#initiating-a-stake-withdrawal","title":"Initiating a stake withdrawal","text":"<p>When this action is executed (<code>initiateWithdrawal()</code>), active stake becomes inactive i.e. active shares are burned and inactive shares minted.</p> <p>After staking delay is over, you will be able to <code>withdraw()</code> FORT, as described in the next section.</p> <p>Permissions</p> <p>Only active shareholders can initiate a withdrawal.</p> <p></p>"},{"location":"scanner-direct-withdrawal/#initiate-the-withdrawal-using-polygonscan","title":"Initiate the withdrawal using Polygonscan","text":"<ol> <li> <p>Go to Forta staking contract page, section Write as Proxy</p> </li> <li> <p>Connect your scan node owner wallet and make sure that you have selected the Polygon network. </p> </li> <li> <p>Go to <code>4. initiateWithdrawal</code> and input the following:</p> <ul> <li> <p>subjectType: 0</p> </li> <li> <p>subject: Your scan node address (not the owner address).</p> </li> <li> <p>stakeValue: Amount of shares to unstake, in wei. If the node has not been slashed, the proportion is <code>1 Share : 1 FORT</code>. If you are unsure about the amount in wei, you can use a converter like https://eth-converter.com/. </p> </li> </ul> </li> <li> <p>Click Write and approve the transaction in your wallet.</p> </li> <li> <p>After confirmation, the staking delay starts. If the current active shares are under the minimum stake threshold, the node enters into disabled state.</p> </li> </ol>"},{"location":"scanner-direct-withdrawal/#withdrawal","title":"Withdrawal","text":"<p>Burn inactive shares after staking delay to get staked FORT.</p> <p></p>"},{"location":"scanner-direct-withdrawal/#withdrawal-using-polygonscan","title":"Withdrawal using Polygonscan","text":"<ol> <li> <p>When the staking delay is over, go to Forta staking contract page, section Write as Proxy</p> </li> <li> <p>Connect your scan node owner wallet and make sure that you have selected the Polygon network. </p> </li> <li> <p>Go to <code>23. withdraw</code> and input the following:</p> <ul> <li> <p>subjectType: 0</p> </li> <li> <p>subject: Your scan node address (not the owner address). </p> </li> </ul> </li> <li> <p>Click Write and approve the transaction in your wallet.</p> </li> <li> <p>When the transaction is confirmed, you will receive the FORT amount you specified in <code>initiateWithdrawal()</code> step.</p> </li> </ol>"},{"location":"scanner-local-mode/","title":"Run a Scan Node locally","text":"<p>In addition to default public scanning, <code>forta</code> has a local mode which is useful for:</p> <ul> <li>running only specific detection bots</li> <li>doing a test run using specific detection bots within a block range</li> <li>logging the alerts instead of publishing</li> <li>forwarding the alerts to a specific target (webhook)</li> <li>producing bot metrics</li> </ul> <p>Staking and rewards</p> <p>Local nodes do not require staking and do not generate any rewards. Local mode is made available only to suit your private scanning and testing needs.</p>"},{"location":"scanner-local-mode/#steps-to-run","title":"Steps to run","text":""},{"location":"scanner-local-mode/#using-the-cli","title":"Using the CLI","text":"<p>Steps to run a local node using the CLI:</p> <ul> <li><code>forta init --passphrase &lt;passphrase&gt;</code></li> <li>Configure <code>~/.forta/config.yml</code></li> <li><code>forta run --passphrase &lt;passphrase&gt;</code></li> </ul> <p>You can provide the passphrase by doing <code>export FORTA_PASSPHRASE=&lt;passphrase&gt;</code> as an alternative method to the <code>--passphrase</code> flag. If you are setting up your node just for testing and development, you can choose a weak and convenient passphrase.</p>"},{"location":"scanner-local-mode/#using-docker-compose","title":"Using Docker Compose","text":"<p>Alternatively, if you would like to run the local mode using a single <code>docker-compose.yml</code> file make sure you check out the  standalone mode section!</p>"},{"location":"scanner-local-mode/#start-configuring","title":"Start configuring","text":"<p>To enable the local mode successfully, please specify at least these settings in the config file:</p> <pre><code># id of the chain to scan\nchainId: 1\n\nscan:\n  jsonRpc:\n    url: http://some-json-rpc-url.io\n\ntrace:\n  jsonRpc:\n    url: http://only-if-required-for-chain.io\n\njsonRpcProxy:\n  jsonRpc:\n    url: http://defaults-to-scan-url-if-not-specified.io\n\nlocalMode:\n  enable: true\n  # docker references of remote or locally available detection bot images\n  botImages:\n    - my-local-test-bot-image-reference\n    - disco.forta.network/bafybeie5xvbbvhlrollwfb3xd4qxs5qw6rhk52ukeq2zbek6tetryqdn5a # remote image\n</code></pre> <p>If <code>forta</code> requires trace API to be specified for the configured <code>chainId</code> (e.g. Ethereum Mainnet, Fantom) and you don't want to use a trace API for now, you can change the <code>chainId</code> to something random like <code>90909</code>.</p>"},{"location":"scanner-local-mode/#specify-a-block-range","title":"Specify a block range","text":"<p>This allows limiting the runtime inputs, testing different bots under the same conditions and comparing outputs. Since bot processing delay can be unexpected, it is important to specify a <code>stopTimeoutSeconds</code> to wait for all bots to finish and the alerts to get logged or sent (webhook). It is useful to reduce the publishing interval to a short time in order to keep <code>stopTimeoutSeconds</code> at a lower value.</p> <pre><code>publish:\n  batch:\n    intervalSeconds: 1\n    metricsBucketIntervalSeconds: 1 # how often the metrics go out with alert batches\n\nlocalMode:\n  ...\n  runtimeLimits:\n    startBlock: 1191111\n    stopBlock: 1192345\n    stopTimeoutSeconds: 30\n</code></pre>"},{"location":"scanner-local-mode/#outputting-alerts","title":"Outputting alerts","text":"<p>By default, local mode logs all alert batch outputs to <code>~/.forta/logs/forta-local-alert-logs-{timestamp}</code>. You can use the <code>logFileName</code> setting to always write to a specific file within <code>~/.forta/logs</code>.</p> <pre><code>localMode:\n  ...\n  logFileName: testlogs.txt\n</code></pre> <p>Or, you could let them be outputted to stdout as info-level logs. Please keep in mind that this disables the other types of outputs described in this section.</p> <pre><code>localMode:\n  ...\n  logToStdout: true\n</code></pre> <p>If you would like to forward the alerts to a specific destination instead, you can specify a webhook handler:</p> <pre><code>localMode:\n  ...\n  webhookUrl: http://my-webhook-handler.url\n</code></pre> <p>To suit these kinds of purposes, we defined Forta Webhook Specification. In local mode, a scan node conforms with this specification and sends authorized webhook requests.</p> <p>About paths</p> <p>The paths defined in the webhook specification is only for making the definitions easier. Scan node configuration requires the complete webhook URL and ignores all paths defined in the specification.</p> <p>Convert to Discord Webhooks</p> <p>If you need to convert the webhook requests to Discord webhook requests, make sure you check out this awesome converter by Lido Finance.</p>"},{"location":"scanner-local-mode/#alert-deduplication","title":"Alert deduplication","text":"<p>If you wish to avoid outputting an alert multiple times from a cluster of local nodes, you can set up Redis and point your nodes using the deduplication config.</p> <pre><code>deduplication:\n  ttlSeconds: 300\n  redis:\n    address: &lt;host&gt;:&lt;port&gt;\n    password: '123'\n    db: 1 # database to be selected after connecting to the server\n</code></pre> <p>Alternatively, if you are running a Redis cluster:</p> <pre><code>deduplication:\n  ttlSeconds: 300\n  redisCluster:\n    addresses:\n      - host1:&lt;port&gt;\n      - host2:&lt;port&gt;\n    password: '123'\n</code></pre>"},{"location":"scanner-local-mode/#simulate-json-rpc-throttling","title":"Simulate JSON-RPC throttling","text":"<p>If you would like to observe how your bots are doing under strict JSON-RPC rate limiting, you can override the token bucket algorithm settings from:</p> <pre><code>jsonRpcProxy:\n  ...\n  rateLimit:\n    rate: 123\n    burst: 456\n</code></pre>"},{"location":"scanner-local-mode/#bot-metrics","title":"Bot metrics","text":"<p>As part of the alert batches (mentioned in the webhook specification), some bot metrics are forwarded. These metrics are bucketed into the specified interval in the config and a summary object for each goes out with the soonest batch possible as soon as the interval is over.</p> <p>Metrics are especially helpful to understand the performance of your bots. However, please keep in mind that <code>forta</code> does not yet come with a tool to further analyze or visualize this data.</p> <pre><code>publish:\n  batch:\n    intervalSeconds: 1\n    metricsBucketIntervalSeconds: 1 # how often the metrics go out with alert batches\n\nlocalMode:\n  ...\n  includeMetrics: true\n</code></pre> <p>Please see Forta Webhook Specification to better understand the metrics summary data model.</p>"},{"location":"scanner-local-mode/#types-of-bot-metrics","title":"Types of bot metrics","text":"Name Description <code>finding</code> Finding count <code>findings.dropped</code> Dropped finding count (due to hard limit) <code>tx.request</code> Transaction input count <code>tx.latency</code> Transaction processing latency <code>tx.error</code> Transaction processing error count <code>tx.success</code> Transaction processing success count <code>tx.drop</code> Dropped transaction input count <code>tx.block.age</code> From block time to bot input time in ms <code>tx.event.age</code> From tx feed time to bot input time in ms <code>block.block.age</code> From block time to bot input time in ms <code>block.event.age</code> From block feed time to bot input time in ms <code>block.request</code> Block input count <code>block.latency</code> Block processing latency <code>block.error</code> Block processing error count <code>block.success</code> Block processing success count <code>block.drop</code> Dropped block input count <code>jsonrpc.latency</code> JSON-RPC request latency <code>jsonrpc.request</code> JSON-RPC request count <code>jsonrpc.success</code> JSON-RPC request success count <code>jsonrpc.throttled</code> Throttled JSON-RPC request count"},{"location":"scanner-local-mode/#standalone-mode","title":"Standalone mode","text":"<p>We crafted a more specialized version of the local mode, called standalone mode, which allows running the node using a single <code>docker-compose.yml</code> file without having to deal with the Forta node CLI and the <code>~/.forta</code> directory.</p> <p>In this mode,</p> <ul> <li>all of the required Forta node service containers and the bots are defined under <code>services</code>,</li> <li>container dependencies are set by using <code>depends_on</code> definitions,</li> <li>Forta config is defined under <code>x-forta-config</code> instead of using a separate <code>config.yml</code> file.</li> </ul> <p>The <code>docker-compose.yml</code> file looks something like this:</p> <pre><code>services:\n  service-forta-scanner:\n    container_name: forta-scanner\n    image: forta-network/forta-scanner:latest\n    ...\n    depends_on:\n      - bot-1\n  ...\n\n  bot-1:\n    container_name: forta-bot-1\n    ...\n\nx-forta-config:\n  ...\n\n  localMode:\n    enable: true\n    logToStdout: true\n    privateKeyHex: abcdefg0...\n    standalone:\n      enable: true\n      botContainers:\n        - forta-bot-1\n</code></pre> <p>For a more detailed reference, please check out to the Docker Compose file defined in the forta-node repository here. You can use that file as boilerplate for your purposes.</p> <p>This is still local mode</p> <p>The other local mode settings are valid to use in this mode and other explanations also apply to it, since standalone is just a specialized sub-mode of the local mode.</p> <p>The steps to run the standalone mode using that file are:</p> <ul> <li>Set <code>privateKeyHex</code> to something that makes sense to you. The webhook requests include a JWT that is signed using that. (More about verification here)</li> <li>Optionally, specify the webhook URL you would like to use.</li> <li>Configure the bot containers under <code>services</code> and let the scanner container depend on them (by using <code>depends_on</code>).</li> <li>List down the names of the bot containers (not service names!) under <code>localmode.standalone.botContainers</code> so the scanner container can attach to them.</li> <li> <p>Specify the service container images. You can get this in two different ways:</p> <ul> <li>Follow the IPFS hash in the <code>forta version</code> output and find the Docker image reference. Then use that reference like <code>disco.forta.network/bafybei...</code> in the Docker Compose file.</li> <li>At the project root, do <code>make containers</code> and it will build the <code>forta-network/forta-scanner:latest</code> image for you.</li> </ul> </li> <li> <p>Run the Docker Compose file like <code>docker compose up --remove-orphans --abort-on-container-exit</code>.</p> </li> </ul>"},{"location":"scanner-pools/","title":"Manage Scanner Pools and Stake","text":""},{"location":"scanner-pools/#introduction","title":"Introduction","text":"<p>A scanner pool contains a group of nodes that scan a specific chain. Each pool belongs to a specific owner and is minted as an NFT (ERC-721) upon registration. These pools require the operators to deposit a total amount of stake which covers the minimum-per-scan-node amount (2500 FORT) for each node.</p> <p>When registering an extra node to a pool, make sure to top up your pool with this minimum amount first.</p> <p>The pool owners which allocate at least the minimum amount required per scanner for their monitored chain, may allow delegations to their pools (up to the max stake allowed: 15,000 FORT per node). Operators can decide</p> <ul> <li>how much of the delegator or operator stake should be allocated,</li> <li>what percentage to keep as commission from delegators' rewards.</li> </ul>"},{"location":"scanner-pools/#creating-a-new-scanner-pool","title":"Creating a new scanner pool","text":"<ul> <li>In the Forta App navigate to \u201cMy Node Pools\u201d</li> </ul> <ul> <li> <p>Click \u201cAdd Scanner Pool\u201d </p> </li> <li> <p>Select a chain for your node pool to monitor and register your node pool</p> </li> </ul> <p></p> <ul> <li>Accept the transaction for creating your node pool and wait for it to be confirmed</li> </ul>"},{"location":"scanner-pools/#depositing-stake","title":"Depositing stake","text":"<p>In order to make scan nodes operational and generate rewards, a node pool must have stake.</p> <ul> <li>Both the pool owner and delegators can stake on a pool.</li> <li>There is no limit on how much FORT can be staked on a pool.</li> <li>There is a limit on how much FORT can be allocated: More nodes in a pool means a higher limit.</li> <li>The pool owner decides how much of the owner and delegated stake should be allocated.</li> </ul> <p>Density affects the rewards</p> <p>When staking on a pool, please prefer the ones that have allocation capacity or have a low amount of unallocated stake. While a lot of depositors can share the rewards of a pool proportionally to their active stake amount on the pool, the rewards are generated based only on the amount of allocated stake.</p> <p>Please also see the Adjusting stake allocation section before depositing any stake.</p>"},{"location":"scanner-pools/#depositing-on-your-own-pool","title":"Depositing on your own pool","text":"<ul> <li>In the Forta App navigate to \u201cMy Node Pools\u201d</li> </ul> <ul> <li>Click on the node pool you would like to add stake</li> </ul> <ul> <li>Click \u201cAdd Stake\u201d</li> </ul> <ul> <li> <p>In order to stake, there are two transactions that must be executed:</p> <ul> <li>Approve the amount of FORT to stake</li> <li>Stake the approved FORT</li> </ul> </li> <li> <p>Enter the amount of FORT you want to approve for staking and wait for the transaction to confirm</p> </li> </ul> <p></p> <ul> <li>Enter the amount of approved FORT you want to stake and wait for the transaction to confirm</li> </ul> <p></p>"},{"location":"scanner-pools/#delegating-to-a-pool","title":"Delegating to a pool","text":"<ul> <li>Find a node pool (that you do not own) on the Network Participants page that has a node and enough stake to earn rewards</li> </ul> <ul> <li>Navigate to the node pool page by clicking on the address</li> </ul> <ul> <li> <p>Click on the \u201cDelegate\u201d button. There are 2 transactions required for delegation</p> <ul> <li>Approve the amount of FORT to delegate</li> <li>Delegate the approved FORT</li> </ul> </li> <li> <p>Enter the amount of FORT you want to approve for delegation. Click \u201cApprove tokens\u201d and approve the transaction. Wait for the transaction to confirm.</p> </li> </ul> <p></p> <ul> <li>Enter the amount of approved FORT you want to delegate and click \u201cDelegate\u201d and approve the transaction. Wait for the transaction to confirm</li> </ul> <p></p> <ul> <li>Navigate to \u201cMy Stakes\u201d or \u201cOverview\u201d on your profile and you can see your staked FORT</li> </ul>"},{"location":"scanner-pools/#withdrawal","title":"Withdrawal","text":"<p>You can withdraw your stakes by navigating to the \u201cMy Stakes\u201d page from the top right menu.</p> <p>Stake lockdown</p> <p>Once the stake withdrawal is initiated, it becomes inactive immediately but cannot be withdrawn for 10 days. Please keep in mind that this delay is subject to change.</p>"},{"location":"scanner-pools/#creating-new-nodes","title":"Creating new nodes","text":"<p>Each node needs to be registered to a specific pool in order to be operational. While one can register many scan nodes on a pool, the pool needs to be populated with more stake first in order to avoid registration issues. This is for preventing pool shutdown conditions that occur when the average per-scanner stake is below minimum.</p> <ul> <li>In the Forta App navigate to \u201cMy Node Pools\u201d</li> </ul> <p></p> <ul> <li> <p>Click on the node pool you would like to add a node </p> </li> <li> <p>Make sure you have at least 2,500 FORT staked for the new node. Click \u201cAdd Scan Node\u201d. Use the Forta node CLI to generate the scanner authorization token (described here) needed to claim a node into a pool.</p> </li> </ul> <p></p>"},{"location":"scanner-pools/#disabling-existing-nodes","title":"Disabling existing nodes","text":"<p>If a node is no longer used, it should be disabled to free up allocated stake for newer nodes.</p> <ul> <li> <p>Navigate to the node pool that has the node you want to disable</p> </li> <li> <p>Select the disable action on the node you want to disable</p> </li> </ul> <p></p>"},{"location":"scanner-pools/#adjusting-stake-allocation","title":"Adjusting stake allocation","text":"<p>The pool owner has the ability to decide how much of the tokens staked in the pool (owner stake and delegated stake) are allocated. This allocation is divided by the number of scan nodes at the time of:</p> <ul> <li>checking if the pool satisfies the minimum stake allocation per node,</li> <li>calculating rewards using the rewards formulas.</li> </ul> <p>While it's always possible to add more stake to a pool, it is allocated proportionally to the amount of scan nodes in the pool. The maximum amount of total allocated stake can only be <code>node_count \u00d7 max_stake_per_scan_node</code>.</p> <ul> <li>The owner of the pool needs to allocate at least 2,500 FORT of his own stake for each node in a pool, for the pool to be active.</li> <li>The total allocation capacity is 15,000 FORT for each node in a pool.</li> </ul> <p>When you deposit more stake on your pool as the owner of the pool and then register a node to it, your stake is allocated automatically. It is up to the pool owner to allocate more from owner stake or more from the delegators so the partitioning of pool rewards (owner vs. delegator) can be adjusted accordingly.</p> <p>Subject to change</p> <p>These limits are subject to change over time.</p> <p>For example, let's assume that at a given time frame:</p> <ul> <li>The minimum stake allocation required per node is 2500 FORT.</li> <li>The maximum stake allocation allowed per node is 5000 FORT.</li> </ul> <p>In this example case, then this is how allocation and node registration plays together:</p> <p></p> <p>Risk of shutting down the pool</p> <p>After unallocating owner stake as the operator, if the allocated owner stake does not satisfy <code>node_count \u00d7 min_stake_per_scan_node</code>, the pool faces the risk of shutting down and will generate no rewards! Please take into account the warnings and your calculations before proceeding.</p> <p>E.g. for a pool with two nodes, a 4k FORT stake on the pool means that both of the nodes in the pool are non-operational until it can be topped up to 5k (<code>2500 \u00d7 2</code>) by the pool owner and allocation of owner stake is adjusted accordingly.</p> <ul> <li>In the Forta App navigate to \u201cMy Node Pools\u201d</li> </ul> <p></p> <ul> <li>Click on the node pool you would like to adjust the stake allocation</li> </ul> <p></p> <ul> <li>Click on \"Allocate Stake\"</li> </ul> <p></p> <ul> <li>From here you can either allocate or unallocate stake. To adjust owner stake make sure the subject is Owner</li> </ul> <p></p> <ul> <li>To adjust the stake of delegators select the Delegators subject</li> </ul> <p></p>"},{"location":"scanner-pools/#changing-the-commission","title":"Changing the commission","text":"<p>In addition to the allocation adjustment, operators can decide how much of the delegators' rewards they would like to keep as commission.</p> <p>By default, all pools start with 100% commission, meaning that all delegator rewards will be received by the pool owners. This should be adjusted to a desired number by the pool owner if delegators are expected.</p> <p>Commission lockdown</p> <p>Once the commission is modified, it becomes effective in two epochs (at the start of the epoch following the current one) and cannot be changed for two epochs (excluding the current one). Please keep in mind that this delay is subject to change.</p> <p>For example, let's assume:</p> <ul> <li>Delegator 1 deposits 12000 FORT.</li> <li>Delegator 2 deposits 6000 FORT.</li> <li>Pool commission is 10% (1000 BPS).</li> <li>The pool delegators are rewarded 2000 FORT in total.</li> </ul> <p>In this case, <code>2000 \u00d7 0.1 = 200</code> FORT is credited to the pool owner as commission. From the remaining 1800 FORT,  each of the delegators earns proportionally to their deposited stake:</p> <ul> <li>Delegator 1: 12000 =&gt; 1200</li> <li> <p>Delegator 2: 6000  =&gt; 600 </p> </li> <li> <p>Click on the node pool you would like to adjust the stake allocation (you must be the owner)</p> </li> <li> <p>Click on \"Change commission rate\"</p> </li> </ul> <p></p> <ul> <li>Enter the commission that you would like to set on your pool</li> </ul> <p></p>"},{"location":"scanner-quickstart/","title":"Scanner quickstart","text":"<p>Out of date</p> <p>This page is deprecated and no longer maintained. For the latest information, please visit the Guide.</p>"},{"location":"scanner-quickstart/#run-a-scan-node","title":"Run a Scan Node","text":"<p>This page contains the steps and technical recommendations to help you set up your node. Please always refer to this documentation for the most up-to-date node setup and configuration details.</p> <p>For other information including rewards, please check out our node operators page if you have not visited yet.</p>"},{"location":"scanner-quickstart/#scan-node-requirements","title":"Scan Node Requirements","text":""},{"location":"scanner-quickstart/#resources","title":"Resources","text":"<p>The following are the requirements for running a Forta scan node.</p> <ul> <li>64-bit Linux distribution</li> <li>CPU with 4+ cores</li> <li>16GB RAM</li> <li>Connection to Internet</li> <li>Docker v20.10+</li> <li>100GB SSD (in addition to full node requirements)</li> <li>Recommended: Full node (any chain)</li> </ul> <p>Security</p> <p>Forta scan node software uses isolation techniques to prevent detection bot code from executing malicious actions. Please make sure you take extra measures and strengthen your host machines:</p> <ul> <li>Implement iptables rules the disallow access to sensitive subnetworks.</li> <li>Do not equip your machines with strong cloud privileges.</li> </ul>"},{"location":"scanner-quickstart/#stake","title":"Stake","text":"<p>All nodes need to be registered to run within a specific pool. In order to make your node operational in the network, please visit the scanner pool management guide to find out how you can create, manage and stake on a scanner pool.</p> <p>In the following steps, you will be able to use your pool ID for scan node registration.</p> <p>Stake on the pool first</p> <p>Make sure you stake on your pool first before registering any scan node to it, as suggested in scanner pool management guide. There is a minimum per-scan-node stake amount that needs to be satisfied in every pool. Adding a scan node to a pool without adding extra stake can render all nodes in a scan node non-operational so this is not allowed by the contract.</p>"},{"location":"scanner-quickstart/#optional-run-your-ethereum-full-node","title":"Optional: Run your Ethereum full node","text":"<p>If you are planning on setting up a Forta node, your own full node node is the most reliable option as a provider to your Forta node.</p> <p>The most preferred full node option for Ethereum mainnet is running an Erigon node. Your Erigon node (Execution Layer) needs to run with a beacon node (Consensus Layer). For more details, please make sure you visit The Merge section on this page.</p> <pre><code>erigon-rpcdaemon \\\n  --http.vhosts '*' --http.port 8545 \\\n  --http.addr 0.0.0.0 --http.corsdomain '*' \\\n  --http.api 'eth,net,web3,trace' --private.api.addr=localhost:9090 \\\n  --authrpc.addr 0.0.0.0 --authrpc.jwtsecret &lt;secret&gt;\n\nerigon --private.api.addr=localhost:9090\n</code></pre> <p>Ethereum node access</p> <p>Be sure to set <code>--http.vhosts</code> to allow hostname access, and enable <code>eth,net,web3</code> HTTP APIs. Note that <code>trace</code> is only applicable for Ethereum mainnet.</p>"},{"location":"scanner-quickstart/#synchronize-system-time","title":"Synchronize system time","text":"<p>To produce correct timestamps on the alerts and avoid authorization problems at the time of publishing alerts, you must ensure at all times that the system time is correct. If the system time is not correct, your node will fail to publish alerts and may generate no rewards as a result.</p> <p>We suggest using <code>systemd-timesyncd</code> which is widely available and sufficient as a time synchronization daemon. After started, it will periodically synchronize the system time in background.</p> <p>To enable, <code>systemd-timesyncd</code> and check the result, you can do: <pre><code>$ sudo systemctl enable systemd-timesyncd\n$ sudo systemctl start systemd-timesyncd\n$ timedatectl status\n               Local time: Tue 2022-01-01 17:00:00 -03\n           Universal time: Tue 2022-01-01 20:00:00 UTC\n                 RTC time: Tue 2022-01-01 20:00:00\n                Time zone: America/Argentina/Buenos_Aires (-03, -0300)\nSystem clock synchronized: yes\n              NTP service: active  &lt;------------------- (it worked)\n          RTC in local TZ: no\n</code></pre></p>"},{"location":"scanner-quickstart/#install-and-configure-docker","title":"Install and Configure Docker","text":"<p>Install Docker (at least v20.10) </p> <p>Add a file called <code>daemon.json</code> to your <code>/etc/docker</code> directory with the following contents:</p> <pre><code>{\n   \"default-address-pools\": [\n        {\n            \"base\":\"172.17.0.0/12\",\n            \"size\":16\n        },\n        {\n            \"base\":\"192.168.0.0/16\",\n            \"size\":20\n        },\n        {\n            \"base\":\"10.99.0.0/16\",\n            \"size\":24\n        }\n    ]\n}\n</code></pre> <p>Avoid networking conflicts</p> <p>Please confirm these network ranges don't conflict with your node's network, especially if you use VPC peering, VPNs, or other non-trivial networking settings.</p> <p>Restart docker with <code>systemctl restart docker</code></p> <p>Ensure docker is running.  You can run <code>docker ps</code> and you should not get any errors and see a list of header columns.</p> <p>Run Docker as a non-root user</p> <p>To run docker as a non-root user, do the following:</p> <p>Add the docker group (it may already exist)</p> <pre><code>sudo groupadd docker\n</code></pre> <p>Add your user to that group.</p> <pre><code>sudo usermod -aG docker your-user\n</code></pre> <p>You must exit and login again to take effect</p> <p>Make sure Docker is running</p> <p>Once <code>docker ps</code> gives you a list of headers, continue to the next section.</p>"},{"location":"scanner-quickstart/#install-forta","title":"Install Forta","text":"<p>The Forta scan node software is available for popular 64-bit Linux distributions using official Forta repositories. Package installation methods are verifiable (auto-verified during installation) and help you install required dependencies.</p>"},{"location":"scanner-quickstart/#install-via-yum-centos-fedora-red-hat-enterprise-linux-etc","title":"Install via YUM (CentOS, Fedora, Red Hat Enterprise Linux etc.)","text":"<pre><code>$ sudo curl https://dist.forta.network/repositories/yum/Forta.repo -o /etc/yum.repos.d/Forta.repo -s\n$ sudo yum install forta\n</code></pre>"},{"location":"scanner-quickstart/#install-via-apt-ubuntu-debian-etc","title":"Install via APT (Ubuntu, Debian etc.)","text":"<pre><code>$ sudo curl https://dist.forta.network/pgp.public -o /usr/share/keyrings/forta-keyring.asc -s\n$ echo 'deb [signed-by=/usr/share/keyrings/forta-keyring.asc] https://dist.forta.network/repositories/apt stable main' | sudo tee -a /etc/apt/sources.list.d/forta.list\n$ sudo apt-get update\n$ sudo apt-get install forta\n</code></pre>"},{"location":"scanner-quickstart/#install-manually","title":"Install Manually","text":"<p>Install Docker (at least v20.10) </p> <p>Download the latest x86-64 release binary and install</p> <pre><code>$ sudo curl https://dist.forta.network/artifacts/forta -o /usr/local/bin/forta\n</code></pre> <p>Make the binary executable</p> <pre><code>$ sudo chmod 755 /usr/local/bin/forta\n</code></pre>"},{"location":"scanner-quickstart/#initial-setup","title":"Initial Setup","text":"<p>Forta scan node's CLI allows you to set up your first Forta configuration directory along with creating and managing your scan node's private key.</p>"},{"location":"scanner-quickstart/#initialize-forta-directory","title":"Initialize Forta Directory","text":"<p>Initialization creates a private key that will sign the alerts from your scan node.  You must set the <code>FORTA_PASSPHRASE</code> environment variable or provide the --passphrase flag to the <code>init</code> command.</p> <p>Initialize Forta using the <code>forta init</code> command</p> <pre><code>$ forta init --passphrase &lt;your_passphrase&gt;\n</code></pre> <p>Forta Directory</p> <p>By default, the forta directory is located in <code>~/.forta</code>. If you would like to use a different directory, either set the <code>FORTA_DIR</code> env var or provide the <code>--dir</code> flag to every command. Init command will initialize your Forta configuration and key to this directory.</p> <p>This command generates a config directory, a private key and outputs your address.</p> <pre><code>Scanner address: 0xAAA8C491232cB65a65FBf7F36b71220B3E695AAA\n\nSuccessfully initialized at /yourname/.forta\n</code></pre> <p>This is the value that will be registered in the scan node registry smart contract (as <code>uint256</code>). If you need to find out your address later again, you can run <code>forta account address</code>.</p>"},{"location":"scanner-quickstart/#recovery","title":"Recovery","text":"<p>Not required for node setup</p> <p>If you have visited this documentation to set up your node, you can safely skip this Recovery section. Just keep in mind that it can save you time later to back up your config now.</p> <p>\"I lost my scan node data, now what?\"</p> <p>The scan node private key does not own or control the staked FORT.</p> <p>Losing the scan node private key will require you to dispose your old scan node and create a new one. This is as easy as disabling the lost scan node from your pool and registering a new one.</p> <ul> <li>Disable the lost node from your pool on https://app.forta.network.</li> <li>Do <code>forta init --passphrase &lt;your-passphrase&gt;</code> to initialize a new node.</li> <li>Now you have a new <code>~/.forta</code> directory with a new private key.</li> <li>Copy your backed up config to <code>~/.forta/config.yml</code> or configure that file from scratch.</li> <li>Register the scan node.</li> </ul>"},{"location":"scanner-quickstart/#configure-systemd","title":"Configure systemd","text":"<p>If <code>forta</code> ever stops running, it must be restarted. If you used a package installation method, there is a Forta systemd service that can be enabled and overridden with your passphrase and config directory environment variables.</p> <p>Please do not modify the original <code>forta.service</code> file and instead prefer the override recommended here. This is needed because the original file will be replaced next time you update <code>forta</code> through <code>yum</code> or <code>apt</code>.</p> <p>To override systemd service environment, you can set the variables in <code>/etc/systemd/system/forta.service.d/env.conf</code> like:</p> <pre><code>[Service]\nEnvironment=\"FORTA_DIR=&lt;your_forta_config_dir&gt;\"\nEnvironment=\"FORTA_PASSPHRASE=&lt;your_forta_passphrase&gt;\"\n</code></pre> <p>Alternative Systemd Override Path</p> <p>In our previous tests, it was confirmed that this approach works in Ubuntu, Debian, CentOS and Fedora. However, it has been reported by several node operators that it sometimes does not work as expected in some distributions. If you are not able to make this work using the suggested path above, you can try writing to <code>/lib/systemd/system/forta.service.d/env.conf</code> instead, as an alternative.</p>"},{"location":"scanner-quickstart/#configure-chain-apis","title":"Configure Chain APIs","text":"<p>In your Forta directory, there now is a <code>config.yml</code> file. You must configure that file so that your scan node knows how to get its blockchain data.</p> <p>Your scan node will be registered to scan a single chain. To let your scan node pull chain data, you need to provide a valid <code>scan.jsonRpc.url</code>.</p> <p>Public JSON-RPC APIs</p> <p>While there are public endpoints available for many chains,\u00a0please note that the quality of an endpoint drives the quality of a scan node's output which in turn affects rewards and slashing. We strongly recommend providing your own blockchain node or using Alchemy to setup your Forta node</p> <p>If you are scanning Ethereum mainnet, <code>trace.jsonRpc.url</code> must also be set as an endpoint that supports <code>trace_block</code> method. If you have your own Ethereum node that supports it (e.g. Erigon), you can use that node. If not, you can use an endpoint from a paid plan like Alchemy Growth plan.</p> <p>JSON-RPC APIs</p> <p>Detection bots are able to call JSON-RPC APIs using the scan node's configured endpoints. By default, this is the <code>scan.jsonRpc.url</code> but one can separate bot-specific traffic by specifying a <code>jsonRpcProxy.jsonRpc.url</code>. We suggest setting this as your own node's JSON-RPC API endpoint if you are running one. If you are not running a full node, you can use <code>scan.jsonRpc.url</code> to point the bots to another reliable API.</p> <p>Other chains</p> <p>If your node is scanning chains other than Ethereum mainnet, please checkout Scanning other chains section to see examples.</p>"},{"location":"scanner-quickstart/#http","title":"HTTP","text":"<p>Here is an example configuration to scan Ethereum mainnet using Alchemy Growth plan and HTTP endpoints:</p> <pre><code>chainId: 1\n\n# The scan settings are used to retrieve the transactions that are analyzed\nscan:\n  jsonRpc:\n    url: https://eth-mainnet.alchemyapi.io/v2/KEY\n\n# This is needed only for scanning Ethereum Mainnet and Fantom\ntrace:\n  jsonRpc:\n    url: https://eth-mainnet.alchemyapi.io/v2/KEY\n\n# Optional: Bots make extra requests to check the chain state. You can point\n# them to a different reliable API by using this. This defaults to `scan.jsonRpc.url`. \njsonRpcProxy:\n  jsonRpc:\n    url: http://different-api:8545\n</code></pre> <p>Another example configuration to scan Ethereum mainnet using your Erigon node's HTTP endpoint:</p> <pre><code>chainId: 1\n\nscan:\n  jsonRpc:\n    url: http://your-node:8545\n\ntrace:\n  jsonRpc:\n    url: http://your-node:8545\n\n# Defaulting to `scan.jsonRpc.url` if not set - the best option when running a node\n# jsonRpcProxy:\n#   jsonRpc:\n#     url: http://your-node:8545\n</code></pre>"},{"location":"scanner-quickstart/#websocket","title":"WebSocket","text":"<p>If you have a WebSocket endpoint available from your full node or from your JSON-RPC provider (e.g. Alchemy), you can use that endpoint as <code>scan.jsonRpc.url</code>. This will ensure that your node will always fetch the latest block as fast as possible.</p> <p>Notifications</p> <p>The WebSocket endpoint needs to support block header notifications. Please check <code>docker logs forta-scanner -f</code> output to see any issues after starting the node.</p> <p>Proxy</p> <p>If you set the scan API as a WebSocket endpoint, please set <code>jsonRpcProxy.jsonRpc.url</code> as an HTTP JSON-RPC API. Your node may get a low score if you skip this!</p> <p>Example:</p> <pre><code>chainId: 1\n\nscan:\n  jsonRpc:\n    url: wss://&lt;websocket-api&gt;\n\ntrace:\n  jsonRpc:\n    url: wss://&lt;websocket-api&gt;\n\njsonRpcProxy:\n  jsonRpc:\n    url: https://&lt;http-api&gt;\n</code></pre>"},{"location":"scanner-quickstart/#retries","title":"Retries","text":"<p>The block feed in the node always retries any request whenever <code>eth_getBlockByNumber</code>, <code>eth_getLogs</code> or <code>trace_block</code> does not work. The default retry interval is 8 seconds. While this is a sufficient retry interval on average for all chains, you can reduce this interval so your node catches up faster.</p> <p>Effect to score</p> <p>Reducing the retry interval can help you achieve a higher SLA score in case you have any concerns about your node's current score. Please keep in mind that small retry intervals can cause a bump in the amount of total requests because of the increase in the amount of retries.</p> <p>To reduce the retry interval to two seconds, you can add <code>retryIntervalSeconds</code> to the scan section of your config like:</p> <pre><code>scan:\n  retryIntervalSeconds: 2\n</code></pre>"},{"location":"scanner-quickstart/#configure-registry-api","title":"Configure Registry API","text":"<p>Warning</p> <p>Quality of this API is as important as the rest of the APIs configured for scanning.</p> <p>There are a set of Forta smart contracts on Polygon, which allows finding out:</p> <ul> <li>the latest list of bots which a scan node should run</li> <li>the latest Forta node service Docker image release</li> </ul> <p>All Forta nodes are expected to run with the latest release and the latest list of the assigned bots. To be able to read these values, Forta nodes use <code>https://rpc.ankr.com/polygon</code> by default but this API can rate-limit your node. Please consider changing this to a free Polygon API with high availability, e.g. Alchemy Polygon API, Chainstack Polygon API, by adding the following configuration:</p> <pre><code>registry:\n  jsonRpc:\n    url: https://polygon-mainnet.g.alchemy.com/v2/&lt;your-alchemy-api-key&gt;\n</code></pre>"},{"location":"scanner-quickstart/#custom-telemetry-optional","title":"Custom Telemetry (Optional)","text":"<p>You can specify a custom telemetry handler in the <code>config.yml</code> file if you would like to receive health reports from your nodes regularly:</p> <pre><code>telemetry:\n  customUrl: http://my.telemetry.data.handler.url\n</code></pre> <p>The forwarded content is a gzipped JSON which is similar to the <code>forta status --format json</code> output.</p> <pre><code>[\n  ...\n  {\n    \"name\": \"forta.container.forta-scanner.service.agent-pool.agents.total\",\n    \"status\": \"ok\",\n    \"details\": \"14\"\n  },\n  {\n    \"name\": \"forta.container.forta-scanner.service.block-analyzer.event.input.time\",\n    \"status\": \"ok\",\n    \"details\": \"2022-08-17T10:36:20Z\"\n  },\n  {\n    \"name\": \"forta.container.forta-scanner.service.block-analyzer.event.output.time\",\n    \"status\": \"ok\",\n    \"details\": \"2022-08-17T10:36:20Z\"\n  },\n  {\n    \"name\": \"forta.container.forta-scanner.service.block-feed.last-block\",\n    \"status\": \"info\",\n    \"details\": \"15358230\"\n  }\n  ...\n]\n</code></pre>"},{"location":"scanner-quickstart/#keep-your-node-up-to-date","title":"Keep Your Node Up-To-Date","text":""},{"location":"scanner-quickstart/#deprecation","title":"Deprecation","text":"<p>All nodes need to start running the latest container versions within 7 days after the latest release, by default. The releases made on GitHub may contain a release config that overrides the version support and reduces the deprecation time:</p> <pre><code># @begin release_config\ndeprecationPolicy:\n  supportedVersions:\n    - v0.7.9\n  activatesInHours: 72\n# @end release_config\n</code></pre> <p>The nodes which run unallowed versions may receive a low SLA score.</p>"},{"location":"scanner-quickstart/#auto-updates","title":"Auto-updates","text":"<p>To help you in this process, the node software includes an auto-updater that detects new container images, pulls, stops old containers and starts new containers.</p> <p>In order to ensure that this feature works at all times, please set the registry API to a reliable one, as suggested in the Configure Registry API section.</p> <p>Each node updates at a specific time within 24 hours, unless overridden by the config in the release made on GitHub: <pre><code># @begin release_config\nautoUpdateInHours: 6\n# @end release_config\n</code></pre></p> <p>To receive the container update without stopping the bots and updating the CLI, please do <pre><code>$ docker kill forta-updater\n</code></pre> and the updater container will pick up the latest release when it is started again.</p> <p>Manual Update</p> <p>You need manual update through APT or YUM only if you need to receive the latest CLI features. As in the above example, CLI of an older version is able to successfully run the service container image of the newer version.</p> <p>To disable the auto-update behavior, you can add this to your config:</p> <pre><code>autoUpdate:\n  disable: true\n</code></pre> <p>Disabling Auto-Updates</p> <p>Disabling this feature is strongly discouraged. Not following the latest version can cause loss of rewards.</p>"},{"location":"scanner-quickstart/#check-the-running-version","title":"Check the running version","text":"<p>Starting with v0.7.10, <code>forta version</code> outputs the CLI and container version separately. While using the CLI from versions provides a better experience, it is only necessary to have the latest container version.</p> <p>Example output:</p> <pre><code>$ forta version\n{\n  \"cli\": {\n    \"commit\": \"ef621ff8cf9e467e021630a6c0367214883e1130\",\n    \"ipfs\": \"QmbnNB1iyrNthzSptqxXkdz4RHfU3g5Y7QesLhbmv5xrF2\",\n    \"version\": \"v0.1.2\"\n  },\n  \"containers\": {\n    \"commit\": \"ef621ff8cf9e467e021630a6c0367214883e1130\",\n    \"ipfs\": \"QmbnNB1iyrNthzSptqxXkdz4RHfU3g5Y7QesLhbmv5xrF2\",\n    \"version\": \"v0.2.3\"\n  }\n}\n</code></pre> <p>Container version will be visible after running the node in the following steps.</p>"},{"location":"scanner-quickstart/#register-scan-node","title":"Register Scan Node","text":"<p>Your scan node has an Ethereum address that makes some features possible:</p> <ul> <li>Receiving detection bots to run</li> <li>Asserting authority on the outputted alerts</li> <li>Identification for rewards and slashing</li> </ul> <p>The private key for the scan node is generated at the <code>forta init</code> step. Please prefer continuing with this private key and do not replace it with your custom private key in order to avoid confusion and security risks.</p> <p>Make sure you have set the <code>chainId</code> in your config.yml correctly before registering your node. Your scan node can be registered only once and to scan a specific chain.</p> <p>You can register your node by</p> <ul> <li>doing <code>forta authorize pool --passphrase &lt;your-passphrase&gt; --id &lt;your-pool-id&gt;</code>,</li> <li>copying the token over to Forta App as described in the scanner pool management page of the docs.</li> </ul> <p>Alternatively, you can</p> <ul> <li>do <code>forta authorize pool --passphrase &lt;your-passphrase&gt; --id &lt;your-pool-id&gt; --polygonscan</code>,</li> <li>visit the <code>registerScannerNode</code> method,</li> <li>click on \"Connect to Web3\" on the top and connect your wallet,</li> <li>copy the values from the first step, click on \"Write\".</li> </ul>"},{"location":"scanner-quickstart/#stake-fort","title":"Stake FORT","text":"<p>To ensure network reliablity, Forta Network requires staking FORT tokens on your node. You can follow the guide in the Manage pools and stake page to find out how to manage stake for nodes.</p> <p>All pools require stake</p> <p>Scan nodes in the unstaked or understaked pools will not be assigned any detection bots and will not generate any rewards.</p> <p>Forta Network makes good use of the stake by enforcing two main mechanisms:</p> <ul> <li>Rewarding: Node operators are incentivized with rewards to ensure that their Forta nodes are running with good health and as expected.</li> <li>Slashing: Node operators are discouraged from harmful actions. Upon detection, they lose rewards and a specific portion is removed from the deposited pool stake. This can cause the staked amount to go under minimum required and all nodes in the pool to enter into disabled state.</li> </ul>"},{"location":"scanner-quickstart/#run-scan-node","title":"Run Scan Node","text":""},{"location":"scanner-quickstart/#start-docker","title":"Start Docker","text":"<p>Ensure Docker is running use the docker command <code>docker ps</code>.  If it is not running, start docker before running Forta.</p>"},{"location":"scanner-quickstart/#start-forta-via-systemd","title":"Start Forta via systemd","text":"<p>Run the systemd service to start Forta</p> <pre><code>sudo systemctl daemon-reload\nsudo systemctl enable forta\nsudo systemctl start forta\n</code></pre>"},{"location":"scanner-quickstart/#start-forta-manually","title":"Start Forta manually","text":"<p>Run the <code>forta run</code> command to start processing blocks.</p> <pre><code>$ forta run --passphrase &lt;your_passphrase&gt;\n</code></pre>"},{"location":"scanner-quickstart/#verify-execution","title":"Verify Execution","text":"<p>Run <code>forta status</code> command to see how your scanner is doing. As more services start, this status output will be dynamically updated. If you see any yellows or reds, please check the error messages, your config and your machine's network connectivity. If you can't make any sense of it, please let us know.</p> <p>You can also view the forta-scanner logs for batches of alerts.</p> <pre><code>$ docker logs -f forta-scanner\n</code></pre> <p>Bot Assignments</p> <p>Your scan node might not have any bots assigned.  This is okay.  As bots are added to the network, the network will assign bots to your node.</p> <p>To see a list of bots that the node is running, use this command.</p> <pre><code>$ docker ps | grep forta-agent\n</code></pre>"},{"location":"scanner-quickstart/#scanning-other-chains","title":"Scanning other chains","text":"<p>It's best to use your own full node for scanning. If you don't have a node, here are some API alternatives that you can use:</p>"},{"location":"scanner-quickstart/#bsc","title":"BSC","text":"<p>You can choose from public BSC endpoints at https://docs.binance.org/smart-chain/developer/rpc.html.</p> <pre><code>chainId: 56\n\nscan:\n  jsonRpc:\n    url: https://bsc-dataseed.binance.org/\n\ntrace:\n  enabled: false\n</code></pre>"},{"location":"scanner-quickstart/#polygon","title":"Polygon","text":"<pre><code>chainId: 137\n\nscan:\n  jsonRpc:\n    url: https://polygon-rpc.com/\n\ntrace:\n  enabled: false\n</code></pre>"},{"location":"scanner-quickstart/#avalanche","title":"Avalanche","text":"<pre><code>chainId: 43114\n\nscan:\n  jsonRpc:\n    url: https://api.avax.network/ext/bc/C/rpc\n\ntrace:\n  enabled: false\n</code></pre>"},{"location":"scanner-quickstart/#arbitrum","title":"Arbitrum","text":"<pre><code>chainId: 42161\n\nscan:\n  jsonRpc:\n    url: https://arb1.arbitrum.io/rpc\n\ntrace:\n  enabled: false\n</code></pre>"},{"location":"scanner-quickstart/#optimism","title":"Optimism","text":"<pre><code>chainId: 10\n\nscan:\n  jsonRpc:\n    url: https://mainnet.optimism.io\n\ntrace:\n  enabled: false\n</code></pre>"},{"location":"scanner-quickstart/#fantom","title":"Fantom","text":"<pre><code>chainId: 250\n\nscan:\n  jsonRpc:\n    url: https://rpc.ftm.tools/\n\ntrace:\n  jsonRpc:\n    url: https://rpcapi-tracing.fantom.network/\n</code></pre>"},{"location":"scanner-quickstart/#monitor-sla","title":"Monitor SLA","text":"<p>To view your scan node's uptime and SLA simply copy and paste https://app.forta.network/scan-node/[YOUR SCAN NODE ADDRESS] into your browser's search bar.</p> <p></p> <p>For more detailed insights, use the SLA-API</p>"},{"location":"scanner-quickstart/#the-merge","title":"The Merge","text":"<p>Only for Ethereum Mainnet</p> <p>This section was prepared only for Forta node operators who would like to point their Forta nodes to their own Ethereum Mainnet nodes. If your Forta node is scanning chains other than Ethereum Mainnet, you can safely ignore this section altogether.</p> <p>To prepare for The Merge, your Erigon node (Execution Layer - EL) will need to be run with a beacon node (Consensus Layer - CL). Few consensus layer clients are listed below:</p> <ul> <li>Prysm</li> <li>Lighthouse</li> <li>Lodestar</li> <li>Nimbus</li> <li>Teku</li> </ul> <p>For more information on versions of these clients, please see the Ethereum Merge announcement blog post. Make sure to upgrade your clients to these versions before September 6</p> <p>You can run consensus layer client on the same machine as the execution layer client (Erigon) by default Erigon's engine API listens on localhost. If you are running CL client on a different machine than Erigon, you will need to configure the Erigon node to connect to the CL client by passing <code>--authrpc.addr 0.0.0.0</code> and <code>--authrpc.vhosts &lt;CL host&gt;</code>.</p>"},{"location":"scanner-quickstart/#erigon-node-execution-layer-client","title":"Erigon node (execution layer client)","text":"<p>Upgrade your node to the latest \"stable\" version of Erigon <code>2022.08.03-alpha</code>.</p> <p>If you are running Erigon directly from the binary (and not using docker-compose), you will need to pass <code>--authrpc.jwtsecret &lt;secret&gt;</code>. For more information see Erigon documentation.</p> <p>If you are running Erigon using docker-compose, you don't have to pass any extra flags for data dir or JWT secret since these are already configured in the docker-compose file.</p>"},{"location":"scanner-quickstart/#prysm-consensus-layer-client","title":"Prysm (consensus layer client)","text":"<p>Upgrade your node to the latest \"stable\" version of Prysm <code>v3.0.0</code>.</p>"},{"location":"scanner-quickstart/#use-docker","title":"Use Docker","text":"<p>You can install Prysm and run a beacon node using Docker by following Prysm Docker.</p> <p>Architecture Constraints</p> <p>Running with docker might not work on Linux ARM64.</p>"},{"location":"scanner-quickstart/#install-binary","title":"Install binary","text":"<p>Alternatively, you can install Prysm directly by downloading the Prysm client binary and make it executable.</p> <p>You can run your beacon node with the following commands:</p> <pre><code>mkdir prysm &amp;&amp; cd prysm\n\ncurl https://raw.githubusercontent.com/prysmaticlabs/prysm/master/prysm.sh \\\n  --output prysm.sh &amp;&amp;\\ \n  chmod +x prysm.sh\n</code></pre>"},{"location":"scanner-quickstart/#follow-installation-docs","title":"Follow installation docs","text":"<p>As yet another option, you can run a beacon node using Prysm by following Prysm Beacon Node.</p> <p>You will need to pass <code>--jwt-secret=&lt;path_to_erigon_jwt_hex&gt;</code> to the beacon node. It doesn't require <code>--suggested-fee-recipient</code> flag unless you are running a validator.</p> <p>Additionally, you can pass the <code>--slots-per-archive-point</code> flag to the beacon node. A lower number helps improve the CL API performance while increasing the storage cost. For more information on slots per archive point, please refer to Run an archival node section in Prysm docs.</p> <p>After running with any method mentioned above, you should be able to see the beacon node running and syncing. This usually takes a couple days, but it can take longer depending on your network and hardware specs.</p>"},{"location":"sdk/","title":"Javascript/Typescript SDK","text":"<p>The Forta bot Javascript SDK comes with a set of classes and type definitions to provide a consistent interface for developers to write their bots. There are also some utility functions available for your convenience to do common operations like searching for an event in the transaction logs. Check out the Javascript/Typescript bots in our examples repo to learn more.</p>"},{"location":"sdk/#handlers","title":"Handlers","text":"<p>The most relevant type definitions for bot developers are the handler types: <code>Initialize</code>, <code>HandleBlock</code>, <code>HandleTransaction</code> and <code>HandleAlert</code>. They are function types with the following signatures:</p> <pre><code>type Initialize = () =&gt; Promise&lt;void | InitializeResponse&gt;\ntype HandleTransaction = (txEvent: TransactionEvent) =&gt; Promise&lt;Finding[]&gt;\ntype HandleBlock = (blockEvent: BlockEvent) =&gt; Promise&lt;Finding[]&gt;\ntype HandleAlert = (alertEvent: AlertEvent) =&gt; Promise&lt;Finding[]&gt;\n</code></pre> <p>Your <code>agent.js</code>/<code>agent.ts</code> file must have a default export object with at least one of <code>handleBlock</code>, <code>handleTransaction</code> or <code>handleAlert</code> properties that provide the handler functions. You can export one or all of these depending on your use case, but at least one must be provided. The return type of these functions is <code>Promise&lt;Finding[]&gt;</code>, meaning they are asynchronous functions that return an array of zero or more <code>Finding</code> objects.</p> <p>You can also optionally export an <code>initialize</code> handler that will be executed on bot startup. This is useful for fetching some data from the network or parsing some file before your bot begins. If you are using the <code>handleAlert</code> handler, then the <code>initialize</code> handler is required to specify which bot's alerts you want to subscribe to. The returned object in this case would be of the type <code>InitializeResponse</code> (see the pattern for consuming bot alerts for more information). If you don't want to subscribe to any bot alerts, don't return anything i.e. <code>void</code>.</p>"},{"location":"sdk/#blockevent","title":"BlockEvent","text":"<p>When a block is mined and detected by a Forta scan node, it will generate a <code>BlockEvent</code> containing information such as the block hash and block number. It contains the following fields:</p> <ul> <li><code>type</code> - specifies whether this was a block reorg or a regular block</li> <li><code>network</code> - specifies which network the block was mined on (e.g. mainnet, ropsten, rinkeby, etc)</li> <li><code>blockHash</code> - hash of the block</li> <li><code>blockNumber</code> - number of the block</li> <li><code>block</code> - data object containing the following fields:<ul> <li><code>difficulty</code></li> <li><code>extraData</code></li> <li><code>gasLimit</code></li> <li><code>gasUsed</code></li> <li><code>hash</code></li> <li><code>logsBloom</code></li> <li><code>miner</code></li> <li><code>mixHash</code></li> <li><code>nonce</code></li> <li><code>number</code></li> <li><code>parentHash</code></li> <li><code>receiptsRoot</code></li> <li><code>sha3Uncles</code></li> <li><code>size</code></li> <li><code>stateRoot</code></li> <li><code>timestamp</code></li> <li><code>totalDifficulty</code></li> <li><code>transactions</code></li> <li><code>transactionsRoot</code></li> <li><code>uncles</code></li> </ul> </li> </ul>"},{"location":"sdk/#transactionevent","title":"TransactionEvent","text":"<p>When a transaction is mined and detected by a Forta scan node, it will generate a <code>TransactionEvent</code> containing various information about the transaction. It contains the following fields:</p> <ul> <li><code>type</code> - specifies whether this was from a block reorg or a regular block</li> <li><code>network</code> - specifies which network the transaction was mined on (e.g. mainnet, ropsten, rinkeby, etc)</li> <li><code>hash</code> - alias for <code>transaction.hash</code></li> <li><code>from</code> - alias for <code>transaction.from</code></li> <li><code>to</code> - alias for <code>transaction.to</code></li> <li><code>gasPrice</code> - alias for <code>transaction.gasPrice</code></li> <li><code>timestamp</code> - alias for <code>block.timestamp</code></li> <li><code>blockNumber</code> - alias for <code>block.number</code></li> <li><code>blockHash</code> - alias for <code>block.hash</code></li> <li><code>addresses</code> - map of addresses involved in the transaction (generated from transaction to/from address, any event log address and trace data address if available)</li> <li><code>block</code> - data object containing the following fields:<ul> <li><code>hash</code></li> <li><code>number</code></li> <li><code>timestamp</code></li> </ul> </li> <li><code>transaction</code> - data object containing the following fields:<ul> <li><code>hash</code></li> <li><code>from</code></li> <li><code>to</code></li> <li><code>nonce</code></li> <li><code>gas</code></li> <li><code>gasPrice</code></li> <li><code>value</code></li> <li><code>data</code></li> <li><code>r</code></li> <li><code>s</code></li> <li><code>v</code></li> </ul> </li> <li><code>logs</code> - list of log objects with the following fields:<ul> <li><code>address</code></li> <li><code>topics</code></li> <li><code>data</code></li> <li><code>logIndex</code></li> <li><code>blockNumber</code></li> <li><code>blockHash</code></li> <li><code>transactionIndex</code></li> <li><code>transactionHash</code></li> <li><code>removed</code></li> </ul> </li> <li><code>traces</code> - only with tracing enabled; list of trace objects with the following fields:<ul> <li><code>blockHash</code></li> <li><code>blockNumber</code></li> <li><code>subtraces</code></li> <li><code>traceAddress</code></li> <li><code>transactionHash</code></li> <li><code>transactionPosition</code></li> <li><code>type</code></li> <li><code>error</code></li> <li><code>action</code> - object with the following fields:<ul> <li><code>callType</code></li> <li><code>to</code></li> <li><code>from</code></li> <li><code>input</code></li> <li><code>value</code></li> <li><code>init</code></li> <li><code>address</code></li> <li><code>balance</code></li> <li><code>refundAddress</code></li> </ul> </li> <li><code>result</code> - object with the following fields:<ul> <li><code>gasUsed</code></li> <li><code>address</code></li> <li><code>code</code></li> <li><code>output</code></li> </ul> </li> </ul> </li> </ul>"},{"location":"sdk/#filterlog","title":"filterLog","text":"<p><code>filterLog</code> is a convenience function on <code>TransactionEvent</code> to filter and decode transaction logs. For example, you can use it to get all of the Transfer logs in a transaction from a particular ERC-20 token:</p> <pre><code>const erc20TokenAddress = \"0x123abc\";\nconst transferEvent = \"event Transfer(address indexed from, address indexed to, uint256 value)\";\nconst transfers = transactionEvent.filterLog(transferEvent, erc20TokenAddress);\nconsole.log(`found ${transfers.length} transfer events`);\n</code></pre> <p>The underlying library used for decoding event logs is ethers.js. The Javascript SDK uses the ethers.js <code>parseLog</code> method and returns an array of <code>LogDescription</code> objects (which we modified to also include the originating <code>address</code> of the log). To better understand usage, see the Javascript filtering example bot.</p>"},{"location":"sdk/#filterfunction","title":"filterFunction","text":"<p><code>filterFunction</code> is a convenience function on <code>TransactionEvent</code> to filter and decode function calls in the transaction or traces. For example, you can use it to get all of the transferFrom function calls on a particular ERC-20 token:</p> <pre><code>const erc20TokenAddress = \"0x123abc\";\nconst transferFromFunction = \"function transferFrom(address from, address to, uint value)\";\nconst transfers = transactionEvent.filterFunction(transferFromFunction, erc20TokenAddress);\nconsole.log(`found ${transfers.length} function calls`);\n</code></pre> <p>The underlying library used for decoding function calls is ethers.js. The Javascript SDK uses the ethers.js <code>parseTransaction</code> method and returns an array of <code>TransactionDescription</code> objects. To better understand usage, see the Javascript filtering example bot.</p>"},{"location":"sdk/#alertevent","title":"AlertEvent","text":"<p>When an alert is fired from a Forta bot and is detected by the network, any subscribing bots will receive an <code>AlertEvent</code> containing various information about the alert (see the pattern for consuming bot alerts for more information). It contains the following fields:</p> <ul> <li><code>alert</code> - data object containing an Alert</li> <li><code>alertId</code> - alias for <code>alert.alertId</code></li> <li><code>name</code> - alias for <code>alert.name</code></li> <li><code>hash</code> - alias for <code>alert.hash</code></li> <li><code>botId</code> - alias for <code>alert.source.bot.id</code></li> <li><code>transactionHash</code> - alias for <code>alert.source.transactionHash</code></li> <li><code>blockHash</code> - alias for <code>alert.source.block.hash</code></li> <li><code>blockNumber</code> - alias for <code>alert.source.block.number</code></li> <li><code>chainId</code> - alias for <code>alert.chainId</code></li> <li><code>hasAddress</code> - alias function for <code>alert.hasAddress</code></li> </ul>"},{"location":"sdk/#finding","title":"Finding","text":"<p>If a bot wants to flag a transaction/block/alert because it meets some condition (e.g. flash loan attack), the handler function would return a <code>Finding</code> object. This object would detail the results of the finding and provide metadata such as the severity of the finding. A <code>Finding</code> object can only be created using the <code>Finding.fromObject</code> method which accepts the following properties:</p> <ul> <li><code>name</code> - required; human-readable name of finding e.g. \"High Gas\"</li> <li><code>description</code> - required; brief description e.g. \"High gas used: 1,000,000\"</li> <li><code>alertId</code> - required; unique string to identify this class of finding, primarily used to group similar findings for the end user</li> <li><code>protocol</code> - required; name of the protocol being reported on e.g. \"aave\", defaults to \"ethereum\" if left blank</li> <li><code>type</code> - required; indicates the type of finding:<ul> <li>Exploit</li> <li>Suspicious</li> <li>Degraded</li> <li>Info</li> </ul> </li> <li><code>severity</code> - required; indicates the impact level of finding:<ul> <li>Critical - exploitable vulnerabilities, massive impact on users/funds</li> <li>High - exploitable under more specific conditions, significant impact on users/funds</li> <li>Medium - notable unexpected behaviours, moderate to low impact on users/funds</li> <li>Low - minor oversights, negligible impact on users/funds</li> <li>Info - miscellaneous behaviours worth describing</li> </ul> </li> <li><code>metadata</code> - optional; key-value map (both keys and values as strings) for providing extra information</li> <li><code>labels</code> - optional; array of <code>Label</code> objects to attach to this finding</li> </ul>"},{"location":"sdk/#alert","title":"Alert","text":"<p>When an <code>Alert</code> is fired by a Forta bot, it can be consumed using an AlertEvent or manually queried using the <code>getAlerts</code> method. <code>Alert</code> objects have the following properties:</p> <ul> <li><code>alertId</code> -  string to identify this class of finding</li> <li><code>chainId</code> - chain ID where this alert was fired</li> <li><code>addresses</code> -  list of addresses involved in the alert (currently truncated at 50 addresses)</li> <li><code>labels</code> - list of Labels associated to the alert</li> <li><code>contracts</code> -  list of contracts related to the alert</li> <li><code>createdAt</code> -  timestamp when the alert was published</li> <li><code>description</code> - text description of the alert</li> <li><code>name</code> - alert name</li> <li><code>protocol</code> - name of the protocol being reported on</li> <li><code>scanNodeCount</code> - number of scanners that found the alert</li> <li><code>source</code> - source where the alert was detected<ul> <li><code>transactionHash</code> - transaction where the alert was detected</li> <li><code>block</code> - block where the alert was detected<ul> <li><code>timestamp</code></li> <li><code>chainId</code></li> <li><code>hash</code></li> <li><code>number</code></li> </ul> </li> <li><code>bot</code> - bot that triggered the alert<ul> <li><code>id</code></li> <li><code>reference</code></li> <li><code>image</code></li> </ul> </li> <li><code>sourceAlert</code> - alert that triggered this alert<ul> <li><code>hash</code></li> <li><code>botId</code></li> <li><code>timestamp</code></li> <li><code>chainId</code></li> </ul> </li> </ul> </li> <li><code>projects</code> - list of Web3 projects related to the alert<ul> <li><code>contacts</code> - list of contact info</li> <li><code>id</code> - project identifier</li> <li><code>name</code> - user-friendly name of the project</li> <li><code>token</code></li> <li><code>social</code></li> <li><code>website</code> - main website of the project</li> </ul> </li> <li><code>findingType</code> -  indicates the type of finding:<ul> <li>Exploit</li> <li>Suspicious</li> <li>Degraded</li> <li>Info</li> <li>Unknown</li> </ul> </li> <li><code>severity</code> - indicates the impact level of finding:<ul> <li>Critical - exploitable vulnerabilities, massive impact on users/funds</li> <li>High - exploitable under more specific conditions, significant impact on users/funds</li> <li>Medium - notable unexpected behaviours, moderate to low impact on users/funds</li> <li>Low - minor oversights, negligible impact on users/funds</li> <li>Info - miscellaneous behaviours worth describing</li> </ul> </li> <li><code>metadata</code> - key-value map (both keys and values as strings) for providing extra information</li> </ul>"},{"location":"sdk/#hasaddress","title":"hasAddress","text":"<p><code>hasAddress</code> is a convenience function on <code>Alert</code> meant for checking the existence of an address involved in the alert. The <code>addresses</code> array is truncated for space efficiency, so this method uses a bloom filter to check for existence. It accepts a single string parameter: the address to check</p>"},{"location":"sdk/#label","title":"Label","text":"<p>Labels can be used to add more contextual data to a <code>Finding</code> e.g. \"is this address an attacker?\". The <code>Label</code> object has the following properties:</p> <ul> <li><code>id</code> - string identifier of this label</li> <li><code>entityType</code> - enum indicating the type of entity:<ul> <li><code>Address</code></li> <li><code>Transaction</code></li> <li><code>Block</code></li> <li><code>Url</code></li> <li><code>Unknown</code></li> </ul> </li> <li><code>entity</code> - string identifier of the entity being labelled e.g. transaction hash</li> <li><code>label</code> - string label to attach to the entity e.g. \"exploit\"</li> <li><code>confidence</code> - confidence level of label between 0 and 1</li> <li><code>metadata</code> - key-value map (both keys and values as strings) for providing extra information</li> <li><code>createdAt</code> - string containing the timestamp of label creation</li> <li><code>source</code> - object with information about where this label came from<ul> <li><code>alertHash</code></li> <li><code>alertId</code></li> <li><code>id</code></li> <li><code>chainId</code></li> <li><code>bot</code><ul> <li><code>id</code></li> <li><code>image</code></li> <li><code>imageHash</code></li> <li><code>manifest</code></li> </ul> </li> </ul> </li> </ul>"},{"location":"sdk/#getjsonrpcurl","title":"getJsonRpcUrl","text":"<p>A convenience function called <code>getJsonRpcUrl</code> can be used to load a JSON-RPC URL for your bot. When running in production, this function will return a URL injected by the scan node that is running the bot. When running locally in development, this function will return the <code>jsonRpcUrl</code> property specified in your forta.config.json file (or <code>https://cloudflare-eth.com/</code> by default).</p>"},{"location":"sdk/#getethersprovider","title":"getEthersProvider","text":"<p><code>getEthersProvider</code> is a convenience function that returns an ethers.js Provider which can be used to interact with the blockchain. The value from <code>getJsonRpcUrl</code> will be used as the JSON-RPC endpoint to connect to.</p>"},{"location":"sdk/#gettransactionreceipt","title":"getTransactionReceipt","text":"<p>A convenience function called <code>getTransactionReceipt</code> can be used to fetch the entire receipt of a transaction and is returned in a format matching the SDK <code>Receipt</code> interface.</p>"},{"location":"sdk/#getalerts","title":"getAlerts","text":"<p>The <code>getAlerts</code> method can be used to fetch alerts based on input <code>AlertQueryOptions</code>. When developing locally, you will need to set the <code>fortaApiKey</code> property in your forta.config.json (and also have a paid plan) for this method to work. The <code>getAlerts</code> method accepts the following input filter properties:</p> <ul> <li><code>botIds</code> required; list of bot ids to fetch alerts for</li> <li><code>addresses</code> -  indicate a list of addresses, alerts returned will have those addresses involved.</li> <li><code>alertId</code> - filter alerts by alert-id</li> <li><code>chainId</code> - EIP155 identifier of the chain alerts returned will only be from the specific chain Id Default is 1 = Ethereum Mainnet</li> <li><code>createdSince</code> - indicate number of milliseconds, alerts returned will be alerts created since the number of milliseconds indicated ago (note: if not specified, the query will only search the past 24 hours)</li> <li><code>first</code> - indicates max number of results.</li> <li><code>startingCursor</code> - query results after the specified cursor</li> <li><code>projectId</code> - indicates a project id, alerts returned will only be from that project.</li> <li><code>scanNodeConfirmations</code> - filter alerts by number of scan nodes confirming the alert</li> <li><code>severities</code> - filter alerts by severity levels</li> <li><code>transactionHash</code> - indicates a transaction hash, alerts returned will only be from that transaction</li> <li><code>blockSortDirection</code> - indicates sorting order by block number, 'desc' or 'asc'. The default is 'desc'.</li> <li><code>blockDateRange</code> - alerts returned will be between the specified start and end block timestamp dates when the threats were detected</li> <li><code>blockNumberRange</code> - alerts for the block number range will be returned</li> </ul> <p>The returned alerts are formatted to match the SDK <code>AlertsResponse</code> interface which looks like this:</p> <pre><code>{\n    alerts: Alert[],\n    pageInfo: {\n        hasNextPage: boolean,\n        endCursor?: {\n            alertId: string,\n            blockNumber: number\n        }\n    }\n}\n</code></pre> <p>Here is an example usage:</p> <pre><code>import { getAlerts, AlertsResponse } from \"forta-agent\"\n\nconst main = async () =&gt; {\n  let hasNext = true;\n  let startingCursor = undefined;\n\n  while(hasNext) {\n    const results: AlertsResponse = await getAlerts({\n      botIds: [\"0xddb7c17e370ecd5f99cadcddb39cfa51264e989c5133c490046d63a299dd68f0\"], \n      transactionHash: \"0xc65af85a3fab1e538f6f521cd0a6e6d246c2f76c05aa8fba40817b59de7401b6\",\n      startingCursor\n    })\n\n    hasNext = results.pageInfo.hasNextPage;\n    startingCursor = results.pageInfo.endCursor;\n\n    results.alerts.forEach(a =&gt; console.log(`${JSON.stringify(a)} \\n`))\n  }\n}\nmain();\n</code></pre>"},{"location":"sdk/#sendalerts","title":"sendAlerts","text":"<p>The <code>sendAlerts</code> method enables submitting alerts via the GraphQL API. See the external bots page for more information.</p>"},{"location":"sdk/#getlabels","title":"getLabels","text":"<p>The <code>getLabels</code> method can be used to fetch labels based on input <code>LabelQueryOptions</code>. When developing locally, you will need to set the <code>fortaApiKey</code> property in your forta.config.json (and also have a paid plan) for this method to work. The <code>getLabels</code> method accepts the following input filter properties (at least one of <code>entities</code>, <code>labels</code> or <code>sourceIds</code> is required):</p> <ul> <li><code>entities</code> - string array to filter by label entities (e.g. wallet addresses, block/tx hashes)</li> <li><code>labels</code> - string array to filter the label value (e.g. \"attacker\")</li> <li><code>sourceIds</code> - string array to filter the label sources (e.g. bot IDs)</li> <li><code>entityType</code> - string to filter labels by <code>EntityType</code> (see label section for possible types)</li> <li><code>state</code> - boolean, set to <code>true</code> if only the current state is desired</li> <li><code>createdSince</code> - integer timestamp in milliseconds, labels returns will be created after this timestamp</li> <li><code>createdBefore</code> - integer timestamp in milliseconds, labels returned will be created before this timestamp</li> <li><code>first</code> - integer indicating max number of results</li> <li><code>startingCursor</code> - query results after the specified cursor object</li> </ul> <p>The returned labels are formatted to match the SDK <code>LabelsResponse</code> interface which looks like:</p> <pre><code>{\n    labels: Label[];\n    pageInfo: {\n        hasNextPage: boolean;\n        endCursor?: {\n            pageToken: string;\n        };\n    };\n}\n</code></pre> <p>Here is an example usage:</p> <pre><code>import { getLabels, LabelsResponse } from \"forta-agent\"\n\nconst main = async () =&gt; {\n  let hasNext = true;\n  let startingCursor = undefined;\n\n  while(hasNext) {\n    const results: LabelsResponse = await getLabels({\n      sourceIds: [\"0xddb7c17e370ecd5f99cadcddb39cfa51264e989c5133c490046d63a299dd68f0\"],\n      createdSince: 1684407014000,\n      startingCursor\n    })\n\n    hasNext = results.pageInfo.hasNextPage;\n    startingCursor = results.pageInfo.endCursor;\n\n    results.labels.forEach(l =&gt; console.log(`${JSON.stringify(l)} \\n`))\n  }\n}\nmain();\n</code></pre>"},{"location":"sdk/#fetchjwt","title":"fetchJwt","text":"<p>Scan nodes allow bots to make authorized requests to external APIs by using the scan node's identity, without letting the scan node modify the requests. You can use the <code>fetchJwt</code> utility function to generate a jwt token from a scan node.</p> <p>This method will only generate a token if the bot is running on a scan node</p> <p>If running a bot locally or in a stand-alone environment (ie. outside of a scanner node), this method will return a mock value.</p> <p>The function signature is <code>fetchJwt(claims, expiresAt)</code>:</p> <ul> <li><code>claims</code>:  a JSON object of any additional claims you would like to include in the payload of the JWT</li> <li><code>expiresAt</code>:  an optional <code>Date</code> object that sets when the JWT will expire</li> </ul> <p>The returned JWT can be decoded using the <code>decodeJwt</code> method.</p> <pre><code>let token;\n\nconst initialize: Initialize = async (blockEvent: BlockEvent) =&gt; {\n  token = await fetchJwt(claims: {key: value})\n  ...\n}\n</code></pre>"},{"location":"sdk/#verifyjwt","title":"verifyJwt","text":"<p>A utility method intended to be used on an external server for verifying the claims and signature of a JWT generated by a scan node. This method verifies that the JWT was generated and signed by the same scan node the bot is running on. See an example usage of verifying a JWT</p> <ul> <li><code>token</code> - required  a JWT token generated by <code>fetchJwt</code></li> </ul>"},{"location":"sdk/#decodejwt","title":"decodeJwt","text":"<p>A utility method for decoding the header and payload of a Jwt returned from a scan node.</p> <ul> <li><code>token</code> - required  a JWT token generated by <code>fetchJwt</code></li> </ul> <pre><code>let jwt;\n\nconst initialize: Initialize = async (blockEvent: BlockEvent) =&gt; {\n  const token = await fetchJwt(claims: {key: value})\n  jwt = decodeJwt(token)\n\n  ...\n}\n</code></pre> <p>This method will not verify the signature of a JWT</p>"},{"location":"sdk/#createblockevent","title":"createBlockEvent","text":"<p>A utility function for writing tests. You can use <code>createBlockEvent</code> to easily generate a mock <code>BlockEvent</code> object when writing unit tests for your <code>handleBlock</code> handler. To better understand usage, see the Typescript unit test example.</p>"},{"location":"sdk/#createtransactionevent","title":"createTransactionEvent","text":"<p>A utility function for writing tests. You can use <code>createTransactionEvent</code> to easily generate a mock <code>TransactionEvent</code> object when writing unit tests for your <code>handleTransaction</code> handler. To better understand usage, see the Javascript unit test example.</p>"},{"location":"sdk/#createalertevent","title":"createAlertEvent","text":"<p>A utility function for writing tests. You can use <code>createAlertEvent</code> to easily generate a mock <code>AlertEvent</code> object when writing unit tests for your <code>handleAlert</code> handler.</p>"},{"location":"security-deploy/","title":"Deployment & Smart Contracts","text":""},{"location":"security-deploy/#security-deployment-smart-contracts","title":"Security - Deployment &amp; Smart Contracts","text":"<p>The Foundation has required deployment through GitHub CI and OpenZeppelin's Defender product. For off-chain assets, critical pull requests must go through a required review that upon the merge are gated by successful tests, node scanner software is gated through a state update in the ScannerNodeVersion contract, and smart contract deployments/changes are handled through OpenZeppelin\u2019s Defender product and relayers and are controlled by multisigs. This process ensures that the Forta Network cannot be changed, even in the event of a security breach by an individual involved in any of the development processes.</p> <p>Lastly, most of the contracts in the Forta Network are upgradeable. Therefore, if you are going to interact with an Upgradeable contract, always use the Proxy address.</p>"},{"location":"security-deploy/#multi-sig","title":"Multi-Sig","text":"<p>Forta is managed through three main Gnosis Safe Multi Sig contracts: </p> <ul> <li>0xC0eb11fBC755D31c6FECEaAc8760ddCb88C64fE1 (Ethereum mainnet). 4/7 controlled by the Council members</li> <li>0x30ceaeC1d8Ed347B91d45077721c309242db3D6d (Polygon mainnet). 4/7 controlled by the Council members</li> <li>0xd1d4FaFd400fCD643132bb7eAF7682eE97E09C3e (Polygon mainnet). The Council members may delegate certain roles and corresponding signing authority. Currently, administrative roles have been delegated to a 3/9 multisig with members of the Foundation staff and certain members of the original core development team.</li> </ul> <p>The Council multisigs have the following roles:</p> <p>Ethereum Mainnet</p> <ul> <li>Forta Token (0x41545f8b9472D758bB669ed8EaEEEcD7a9C4Ec29): ADMIN_ROLE</li> </ul> <p>Polygon Mainnet</p> <ul> <li>Forta Token (Bridged) (0x9ff62d1FC52A907B6DCbA8077c2DDCA6E6a9d3e1): ADMIN_ROLE</li> <li>Access (0x107Ac13567b1b5D84691f890A5bA07EdaE1a11c3): DEFAULT_ADMIN_ROLE, AGENT_ADMIN_ROLE, ENS_MANAGER_ROLE, SCANNER_ADMIN_ROLE, SCANNER_VERSION_ROLE, SLASHER_ROLE, STAKING_ADMIN_ROLE, UPGRADER_ROLE</li> </ul> <p>The administrative multisig has the following roles:</p> <p>Polygon Mainnet</p> <ul> <li>Access (0x107Ac13567b1b5D84691f890A5bA07EdaE1a11c3): AGENT_ADMIN_ROLE, DISPATCHER_ROLE, ENS_MANAGER_ROLE, SCANNER_POOL_ADMIN_ROLE, SCANNER_VERSION_ROLE, SLASHER_ROLE, SWEEPER_ROLE, UPGRADER_ROLE</li> </ul>"},{"location":"security-deploy/#roles","title":"Roles","text":"<p>Complete list of roles with a description:</p> <ul> <li>Forta Token (0x41545f8b9472D758bB669ed8EaEEEcD7a9C4Ec29):<ul> <li>ADMIN_ROLE: General admin role granted to account with ability to set ENS and upgrade contract.</li> <li>MINTER_ROLE: Role granted to account with the access to mint more FORT tokens.</li> </ul> </li> <li>Forta Token (Bridged) (0x9ff62d1FC52A907B6DCbA8077c2DDCA6E6a9d3e1):<ul> <li>ADMIN_ROLE: General admin role granted to account with ability to set ENS and upgrade contract.</li> </ul> </li> <li>Access (0x107Ac13567b1b5D84691f890A5bA07EdaE1a11c3):<ul> <li>DEFAULT_ADMIN_ROLE: General admin role that is set during the initialization of the Access contract. Most notable ability is to grant new roles to other accounts and/or contracts.</li> <li>ENS_MANAGER_ROLE: Role granted to an account with the ability to set ENS reverse registration.</li> <li>UPGRADER_ROLE: Role granted to an account with the ability to upgrade a proxy to use a new implementation.</li> <li>AGENT_ADMIN_ROLE: Role granted to account with the ability to set the bot stake threshold, activate frontrunning protection, and enable and/or disable a given bot.</li> <li>SCANNER_ADMIN_ROLE: Role granted to account with the ability to set the stake threshold for a given chain, and enable and/or disable a given scanner.</li> <li>SCANNER_POOL_ADMIN_ROLE: Role granted to account with the ability to set the scanner pool stake parameters, set scanner node registration delay, and update the amount of enabled scanners in a pool.</li> <li>SCANNER_2_SCANNER_POOL_MIGRATOR_ROLE: Role granted to ScannerToScannerPoolMigration contract to be able to de-register scanners from the previous system and register scanner pools under delegated staking.</li> <li>DISPATCHER_ROLE: Role granted to account with ability to assign and/or unassign bots to scanner nodes.</li> <li>MIGRATION_EXECUTOR_ROLE: Role granted to account with ability to migrate scanners. Role granted to a Forta controlled EOA, 0xe9a105b355A14D11eA3468410Dfe6B31998C8384.</li> <li>SLASHER_ROLE: Role granted to the SlashingController contract to slash a stake subject.</li> <li>SWEEPER_ROLE: Role granted to account with ability to transfer out tokens mistakenly sent to the staking contract.</li> <li>REWARDER_ROLE: Role granted to account with ability to reward scanner pools. Role granted to a Forta controlled EOA, 0x15d3c7e811582Be09Bb8673cD603Bb2F22D1e47B.</li> <li>SLASHING_ARBITER_ROLE: Role granted to account with ability to execute various actions in the slashing process. Role granted to the 2/3 Arbiter multisig, 0x044f6Db7F0ba9e5F0AccD797E2AD5B1bA4E1E853. Slashing detailed further here.</li> <li>STAKING_CONTRACT_ROLE: Role granted to the Staking contract with the ability to increase or decrease a subject\u2019s stake allocation.</li> <li>STAKING_ADMIN_ROLE: Role granted to account with the ability to set the percentage of a delegator\u2019s stake than can be slashed.</li> <li>ALLOCATOR_CONTRACT_ROLE: Role granted to the Allocator contract with the ability to increase and/or decrease a subject's allocated stake amount for rewards calculation.</li> <li>SCANNER_VERSION_ROLE: Role granted to an account with the ability to set a new scanner node version.</li> <li>SCANNER_BETA_VERSION_ROLE: Role granted to an account with the ability to set a new scanner node beta version.</li> </ul> </li> </ul>"},{"location":"security-deploy/#contract-administration","title":"Contract Administration","text":"<p>Forta contracts are managed through OpenZeppelin's Defender product utilizing relays to manage smart contract deployment and maintenance.</p>"},{"location":"security-deploy/#deployed-smart-contract-addresses","title":"Deployed Smart Contract Addresses","text":"<p>Forta Network uses smart contracts to coordinate registration and ownership of Scanner Nodes and Detection Bots (referred to by their former name of Agents in this release), the assignments of Bots and Scanners, the accepted Scanner Node software version and the economic safety mechanisms of the network via the ERC20 FORT Token.</p> <p>To learn more, read the smart contracts GitHub repo, the documentation for the contracts, or the smart contract architecture diagram in the Design page.</p> <p>Ethereum Mainnet</p> Name Proxy Implementation Forta Token 0x41545f8b9472D758bB669ed8EaEEEcD7a9C4Ec29 0x587969Add789c13F64Bcc34Ff253BD9BFB78f38a <p>Polygon</p> Name Proxy Implementation Access 0x107Ac13567b1b5D84691f890A5bA07EdaE1a11c3 0x739707848131F41aCd1d78A56FE0eA02052811Df Agents (Detection Bots) 0x61447385B019187daa48e91c55c02AF1F1f3F863 0xE7e6c9A579eF43FfE629F9B99a9e4585ae69ED9c Scanners (Deprecated) 0xbF2920129f83d75DeC95D97A879942cCe3DcD387 0x75c46283dE6b08bE4bb4425b94aC338f2802e3B0 Scanner Pools 0x90FF9C193D6714E0e7a923b2Bd481Fb73FEC731d 0x92FA117c7c071cC11b544931c46c9e3096d6FcB1 Dispatch 0xd46832F3f8EA8bDEFe5316696c0364F01b31a573 0xB5F1A9C329924Fe8203A91aa891182d4E331fF0A Forwarder -- 0x356A8ee5D3bCc183c2c7853F11D19f4C7622396F Forta Token (Bridged) 0x9ff62d1FC52A907B6DCbA8077c2DDCA6E6a9d3e1 0xd6b3139108e271c812acc6ffebad28e935d61e24 Staking 0xd2863157539b1D11F39ce23fC4834B62082F6874 0xeA359707f17Aeb000c9385b4Bfd1cC7be62d4Bc7 StakeSubjectGateway 0x587969Add789c13F64Bcc34Ff253BD9BFB78f38a 0x6C85A754F9c79178D9701e91C29C995f227D7551 ScannerNodeVersion 0x4720c872425876B6f4b4E9130CDef667aDE553b2 0x61dE69E421d50F7290373fc38751f694ff1e1984 SlashingController 0x6927C25ff30ed86F86A863d987590A1d77509bDb 0x525a90638330473bE7bB756465ca443a03b53068 StakeAllocator 0x5B73756e637A77Fa52e5Ce71EC6189A4C775c6FA 0x8A9B40aE0cCa4f602CA3E4f68114b69C794571F0 RewardsDistributor 0xf7239f26b79145297737166b0c66f4919af9c507 0xfc3642038a312Ff983BdBC1F5C900eEC20AaFfB6 ScannerToScannerPoolMigration 0x1365fa3FE7F52db912daBc8e439f0843461fee16 0xAb94300F91DA64637C94b6c4159AC805d23C7cF8 General Plan 0x4e0c80548e67a6e05464e540729222eb9812444d 0x64a3328cf61025720c26de2a87b6d913fa6e376a Scam Detector Plan 0x54089510aec879ca42e08bc4b166be8362b56bb2 0x64a3328cf61025720c26de2a87b6d913fa6e376a Rug Pull Detector Plan 0x525d8d73f11a8586482f4f74c105d9d8b7cf73da 0x64a3328cf61025720c26de2a87b6d913fa6e376a Spam Detector Plan 0x6453379cbc14f7a277319b6c8b7577ae78524968 0x64a3328cf61025720c26de2a87b6d913fa6e376a <p>Sepolia Testnet</p> Name Proxy Implementation Forta Token 0x95d9a757ad9C25999ffE93f3067221F04ce1Cc79 0x6A434647A4a3De2F915Bb49B6227444EBbE67Aed <p>Base Sepolia Testnet</p> Name Proxy Implementation Access 0x3063152eb36007dEbEA023Caa6725da166bB149c 0xbEC4ADBEFc7B9B2BC1277F77B3dFa9a20C72297d Agents (Detection Bots) 0x0C8B8DeC21Aa72179e8C4703a9B55d9Db061D423 0x94bb1C019F23da25e6186831c88372422050bAE8 Scanner Pools 0x786e4446bB39F5480310FE98c48d2d5e6129A4cC 0xd3BF0042aEDcB9d41cdaaC647249Bf1c7102f764 Dispatch 0x452C7044B9977de45ed7621ba0Bb77E312663157 0x74bc6EF72B84581aCAB56bd180c1C7A0CCaeECD3 Forwarder -- 0x4cf374988bDb78Ba81D59f915612D7D74ef93380 Forta Token (Bridged) 0x38C0F07ECA98b87757Fb76C56Be779b79C676062 0xcB31e349c6229cDC3560d80368092aC89095Ca38 Staking 0x1ed86971E4C4f3d13b6b8030D80C7D609de7139c 0xC6fE33F0BAd197fE65673Eff0D4e959e277fb401 StakeSubjectGateway 0x7691a7505666fCe7d3512Fd2ec5d731c6CB6C399 0x98fb54aF7f508E83b35d81C65158bC8449128BB9 ScannerNodeVersion 0x58376C1982Da91B54d508335D9c9B43F1AC9E54D 0x860757a3e9b72deD32CF15ea64f5425533442Fd9 SlashingController 0x1Eca2C733AecaeB2c2E89F7fA526E00fB4A74eDe 0x18Ca964A5C1a5778fA3519ca6E2Dfc449A5b675b StakeAllocator 0xc054a3DABfFEb0279E62669FB699a33D4cC5fC62 0xBe9209E216Bc22b375b87267f009d75286d56B4A RewardsDistributor 0x414E8777Df3e3Af4Ed3e4bA9A2266779F86558e4 0xFf5cc53879dB4924E0266c2Ec93C5b6204593684 <p>Pause Functionality</p> <p>Currently, Forta does not implement Pause functionality in its smart contracts. In lieu of Pause functionality, the contracts\u2019 upgradability could be utilized to pause the contracts in the event of responding to an incident. Additionally, Forta does not incorporate the usage of Oracles, and therefore has no risk of Oracle manipulation attacks.</p> <p>Timelock</p> <p>Forta has no implementation of a Timelock. Since changes to the contracts require an execution from the 4/7 Forta Council multisig, this process fulfills the need of a Timelock\u2019s functionality.</p>"},{"location":"security-deploy/#forta-on-chain-monitoring","title":"Forta On-Chain Monitoring","text":"<p>Forta on-chain activity is monitored by Forta Detection Bots and feeds into Forta Network's incident response process. The following detection bots were developed specifically for the Forta smart contracts. The code is available on GitHub.</p> <ul> <li>Forta Access Control Role Changed</li> <li>Forta Access Manager - Router Updated</li> <li>Forta Admin Bot Scanner Disable</li> <li>Forta Agent Updated</li> <li>Forta Agents Linked</li> <li>Forta Core Monitoring</li> <li>Forta Emitting Upgraded</li> <li>Forta Mint Mainnet</li> <li>Forta Scanner Node Software Updated</li> <li>Forta Staking Events</li> <li>Forta Staking Parameters</li> <li>Forta High Number Of Bot Deployments</li> <li>Forta Routing Updated</li> <li>Forta Stake Controller Changed</li> <li>Forta Stake Threshold Changed</li> <li>Forta Token Role Changes</li> <li>Forta Whitelist Disabling</li> </ul> <p>Forta is also monitored by the bots in the Threat Detection Kits.</p>"},{"location":"security-deploy/#forta-off-chain-monitoring","title":"Forta Off-Chain Monitoring","text":"<p>Lastly, several operational monitors exist around the performance of the network, such as latency, API usage, deployments, etc. </p>"},{"location":"security-design/","title":"Design","text":""},{"location":"security-design/#security-design","title":"Security - Design","text":"<p>Security starts in the design phase by incorporating strategies to disincentivize and mitigate malicious behaviors. As described in the Forta Litepaper, the primary guiding principles around the Forta protocol were:</p> <ul> <li>Decentralization - this not only applies to the network of independent scan nodes, but also to the detection bots that the community develops and the governance over the Network. This creates redundancies and increases the reliability of the network in case isolated failures occur.</li> <li>Cryptoeconomic Incentives - these incentives, like node and bot staking, encourage net positive behavior and disincentivize malicious behaviors.</li> <li>Security Inheritance - as the Forta Network is built on top of Ethereum and Polygon, its smart contracts inherit the security properties of those networks at the base layer.</li> <li>Network Isolation - isolation of network components from each other.</li> </ul> <p>Further, the design of the Forta Network adopted three important security practices: (1) an assume-breach mentality, (2) an attacker mindset, and (3) looking at the protocol comprehensively from a security perspective. These three principles should be at the forefront of the Forta community's mind for any future changes to the Forta Network. Some of the questions that can be asked during the design phase are:</p> <ul> <li>What if a contributor is compromised?</li> <li>What if there is a malicious node or bot developer? What are they able to accomplish?</li> <li>What are the components beyond the smart contracts that need to be considered?</li> <li>Where are the community touch points and how could a compromise within that setting manifest?</li> </ul> <p>As an example, the Forta Litepaper detailed how those guiding principles and questions were incorporated into the original Forta Network design.</p>"},{"location":"security-design/#smart-contracts","title":"Smart Contracts","text":"<p>The architecture of the Forta smart contracts can be seen in the below diagram.</p> <p></p>"},{"location":"security-develop/","title":"Development","text":""},{"location":"security-develop/#security-development","title":"Security - Development","text":"<p>Code reuse and leveraging audited smart contract libraries help to reduce the overall attack surface of a protocol. The Forta Network leveraged OpenZeppelin's open source smart contract libraries for certain of its smart contracts. Overall, the principle of least privilege and access control was implemented (e.g. see role usage of Forta's smart contracts). </p> <p>The principle of least privilege does not just apply to smart contracts, but all other dependent code relevant components, such as GitHub code repositories (e.g. secured by 2FA on all accounts) and processes (e.g. code review requirements for critical pull requests).</p> <p>Forta's governance process is grounded by a community governance framework that consists of a Forta's governance process (supported by off-chain governance voting on Snapshot) as well as the Forta Governance Council to which the community delegated decision power to. This Council has control of the 4/7 Gnosis Safe Council multisig wallets that require a majority of Council members to execute proposals and/or changes to the protocol. The distributed and two-step nature of proposal execution mitigates development risk due to governance.</p>"},{"location":"security-maintain/","title":"Maintenance","text":""},{"location":"security-maintain/#security-maintenance","title":"Security - Maintenance","text":"<p>As mentioned in the overview, security is not static and the Forta development community should periodically assess the change velocity and risk assessment. In the initial period following Permissionless Launch, the Foundation has engaged the original core development team to review/ assess the state of the Forta Network from a security perspective on a monthly basis. </p> <p>The Forta Foundation has instituted an initial incident response process. While incidents can be categorized into normal events, incidents, and emergency events, this section focuses on the latter as an extreme case. The processes and structure applied here can selectively flow into the former types of incidents. Of course, all the actions described in the security section of these docs could be described as preventative actions; incidents do occur though and at the start of the incident one requires detective actions, such as operational and security monitoring, as well as community engagement and appropriate communication channels (e.g. @FortaNetwork and Forta Discord or private channels for unremedied vulnerabilities). Further, the Forta Foundation has established a bug bounty program on Immunefi.</p> <p>When incidents occur, incident readiness and ability to take corrective actions are needed. While the incident process describes roles, responsibilities and actions to take during an incident, incident readiness needs to facilitate the action plan associated with the objectives set out for the incident response process. This includes aspects like defining communication channels, having the right audit trails, and having capabilities to respond to an incident swiftly (e.g. pausing or updating a smart contract).</p>"},{"location":"security-maintain/#incident-response-framework","title":"Incident Response Framework","text":"<p>The Forta Incident Response process is modeled after the FEMA National Incident Management System (NIMS). It is a standardized approach used by US government agencies for incident management that translates well into the cybersecurity space. It\u2019s been used for over 40 years as an effective framework to effectively handle incidents. NIMS is organized into three key components and gets activated when an incident occurs:</p> <ul> <li>Resource Management</li> <li>Command and Coordination - including the Incident Command System</li> <li>Communications and Information Management</li> </ul> <p>The Incident Command System (ICS) is just one part of NIMS. The benefits of ICMs are:</p> <ul> <li>Clarifying chain of command and supervision responsibilities to improve accountability.</li> <li>Leveraging interoperable communications systems and plain language to improve communications.</li> <li>Providing an orderly, systematic planning process.</li> <li>Implementing a common, flexible, predesigned management structure.</li> <li>Fostering cooperation between diverse disciplines and agencies.</li> </ul> <p>NIMS is a simple flexible framework that creates clarity in an incident situation. For more information around NIMS and ICS, the following online training courses provide more details: IS-100.c and IS-700.b.</p>"},{"location":"security-maintain/#incident-response-process","title":"Incident Response Process","text":"<p>Incident response process holistically follows 4 distinct stages:</p> <ul> <li>Preparation/ Incident Response Readiness</li> <li>Triage and Incident Declaration</li> <li>Response</li> <li>Post Mortem</li> </ul> <p>While each incident is likely going to be unique, some aspects will be shared across incidents. As such, the below can act as general guidelines on how incidents should be approached in the context of NIMS as opposed to a playbook anticipating certain scenarios.</p>"},{"location":"security-maintain/#preparation-incident-response-readiness","title":"Preparation/ Incident Response Readiness","text":"<p>In order to be able to effectively respond to an incident, the Forta Governance Council has approved the following plan to be carried out for each incident, which tasks have been delegated to the Foundation and Forta community members as appropriate:</p> <ul> <li>Training - each member of the Incident Response Team completed the NIMS/ ICS training courses and familiarized themselves with the incident response process.</li> <li>War Room - as an incident occurs, proper communication channel and backup channels are defined. The storage location of any artifacts (documents, log files, etc.) has already been defined.</li> <li>External Communication Channels - the Foundation will designate a Public Communications Officer for each incident as part of the Unified Command structure as defined by NIMS. This person will keep the Forta community abreast of the details and progress of the incident, using discretion as appropriate for unremedied vulnerabilities.</li> <li>Forensic Readiness - tooling needs, access procedures, and log files acquisition have already been documented. Operational and security alerts (internal/external) are surfaced to corresponding Incident Command Supervisors to triage events (see below).</li> <li>Incident Response Roster - geo distributed on-call list as well as expertise roster have been established. Note, the Forta Network is managed by multisigs and sufficient signer coverage needs to exist to perform any mitigating actions. This was considered in the on-call list.</li> <li>On-chain Response Capabilities - defined on-chain response capabilities as implemented through the multisig, OpenZeppelin\u2019s Defender, and on-call roster of the signers as well as upgradability and pausability of certain Forta contracts.</li> <li>Abuse Roster - created a list of contacts/links to mitigate abuse, such as scams or impersonating accounts.</li> </ul>"},{"location":"security-maintain/#triage-and-incident-declaration","title":"Triage and Incident Declaration","text":"<p>An incident starts with an event. This could be a Forta community member noticing something, a user reaching out on Twitter/ via security@forta.org, or an alert from Forta\u2019s operational and security monitoring. These events need to be brought to the attention of the Incident Response Team via the designated channel (all critical and operational monitoring alerts are sent to this channel today) and should get escalated there with the incident command supervisor being tagged to triage the incident.</p> <p>Triaging the incident out to lead to the following outcomes:</p> <ol> <li>Does the event constitute an incident?</li> <li>What is the severity of the incident?</li> <li>Identify an incident command supervisor as per the on-call schedule.</li> </ol>"},{"location":"security-maintain/#response","title":"Response","text":"<p>At the beginning of a declared incident, the following steps ought to be executed:</p> <ul> <li>Create the incident response Slack channel</li> <li>Identify initial set of incident responders and public communications officer to be activated; structure according to the NIMS framework</li> <li>Articulate the objective of the incident on the Slack channel with \u2018Incident Objective:\u2019</li> <li>Develop the action plan</li> <li>Execute on action plan; iterate given the information obtained. </li> <li>Setup regular calls between team leads and incident command supervisor</li> <li>Setup regular calls between incident command supervisor and public communications officer</li> <li>If an incident extends the business day, ensure a call with a hand-off between the incident command supervisors and public communications officer. </li> <li>Once objectives are achieved, declare the incident as resolved and move towards the post mortem stage.</li> </ul>"},{"location":"security-maintain/#post-mortems","title":"Post Mortems","text":"<p>Each high severity incident is concluded with a post-mortem that allows the incident response process to improve and strengthen the Forta community\u2019s ability to handle incidents effectively. These post-mortems will be posted in the Forta security documentation as well as Forta\u2019s main community communication channels (Twitter, Discord, Forum). A post-mortem may not be published if such publicity could present further risk to Forta or other protocols.</p> <p>The post mortems should have a set of prioritized action items assigned and completion dates committed (note, some items will be optional). The action plan should be reviewed on a weekly basis until all committed action items are completed. The closure of the post-mortem will be the responsibility of the primary incident command supervisor.</p>"},{"location":"security-maintain/#practice","title":"Practice","text":"<p>Incident response processes can be stressful events. Similar to how fire drills are practiced in schools, practicing incident response processes will help to surface gaps in the process, get everybody familiar with the process, and help everybody to be more comfortable and effective in a real world incident.</p> <p>An incident will be simulated every 6 months if no other real world incidents occurred and results of the incidents will be posted in a post-mortem write up. These will be scheduled events.</p>"},{"location":"security-testing/","title":"Testing and Review","text":""},{"location":"security-testing/#security-testing-and-review","title":"Security - Testing and Review","text":"<p>Testing and review starts with a good understanding of the Forta Network itself through documentation, transparency, and public nature of the primary components of the network. Key pieces of the network are summarized below:</p> <ul> <li> <p>Contracts (prod and test)</p> <ul> <li>Polygon and Ethereum mainnet</li> <li>Mumbai and Goerli Test Net</li> </ul> </li> <li> <p>Github repos (private and public)</p> <p>Public:</p> <ul> <li>Scan Node software for the Forta Network</li> <li>Forta Go Libraries</li> <li>Forta Detection Bot SDK and CLI tool</li> <li>Forta Contracts</li> <li>Forta Threat Detection Kits</li> <li>Airdrop Autotasks</li> </ul> <p>Private:</p> <ul> <li>Forta Assigners</li> <li>Forta Infra</li> <li>Forta Airdrop Interface</li> <li>Forta Airdrop Contracts</li> <li>Forta GraphQL API</li> </ul> </li> </ul> <p>Testing of the code must happen through GitHub Actions on each pull request and gated upon successful tests. Code coverage data for the contract's tests can be found in the Codecov dashboard here. (Note: Code coverage tests exclude contracts in the <code>contracts/components/_old</code> folder since those are deprecated contracts.)</p> <p>Adopting an attacker mindset, the Foundation went beyond employing secure design, development, deployment and testing and enlisted external security experts to assess the Forta Network after it was built. This helped to surface erroneous assumptions and uncover security gaps that may have remained hidden. Forta primarily engaged OpenZeppelin's smart contract auditing expertise as well as Dedalo's web2 and broad threat assessment expertise for other critical components of the Network. All such reports/findings are linked below:</p> <ul> <li>Dedalo's Airdrop Assessment, June 17th 2022</li> <li>OpenZeppelin's Airdrop Smart Contract Audit, June 9th 2022</li> <li>Dedalo's Forta Scan Node Assessment, April 7th 2022</li> <li>OpenZeppelin's Protocol Audit, February 7th 2022</li> <li>Dedalo's Web Security Assessment, January 5th 2022 </li> <li>MixBytes' Security Assessment of slash proposal changes, September 2nd 2022</li> <li>Consensys' Security Assessment of Delegated Staking, November 2022</li> </ul>"},{"location":"security/","title":"Security Overview","text":"<p>As a decentralized monitoring network to detect threats and anomalies on Web3 systems, the Forta Network\u2019s security is of utmost importance. The Forta Network protects billions of dollars of value in the Web3 ecosystem, so Forta itself needs to be reliable and follow best security practices. In June 2022, a16z and other Forta community members published a guide called Smart Contract Security: A Simple Checklist for Web3 Development. It describes five critical phases of the Development Lifecycle for Smart Contract Security, which were followed when the Forta Network was developed and the Forta community should adhere to in the future:</p> <p></p> <p>This section shares how each of these 5 phases was contemplated in the original design and development of the Forta Network. However, the Forta Foundation and the community should continue to approach security comprehensively, including contemplating network infrastructure and Web2-dependent components (e.g. the Forta API and Dapp) and associated processes as the protocol evolves.</p> <p>Security of a protocol is not static. A protocol continues to evolve and security issues can be introduced with any changes. Attackers also evolve and may adopt techniques that present new threats. The Forta community\u2019s stance towards security therefore should not be static. Security should not degrade, but rather strengthen over time. This section also highlights the continued investments the Forta community can make over time to strengthen Forta's security, such as auditing any changes to existing smart contracts, ongoing monitoring and detection bot development, and periodic security assessments.</p>"},{"location":"sensitive-data/","title":"Protecting sensitive data","text":"<p>There are cases where developers need to use sensitive information in their bot (e.g. some API key) or just hide their bot code from the public. While Forta does not currently support storage of secrets (since all bot images are stored in a public repository), developers can still use JWT authentication or code obfuscation as two ways to protect sensitive data.</p> <p>It should be noted that obfuscation is not the same as encryption, and that obfuscation can potentially be reversed with enough effort. With this in mind, we do not recommend storing high-value secrets in your bots. Instead, you can use the pattern for JWT authentication for bots to securely load secrets without storing them in the code.</p> <p>This page will demonstrate how to obfuscate your code using an example Javascript bot. You can find the code for this example here.</p>"},{"location":"sensitive-data/#obfuscating-code","title":"Obfuscating code","text":"<p>In this example, the javascript-obfuscator library is used to obfuscate the bot code, but you can use any library you prefer. An npm script is added to the project to run the obfuscator tool over the code: <code>npm run obfuscate</code>. The script in package.json will look like:</p> <pre><code>\"scripts\": {\n  ...\n  \"obfuscate\": \"javascript-obfuscator ./src --output ./obfuscated --config obfuscation-config.js\"\n}\n</code></pre> <p>This will take all of the Javascript files in the src folder and output obfuscated versions of each file with the same name to the obfuscated folder (if using Typescript, you should obfuscate the compiled Javascript files in the dist folder instead of the src folder). The npm script simply invokes the <code>javascript-obfuscator</code> tool with some obfuscation options stored in obfuscation-config.js.</p> <p>It is recommended to obfuscate before building your bot image so that you can verify the results of the obfuscation and make sure it meets your expectations. You can also try running the obfuscated code to verify that it still works by moving the obfuscated files over to the src folder. Please note that the <code>javascript-obfuscator</code> tool can output different results based on the same settings, so be sure to verify that the obfuscated result is good enough for you.</p> <p>If there are any json files in your bot (e.g. ABI.json), consider converting them into Javascript (.js) files so that they also get obfuscated and don't reveal anything about the bot. Make sure that unit tests are also obfuscated, or better yet, just not included in the final image. This could easily reveal what the bot is doing.</p>"},{"location":"sensitive-data/#obfuscation-settings","title":"Obfuscation settings","text":"<p>The obfuscation-config.js contains a number of settings for manipulating the code. You may want to tweak these settings in order to further obfuscate your code. There are a few preset options you can experiment with to achieve your desired level of obfuscation. Keep in mind that there will be a tradeoff between obfuscation and performance when tweaking these settings.</p> <p>Be careful if tweaking the obfuscation-config.js settings, as some of the options could potentially break your code. For example, the <code>selfDefending</code> option will prevent your code from running if it is formatted in any way after being obfuscated. See the complete list of options to get a better understanding.</p>"},{"location":"sensitive-data/#updating-the-dockerfile","title":"Updating the Dockerfile","text":"<p>The Dockerfile in the example is slightly modified to copy the obfuscated source code from the obfuscated folder instead of the src folder:</p> <pre><code>...\n# copy code over from obfuscated folder\nCOPY /obfuscated ./src\n...\n</code></pre> <p>This will ensure only the obfuscated code gets published in the bot image.</p> <p>Awesome! You now have an obfuscated bot that can store sensitive data in a publicly available image.</p>"},{"location":"sharding/","title":"Increasing bot throughput with sharding","text":"<p>Only supported in CLI</p> <p>Sharding is currently only supported by the <code>forta-agent</code> CLI (i.e. you cannot enable sharding from the Forta App UI)</p> <p>Some detection bots may have difficulty keeping up with the volume of blocks/transactions/alerts (either because of the bot's logic, or due to the speed of the blockchain being scanned). One solution is to use sharding to increase throughput for your detection bot. With sharding, you can increase the number of instances of your detection bot and split the blocks/transactions/alerts across these instances.</p> <p>By default, each detection bot is deployed to multiple scan nodes (currently, 3 per each chain being scanned) and each of these 3 bot instances receives all of the blocks/transactions/alerts for the chain being scanned. Another way to say this: by default, a detection bot targets 3 instances with only 1 shard per instance.</p> <p>Sharding for transactions/blocks is based on the block number; sharding for alerts is based on the alert timestamp.</p>"},{"location":"sharding/#enabling-sharding","title":"Enabling sharding","text":"<p>To enable sharding, you need to configure it in your package.json using the <code>chainSettings</code> property. Here is a simple example of a sharding configuration:</p> <pre><code>\"chainSettings\":{\n   \"1\": {\n      \"shards\": 2,\n      \"target\": 2\n   }\n}\n</code></pre> <p>The above configuration only applies to the Ethereum chain (as indicated by the <code>\"1\"</code> key), and targets 2 bot instances with 2 shards each i.e. the total number of bot shards will be 2 x 2 = 4. Each shard will receive only half of the Ethereum blocks/transactions/alerts. With this configuration in package.json, you just need to publish the bot using <code>npm run publish</code> to deploy the shards.</p> <p>Currently, the maximum number of possible shards is 6. It is also worth mentioning that each shard can potentially be running on a different scan node.</p>"},{"location":"sharding/#more-configuration-examples","title":"More configuration examples","text":"<p>Here is a slightly more complex sharding configuration in package.json for a detection bot scanning multiple chains:</p> <pre><code>\"chainIds\": [1, 137, 56, 10],\n\"chainSettings\": {\n    \"default\": {\n        shards: 2,\n        target: 3,\n    },\n    \"137\": {\n       shards: 3,\n       target: 2,\n    }\n}\n</code></pre> <p>In this configuration, the bot is deployed to 4 different chains (as indicated by <code>chainIds</code>). The sharding configuration specifies a <code>default</code> target of 3 instances with 2 shards each (the default sharding config will be used for chains where a specific config is not given). Also, the config specifies that on the Polygon chain (<code>137</code>) the bot should target 2 instances with 3 shards each.</p>"},{"location":"sharding/#how-to-determine-the-right-sharding-configuration","title":"How to determine the right sharding configuration?","text":"<p>Sharding is needed if your bot is unable to keep up with the transaction/block/alert throughput of the chain. It essentially is too slow. For instance, BNB Chain adds a block every 3 seconds; recently, there are about 70 tx in each block on average. This means, the bot needs to process a tx in approximately 40ms. If your bot is slower than this, the bot may fall behind and transactions are dropped. </p> <p>The first step would be to assess whether the bot indeed drops transactions. The bot health page provides insights through the Dropped view (example).</p> <p>Second, start measuring the performance of your bot through a unit test. In this test, you would want to exercise the different code paths of your bot (the cheap and expensive paths) and calculate a weighted average processing time based on the performance of these code paths (example). </p> <p>Once the performance is known, one can derive a sharding configuration. For instance, if your bot takes 120ms on average to process a transaction, it would be too slow for the BNB Chain. In that case, you would want to distribute the transactions to approximately 3 shards.</p> <p>Once configured, it is essential to deploy the bot and review the bot stats page. You tested your bot on your local machine and the performance of your machine may differ from the scan nodes on the network. Some experimentation and iteration may be needed to utilize sharding in a way where every transaction/block gets processed reliably.</p>"},{"location":"sharding/#sharding-alternatives","title":"Sharding alternatives","text":"<p>Is the above sharding solution not quite working for your bot? You can also consider these community-developed libraries to help with sharding your bot:</p> <ul> <li>forta-sharding by Artem Kovalchuk</li> </ul>"},{"location":"sla-api/","title":"Scan Node SLA API","text":"<p>To evaluate the health of nodes in the network, Forta calculates a score (SLA) based on node activity.  This score is a 0-1 score where higher is better.  This calculation will evolve as more factors are considered.</p>"},{"location":"sla-api/#sla-calculation","title":"SLA Calculation","text":"<p>See SLA for details regarding the composition of the SLA score.</p>"},{"location":"sla-api/#api","title":"API","text":"<p>To make this score visible, we now have an API that anyone can call for a given scanner address.  Simply curl the API to get a summary report for the period you are interested in.</p>"},{"location":"sla-api/#request","title":"Request","text":"<p>URL <pre><code>GET https://api.forta.network/stats/sla/scanner/{scannerAddress}\n</code></pre></p> <p>Request Parameters</p> <ul> <li><code>startTime</code> - Start of date range to consider, in RFC3339 (YYYY-MM-DDTHH:MM:SSZ) (Default: 2 hours ago)</li> <li><code>endTime</code> - End of date range to consider, in RFC3339 (YYYY-MM-DDTHH:MM:SSZ) (Default: 1 hour ago)</li> <li><code>showMinutes</code> - Enables the <code>lowestMinutes</code> list in the response (Default: false)</li> </ul> <p>Example (Most Recent available Hour) <pre><code>https://api.forta.network/stats/sla/scanner/0x58ee631aaef6882a392da1c25486ee181ff1b7d5\n</code></pre></p> <p>Example (The day of 2022-09-07) <pre><code>https://api.forta.network/stats/sla/scanner/0x58ee631aaef6882a392da1c25486ee181ff1b7d5?startTime=2022-09-07T00:00:00Z&amp;endTime=2022-09-08T00:00:00Z&amp;showMinutes=true\n</code></pre></p>"},{"location":"sla-api/#response","title":"Response","text":"<p>Fields</p> <ul> <li><code>scannerId</code> - ID of scanner requested</li> <li><code>startTime</code> - Start time considered for SLA calculations</li> <li><code>endTime</code> - End time considered for SLA calculations</li> <li><code>statistics</code> - Score statistics for the period <ul> <li><code>min</code> - Minimum hour-level score for the period </li> <li><code>max</code> - Maximum hour-level score for the period </li> <li><code>p50</code> - 50th Percentile hour-level score for the period </li> <li><code>avg</code> - Average hour-level score for the period </li> </ul> </li> <li><code>lowestScores</code> - Hour scores for the period (sorted by score ASC)<ul> <li><code>minute</code> - Hour for this hour summary score</li> <li><code>score</code> - Score for this hour</li> <li><code>inputs</code> - Inputs considered in the subscores<ul> <li><code>input_performance</code> - Average of all latest block scores from reported minutes</li> <li><code>expected_input_performance</code> - Always 1 (for reference)</li> <li><code>reporting_success</code> - Sum of batch scores of all reported minutes in the hour</li> <li><code>expected_min_reporting_success</code> - Strict for bot-assigned nodes</li> <li><code>expected_max_reporting_success</code> - The number of minutes in one hour</li> <li><code>inspection_score</code> - The Resource score for the node (hour average) (see SLA for details)</li> <li><code>expected_inspection_score</code> - Always 1 (for reference)</li> </ul> </li> <li><code>scores</code> - Subscores that led to overall score for this hour<ul> <li><code>name</code> - Name of score</li> <li><code>value</code> - Value of score (0-1)</li> <li><code>weight</code> - Weight towards overall score</li> </ul> </li> </ul> </li> <li><code>lowestMinutes</code> - 10 lowest minute scores for the period (sorted by score ASC) (enabled with <code>?showMinutes=true</code>)<ul> <li><code>minute</code> - Minute for this minute score</li> <li><code>score</code> - Score for this minute</li> <li><code>inputs</code> - Inputs considered in the subscores<ul> <li><code>batch_count</code> - Number of batches sent in this minute</li> <li><code>expected_batch_count</code> - Expected number of batches for the minute</li> <li><code>latest_block</code> - Latest block sent by scan node in this minute</li> <li><code>expected_latest_block</code> - 75th Percentile block for all peers for this network</li> <li><code>latest_block_threshold</code> - Threshold used for evaluation of the latest block </li> <li><code>inspection_score</code> - The Resource score for the node (see SLA for details)</li> </ul> </li> <li><code>scores</code> - Subscores that led to overall score for this minute<ul> <li><code>name</code> - Name of score</li> <li><code>value</code> - Value of score (0-1)</li> <li><code>weight</code> - Weight towards overall score</li> </ul> </li> </ul> </li> </ul>"},{"location":"sla-api/#subscores","title":"Subscores","text":""},{"location":"sla-api/#from-minutes-affects-hour","title":"From minutes (affects hour)","text":"<ul> <li> <p><code>batch_score</code> - 0-1 score for <code>batch_count</code> vs <code>expected_batch_count</code></p> <ul> <li>Score is proportional (4 = 1, 3 = 0.75, 2 = 0.50, 1 = 0.25, 0 = 0)</li> <li>Exceeding also decreases score (4 = 1, 5 = 0.75, 6 = 0.50, 7 = 0.25, 8 = 0)</li> </ul> </li> <li> <p><code>latest_block</code> - 0-1 score for <code>latest_block</code> vs <code>expected_latest_block</code></p> <ul> <li>Full credit for being at or above <code>expected_latest_block</code> (within 100 blocks)</li> <li>Decreases from 1 to 0 if <code>latest_block</code> is below <code>expected_latest_block</code>, until 100 blocks behind (score = 0)</li> </ul> </li> </ul>"},{"location":"sla-api/#from-hour-affects-final-score","title":"From hour (affects final score)","text":"<ul> <li><code>reporting_success</code> - 0-1 score for total <code>batch_score</code> within the hour vs. <code>expected_(min|max)_reporting_success</code>.<ul> <li>Score is proportional between <code>[0,min]</code>. Min is 59 for bot-assigned nodes and 3 for idle nodes.</li> <li>The sum does not exceed 60 in an hour.</li> </ul> </li> <li><code>input_performance</code> - 0-1 score for average <code>latest_block</code> score within the hour vs. <code>expected_input_performance</code> (i.e. 1).<ul> <li>The average is calculated using reported minutes.</li> <li>An idle and a bot-assigned node can have the same score although they report at different rates.</li> </ul> </li> </ul> <p>Example Response <pre><code>{\n   \"scannerId\":\"0x9DC6B3679DF5d3327612d6882680F22F984C5F24\",\n   \"startTime\":\"2022-09-07T10:13:58.247904993Z\",\n   \"endTime\":\"2022-09-07T11:13:58.247904993Z\",\n   \"statistics\":{\n      \"min\":1,\n      \"max\":1,\n      \"p50\":1,\n      \"avg\":1\n   },\n   \"lowestScores\":[\n      {\n         \"minute\":\"2022-09-07T10:00:00Z\",\n         \"score\":1,\n         \"inputs\":{\n            \"batch_count\":215,\n            \"expected_min_batch_count\":0,\n            \"expected_max_batch_count\":0,\n            \"reporting_success\":60,\n            \"expected_min_reporting_success\":59,\n            \"expected_max_reporting_success\":60,\n            \"latest_block_threshold\":0,\n            \"latest_block\":0,\n            \"expected_latest_block\":0,\n            \"input_performance\":1,\n            \"expected_input_performance\":1,\n            \"inspection_score\":1,\n            \"expected_inspection_score\":1\n         },\n         \"scores\":[\n            {\n               \"name\":\"input_performance\",\n               \"value\":1,\n               \"weight\":5\n            },\n            {\n               \"name\":\"reporting_success\",\n               \"value\":1,\n               \"weight\":1\n            }\n         ]\n      }\n   ],\n   \"lowestMinutes\":[\n      {\n         \"minute\":\"2022-09-07T11:29:00Z\",\n         \"score\":0,\n         \"inputs\":{\n            \"batch_count\":4,\n            \"expected_min_batch_count\":1,\n            \"expected_max_batch_count\":4,\n            \"reporting_success\":0,\n            \"expected_min_reporting_success\":0,\n            \"expected_max_reporting_success\":0,\n            \"latest_block_threshold\":40,\n            \"latest_block\":15490042,\n            \"expected_latest_block\":15490040,\n            \"input_performance\":0,\n            \"expected_input_performance\":0,\n            \"inspection_score\":1,\n            \"expected_inspection_score\":0\n         },\n         \"scores\":[\n            {\n               \"name\":\"batch_count\",\n               \"value\":1,\n               \"weight\":1\n            },\n            {\n               \"name\":\"latest_block\",\n               \"value\":1,\n               \"weight\":5\n            }\n         ]\n      }\n   ]\n}\n</code></pre></p>"},{"location":"sla/","title":"Scan Node SLA","text":""},{"location":"sla/#what-is-sla","title":"What is SLA?","text":"<p>The Forta Network must have reliable scan nodes.  Forta evaluates the performance of nodes using an SLA calculation so that the network can prioritize Bot assignments and issue rewards.  </p> <p>There are three expectations of scanners</p> <ul> <li>Scanners must meet the minimum requirements of the network</li> <li>Scanners must analyze recent data</li> <li>Scanners must be online and regularly send data</li> </ul> <p>Therefore, an SLA Score incorporates these expectations.</p>"},{"location":"sla/#what-is-a-good-sla","title":"What is a good SLA?","text":"<p>Higher is better.  Rewardable SLAs are between .75 and 1. </p>"},{"location":"sla/#monitor-sla","title":"Monitor SLA","text":"<p>See the SLA API to monitor SLA.</p>"},{"location":"sla/#calculating-sla","title":"Calculating SLA","text":"<p>SLA is a minimum between the Resource Score and a weighted average of the Data Quality Score and the Uptime Score</p> <pre><code>SLA = minimum( \n    resource score, \n    weighted_average( \n        5 * data quality score,\n        1 * uptime score\n    ) \n)\n</code></pre> <p>SLA is calculated per hour. Nodes are rewarded for each hour they reliably meet the requirements of the network.</p>"},{"location":"sla/#resource-score","title":"Resource Score","text":"<p>Scanners must meet the requirements of the Scan Node.  All of the following requirements must be met. </p> <ul> <li>Must run the latest container version</li> <li>Must have run inspections recently</li> <li>Must support <code>trace_block</code> if required for chain (Ethereum Mainnet, Fantom)</li> <li>Must support outbound internet access for Bots</li> <li>Must have accessible JSON-RPC API</li> <li>Must have a JSON-RPC API that supports <code>eth</code> module</li> <li>Must scan the same chain as registered for</li> <li>Must support the minimum memory requirement (currently 16GB)</li> <li>Must load an automated hourly test bot at least once per 2-hour period</li> <li>Must not fail Proof of Detection</li> </ul> <p>All requirements must be met</p> <p>If any requirement is not met, the resource score will be zero, which will cause a zero SLA score.</p>"},{"location":"sla/#data-quality-score","title":"Data Quality Score","text":"<p>Alternative naming</p> <p>This score is also known as <code>input performance</code> in the SLA API response.</p> <p>All scanners report the latest known block in the batches they send. This score is calculated by measuring a scanner's distance to the latest block at the time of reporting.</p> <p>Each scanner reports at an arbitrary time within any given minute. If the scanner reported at 13:05:34, then the closest block can be estimated by using:</p> <ul> <li><code>report_time_seconds</code>: Seconds elapsed within a given minute. This value is 34.</li> <li><code>current_minute_max</code>: The highest block reported in minute 13:05:00. Let's use 20.</li> <li><code>previous_minute_max</code>: The highest block reported in minute 13:04:00. Let's use 12.</li> </ul> <p>and then by doing</p> <pre><code>previous_minute_max + ((current_minute_max - previous_minute_max) * (report_time_seconds / 60))\n</code></pre> <p>If we evaluate the numbers above, the elapsed blocks can be calculated as 5 and the estimated block number becomes <code>12 + 5 = 17</code>. Then this number is compared with the block number the scanner reported and divided by a threshold. There are two possible outcomes:</p> <ul> <li>If the reported block is at least 17, then the score is 1.</li> <li>If the reported block is e.g. 15 and the threshold is 10 blocks, then the score is <code>1 - ((17 - 15) / 10) = 0.8</code>.</li> </ul> <p>Reporting too high block numbers</p> <p>The SLA calculation takes into account that some scanners can report extremely high block numbers. The selection of max numbers and final SLA calculation makes sure that these scanners are defaulted to zero because of their faulty operation.</p>"},{"location":"sla/#proof-of-detection","title":"Proof of Detection","text":"<p>Scan nodes must execute assigned bots, provide metrics and deliver any alerts emitted by them. If a scan node falsely claims bot execution, censors or tampers with any alert, SLA score will be 0 for the whole scan node pool for the calculated hour.</p> <p>There are two types of failures:</p>"},{"location":"sla/#missing-proof","title":"Missing Proof","text":"<p>If a scan node sends more than 30 <code>agent.health.success</code> metrics, the mechanism assumes that the bot was healthy enough to emit a proof. In case the node does not emit an alert, it will be treated as Proof of Detection failure.</p>"},{"location":"sla/#bad-proof","title":"Bad Proof","text":"<p>SLA calculator recalculates the hash given by the bot. If there is a mismatch, then it means that the node did not do the work it was deemed to do and fails Proof of Detection.</p>"},{"location":"sla/#uptime-score","title":"Uptime Score","text":"<p>Alternative naming</p> <p>This score is also known as <code>reporting success</code> in the SLA API response.</p> <p>Scanners must send data at regular intervals so that the network can deliver timely alerts. The nodes send a batch file to the Forta API</p> <ul> <li>every 15 seconds if the node is running bots and there are new alerts,</li> <li>every 1 minute if the node is running bots but there are no alerts,</li> <li>a few times in an hour if the node is not running any bots.</li> </ul> <p>The minute score of uptime is the percent difference between the number of batches and the expected number of batches.  Due to timing and alert rate, this count can fluctuate between 0 and 5 in a minute, but this does not impact the SLA very much, because the score is not weighted as high as others.</p> <p>If data is not being sent at all, all other scores will be impacted as well.</p> <p>Hourly uptime is measured by adding up all of the minute scores within an hour. While idle scan nodes are expected to report at a lower rate, the bot-assigned nodes are expected to report every minute. In both situations, the uptime score derived from the sum falls proportionally as the total score from reported minutes approaches zero.</p> <pre><code>uptime score = 1 - ( abs ( number of batches - 4 ) ) / 4 )\n</code></pre>"},{"location":"sla/#examples","title":"Examples","text":""},{"location":"sla/#node-is-5-blocks-behind-on-mainnet","title":"Node is 5 blocks behind on mainnet","text":"<p>Subscores</p> <ul> <li>Resource score is 1</li> <li>Data Quality Score is 0.8837</li> <li>Uptime score is 1</li> </ul> <p>Calculation  <pre><code>SLA = minimum( \n    1, \n    weighted_average( \n        5 * .8837,\n        1 * 1\n    ) \n)\n</code></pre></p> <p>Score is 0.9031</p>"},{"location":"sla/#node-is-100-blocks-behind-on-mainnet","title":"Node is 100 blocks behind on mainnet","text":"<p>(mainnet uses ~13s blocks, yielding 43 blocks in 10 minutes)</p> <p>Subscores</p> <ul> <li>Resource score is 1</li> <li>Data Quality Score is 0, because 43 blocks is the threshold</li> <li>Uptime score is 1</li> </ul> <p>Calculation  <pre><code>SLA = minimum( \n    1, \n    weighted_average( \n        5 * 0,\n        1 * 1\n    ) \n)\n</code></pre></p> <p>Score is 0.166666</p>"},{"location":"sla/#node-does-not-support-trace_block-on-mainnet","title":"Node does not support trace_block on mainnet","text":"<p>Subscores</p> <ul> <li>Resource score is 0</li> <li>Data Quality Score is 1</li> <li>Uptime score is 1</li> </ul> <p>Calculation  <pre><code>SLA = minimum( \n    0, \n    weighted_average( \n        5 * 1,\n        1 * 1\n    ) \n)\n</code></pre></p> <p>Score is 0</p>"},{"location":"sla/#node-does-not-support-trace_block-on-polygon","title":"Node does not support trace_block on polygon","text":"<p>Subscores</p> <ul> <li>Resource score is 1  (because trace is not required for polygon)</li> <li>Data Quality Score is 1</li> <li>Uptime score is 1</li> </ul> <p>Calculation  <pre><code>SLA = minimum( \n    1, \n    weighted_average( \n        5 * 1,\n        1 * 1\n    ) \n)\n</code></pre></p> <p>Score is 1</p>"},{"location":"slashing-creating-proposal/","title":"Creating a Slashing Proposal.","text":"<p>Anyone who detects a slashable offence perpetrated by a Scan Node or Bot may report a Slash Proposal, if they meet the following requirements:</p>"},{"location":"slashing-creating-proposal/#requirements","title":"Requirements.","text":"<ul> <li>Have 1000 FORT bridged to Polygon, per proposal.  This deposit can be slashed if the proposal does not follow appropriate formatting, it is malicious, false or spam. Check the slashing process for more info.</li> <li>Present verifiable evidence, in the form of screen captures, log files or any file that proves the accusations.</li> <li>Have knowledge of uploading files to IPFS.</li> <li>Is able to present evidence following Forta's Evidence Format</li> <li>Is able to interact with the SlashingController contract, either via PolygonScan or interacting directly with the contracts via a web3 library and a JSON RPC endpoint.</li> </ul> <p>Proposal Deposit slashing</p> <p>This deposit can be slashed if the proposal does not follow appropriate formatting and file limitations (see below), it is malicious, false or spam. Follow carefully this guide to follow the correct conventions.</p>"},{"location":"slashing-creating-proposal/#1-preparing-evidence","title":"1. Preparing Evidence","text":"<p>Each case can have several files with evidence (logs, screenshots), and each evidence file should have a JSON file describing it, both hosted and pinned in IPFS.</p> <p>Both evidence file and evidence descriptor must be downloadable during the Slash Proposal lifecycle, or the Slash Deposit might be slashed and the Slash Proposal not executed.</p>"},{"location":"slashing-creating-proposal/#file-limitations","title":"File limitations","text":"<ul> <li>Max file size, 500 Mbytes.</li> <li>Allowed extensions: .txt, .jpg, .jpeg, .png, .pdf, .webm, .mpg</li> </ul> <p>Evidence description JSON:</p> <pre><code>{\n\n    \u201cfileURI\u201d: string,\n    \u201cfileHash\u201d: string,\n    \u201cfileTypeExtension\u201d: string,\n    \u201cname\u201d: string,\n    \u201cdescription\u201d: string,\n    \u201cchecksum\u201d: string\n\n}\n</code></pre> <ul> <li>fileURI: IPFS URI of the evidence, example: \u201c/ipfs/QmWQV5ZFFhEJiW8Lm7ay2zLxC2XS4wx1b2W7FfdrLMyQQc\u201d</li> <li>fileHash: IPFS file hash, example: \u201cQmWQV5ZFFhEJiW8Lm7ay2zLxC2XS4wx1b2W7FfdrLMyQQc\u201d</li> <li>fileTypeExtension:\u201dtxt\u201d, \u201cpdf\u201d, \u201cpng\u201d or \u201cjpg\u201d</li> <li>fileName: name of the file</li> <li>description: description of what the evidence portrays. 500 char max.</li> <li>checksum: keccak256 hash of all the other concatenated key,value pairs of the JSON.</li> </ul> <p>Example js script producing an evidence descriptor JSON:</p> <pre><code>const evidenceDescriptor = {\n    fileURI: 'ipfs://bafybeihmnuxjiq4vd4r3ga3cebcn43o7v7nsovdn2n6rqis23dohcja72u/',\n    fileHash: 'bafybeihmnuxjiq4vd4r3ga3cebcn43o7v7nsovdn2n6rqis23dohcja72u',\n    fileTypeExtension: 'txt',\n    fileName: 'logs',\n    description: 'The logs provided in the file proves the Scanner Node 0x123 registered in Scanner Pool 456... is censuring the alerts from my bot',\n    checksum: null,\n};\n\nconst unhashedChecksum = Object.keys(evidenceDescriptor)\n    .filter((key) =&gt; key !== 'checksum')\n    .reduce((prev, key) =&gt; `${prev}${key}${evidenceDescriptor[key]}`, '');\n\nevidenceDescriptor.checksum = ethers.utils.id(unhashedChecksum);\nfs.writeFileSync('./evidence_1.json', JSON.stringify(evidenceDescriptor, null, 2));\n</code></pre> <p>And the resulting file:</p> <pre><code>{\n  \"fileURI\": \"ipfs://bafybeihmnuxjiq4vd4r3ga3cebcn43o7v7nsovdn2n6rqis23dohcja72u/\",\n  \"fileHash\": \"bafybeihmnuxjiq4vd4r3ga3cebcn43o7v7nsovdn2n6rqis23dohcja72u\",\n  \"fileTypeExtension\": \"txt\",\n  \"fileName\": \"logs\",\n  \"description\": \"The logs provided in the file proves the Scanner Node 0x123 registered in Scanner Pool 456... is censuring the alerts from my bot\",\n  \"checksum\": \"0x7c2c3e9954d792269b84ee976c29153771886ddd81d4b4073bc5d3f0eb0a9099\"\n}\n</code></pre>"},{"location":"slashing-creating-proposal/#2-approve-fort","title":"2. Approve FORT","text":"<ol> <li> <p>Go to the FORT token contract on Polygon</p> <ol> <li>Click on \"Contract\"</li> <li>Click on \"Write as Proxy\"</li> <li>Click on \"Connect to Web3\"    </li> </ol> </li> <li> <p>Approve the Slashing Controller contract address (0xTODO) to spend the amount for the slashing proposal deposit (1000 FORT in wei)</p> </li> </ol> <p>spender: 0x6927C25ff30ed86F86A863d987590A1d77509bDb</p> <p>amount: 1000000000000000000000</p> <p></p> <ol> <li>Confirm the transaction </li> </ol>"},{"location":"slashing-creating-proposal/#2-submitting-slash-proposal","title":"2. Submitting Slash Proposal","text":""},{"location":"slashing-creating-proposal/#21-open-slashingcontroller-contract-in-polygonscan","title":"2.1 Open SlashingController contract in Polygonscan","text":"<ol> <li> <p>Go to SlashingController's Polygonscan page,</p> <ol> <li>Click on \"Contract\"</li> <li>Click on \"Write as Proxy\"</li> <li>Click on \"Connect to Web3\"</li> </ol> </li> <li> <p>Go to \"7. ProposeSlash\" and input your parameters:</p> <ol> <li>_subjectType: 1 for Detection Bot, 2 for Scanner Pool</li> <li>_subjectId: a Scanner Pool ID or Bot ID</li> <li>_penaltyId: The keccak256 hash of the slash reason, in uppercase separated by underscores.<ol> <li>MISCONDUCT_SLASH: 0xe147df3b4755943b8e7219d7acfd0fd67879bdbf5f62537886a5e2acd476ee7d</li> <li>OPERATIONAL_SLASH: 0x602d37be0dfc88daa6b674e3c42ff4efabf3e86cef482bce18b643e8c0a1b33c</li> </ol> </li> <li>_evidence: Array of IPFS file URLs of the proposal's evidence descriptor JSONs (at least 1, up to 5)</li> </ol> </li> <li> <p>Click \"Write\" and Approve the transaction to submit the evidence.</p> </li> <li> <p>Go to the transaction's page in Polygonscan. Go to the 'Logs' Tab and look for the event 'SlashProposalUpdated'. The second parameter is your Slash Proposal ID.</p> </li> </ol>"},{"location":"slashing-creating-proposal/#3-check-slash-proposal-state","title":"3. Check Slash Proposal state","text":"<p>After submitting the proposal, the Slashing Arbiters will review it, possibly modifying the slash type or subject it targets (with new evidence).</p> <p>To check the status of your proposal, you can:</p> <ol> <li> <p>Go to SlashingController's Polygonscan page,</p> <ol> <li>Click on \"Contract\"</li> <li>Click on \"Read as Proxy\";</li> </ol> </li> <li> <p>Go to \"11. currentState\", input your SlashProposal ID, and click Query.</p> </li> </ol> <p></p> <p>The return value will be a number, here is the meaning (To learn more, see the Slashing Policy)</p> <p>0: UNDEFINED (the Slash Proposal ID might be wrong, this Slash Proposal has not been created).</p> <p>1: CREATED (proposal just created and awaiting review, the stake of the subject id is frozen).</p> <p>2: REJECTED (proposal has been rejected by a Slashing Arbiter. The Slash Proposer's deposit has been sent to the treasury. Stake unfrozen).</p> <p>3: DISMISSED (proposal has been dismissed by a Slashing Arbiter. The Slash Proposer's deposit has been returned to the proposer. Stake unfrozen).</p> <p>4: IN_REVIEW (proposal being reviewed by a Slash Arbiter).</p> <p>5: REVIEWED (proposal is ready for a decision of the Slasher. The Slash Proposer's deposit has been returned to the proposer).</p> <p>6: EXECUTED (proposal executed, stake slashed and sent to the proposer and treasury, according to the current split parameters. Stake unfrozen).</p> <p>7: REVERTED (proposal not executed by Slasher. Stake unfrozen)</p>"},{"location":"slashing-policy/","title":"Slashing Policy","text":""},{"location":"slashing-policy/#slashing-in-the-forta-network","title":"Slashing in the Forta Network","text":"<p>Both Scanner Pool Owners and Detection Bots are required to stake FORT tokens in order to participate in the Forta Network and earn FORT rewards. Soon, delegated staking will allow other Forta community members to stake tokens on node operations. Staking aligns incentives amongst Network participants and also acts as a sybil resistance mechanism. As a further security feature, Network participants also risk their staked FORT being slashed as follows:</p> <ul> <li> <p>Slashing Scanner Pool Owners. Although the Forta work assignment algorithm takes into account SLA performance and pool owners that fail to execute their assigned work correctly should be organically pushed out of the Network over time, for additional reliability, Scanner Pool Owners are also subject to slashing if they fail to execute their assigned work correctly outside of the SLA factors or if they attempt misconduct.</p> </li> <li> <p>Slashing Detection Bots. Although Detection Bots are deployed via docker containers and must meet specific technical criteria in order to be assigned by the Forta work assignment algorithm, for additional reliability, Detection Bots are also subject to slashing if they fail to meet Detection Bot guidelines or negatively impact the Network, or attempt malicious behavior.</p> </li> </ul>"},{"location":"slashing-policy/#purpose-of-this-slashing-policy","title":"Purpose of this Slashing Policy","text":"<p>In FP-2, FORT token holders approved the implementation of slashing architecture to further secure the Network, which includes the endowment of two protocol roles to one or more multisigs that have the power to determine the outcome of technical complaints in the Network:</p> <ol> <li>Arbiter Multisig(s) - responsible for receiving, reviewing and resolving the outcome of complaints (in the form of Slashing Proposals) in the Forta Network </li> <li>Slasher Multisig(s) - responsible for approving and executing validated Slashing Proposals</li> </ol> <p>Since certain parts of the slashing architecture are not yet expressed in smart contract code running on-chain, the purpose of this Slashing Policy is to establish norms that guide the actions of multisig signors beyond what is currently expressed on-chain. This policy presumes that any signor that does not comply with the norms laid out in this Slashing Policy will be replaced via decentralized governance.</p> <p>The substance of this policy is intended to ensure that the Forta slashing architecture supports a healthy and robust Network where participants perform their work correctly, while minimizing the risk to honest participants of being economically penalized while interacting with the Forta Network in good faith.</p>"},{"location":"slashing-policy/#forta-slashing-process","title":"Forta Slashing Process","text":"<p>The entire Forta slashing process takes place on Polygon mainnet. If you need to bridge your FORT tokens from Ethereum to Polygon, check out this guide. Please carefully review the Technical Slashing Guidance provided at the bottom of this page to submit a final Slashing Proposal.</p>"},{"location":"slashing-policy/#i-proposal","title":"I. PROPOSAL","text":"<p>Any Proposer can submit an on-chain Slashing Proposal by following the Technical Slashing Guidance, which requires:</p> <ul> <li>the Proposer providing sufficient evidence substantiating the complaint against the Slashing Subject; and </li> <li>the Proposer making a 1000 FORT token deposit.</li> </ul> <p>The Proposer\u2019s 1000 FORT deposit is at risk of being slashed if the Arbiter determines the Slashing Proposal does not conform to the requirements herein, or it is deemed malicious. Therefore, the Proposer must take care to submit sufficient verifiable evidence (e.g. screen captures, log files, or any other file that proves the accusations) in accordance with the formatting and file limitations set out in the Technical Slashing Guidance. Such evidence must remain publicly accessible through the entire slashing process. </p> <p>If a Slashing Proposal is ultimately validated and executed, the FORT tokens of the Slashing Subject (which could include anyone who has delegated stake to such Slashing Subject) targeted by the Slashing Proposal will be slashed and distributed as follows:</p> <ul> <li>80% of slashed stake will go to the Proposer</li> <li>20% of slashed stake will be returned to a community treasury at 0xC99884BE6eEE5533Be08152C40DF0464B3FAE877 on Polygon</li> </ul>"},{"location":"slashing-policy/#ii-arbiter-review","title":"II. ARBITER REVIEW","text":"<p>The Arbiter is a protocol role responsible for receiving, reviewing and resolving technical complaints in the Forta Network. Following review of each Slashing Proposal, one of three possible outcomes will be determined by the Arbiter:</p> <ol> <li> <p>Withdrawn Slashing Proposal - no parties are penalized</p> <ul> <li>Slashing Proposal is withdrawn from the slashing process by the Arbiter following review</li> <li>1000 FORT token deposit returned to Proposer; no stake slashed from Slashing Subject</li> <li>e.g. Arbiter review surfaces additional evidence that renders Slashing Proposal complaint moot, or parties mutually agree to alternative resolution or withdraw complaint</li> </ul> </li> <li> <p>Denied Slashing Proposal: Proposer is penalized</p> <ul> <li>Slashing Proposal is denied as eligible by the Arbiter following review</li> <li>1000 FORT token deposit of Proposer is slashed to community treasury</li> <li>e.g. Arbiter review determines Slashing Proposal was made in bad faith or did not contain accurate or sufficient evidence proving misconduct</li> </ul> </li> <li> <p>Validated Slashing Proposal - Slashing Subject is penalized</p> <ul> <li>Slashing Proposal is validated as eligible for slashing by the Arbiter following review and is classified as an \u201cOperational\u201d or \u201cMisconduct\u201d complaint as set out below</li> <li>1000 FORT token deposit returned to Proposer</li> <li>e.g. Arbiter review determines Slashing Proposal was made in good faith and evidence is sufficient for Arbiter to determine outcome</li> </ul> </li> </ol> <p>Following receipt of a Slashing Proposal, the Arbiter shall make best efforts to determine the outcome of a Slashing Proposal within 10 days. All activity undertaken by the Arbiter pursuant to this policy will be published in the Discord channel #slashing-proposals in advance of being executed on-chain, subject to redaction only where necessary to protect the security or integrity of the Forta Network. This disclosure should include the determination made by the Arbiter accompanied by the reasoning for reaching such a determination. </p>"},{"location":"slashing-policy/#iii-executing-validated-slashing-proposals","title":"III. EXECUTING VALIDATED SLASHING PROPOSALS","text":"<p>The Arbiter address will confirm any Validated Slashing Proposal as either an \u201cOperational\u201d or \u201cMisconduct\u201d complaint, with the following consequences:</p> <ol> <li> <p>Misconduct Complaint - Slashing Subject at risk of up to 90% slash (if executed by Slasher Multisig). For example:</p> <ul> <li>Censoring, forging or tampering with bots alerts</li> <li>Forging or failing to provide performance metrics</li> <li>Bot is part of an attack against Network or its participants</li> <li>Any other evidenced misconduct in the Network</li> <li>Bots whose alert misrepresents the purpose stated on their description or that fail to alert subscribers in the way they advertise</li> <li>Any other evidenced operational failures in the Network</li> </ul> <p>The pool owner stake will be slashed by up to 90% of his staking in the scanner node.</p> <p>A percentage of 30% of the slashed amount to the pool owner will also be slashed from the delegated stake to that pool.</p> </li> <li> <p>Operational Complaint - Slashing Subject at risk of up to 15% slash (if executed by Slasher Multisig). For example:</p> <ul> <li> <p>Scanner Pool Slashing Subject:</p> <ul> <li>Failure to run a Node with the minimum technical requirements set out in the Forta Docs</li> <li>Failure to run a Node at expected quality standards not captured by the SLA calculation</li> </ul> <p>The pool owner stake will be slashed by up to 90% of his staking in the scanner node.</p> <p>A percentage of 30% of the slashed amount to the pool owner will also be slashed from the delegated stake to that pool.</p> </li> <li> <p>Detection Bot Slashing Subject:</p> <ul> <li>Bots that clog the network (spam)</li> <li>Bots that inappropriately affect Scanner Node SLAs</li> <li>Bots that demand an excessive amount of resources from Scanner Nodes</li> </ul> </li> </ul> </li> </ol> <p>The on-chain rules are the ultimate authority of this logic, and in the case where the on-chain rules differ from this, it will prevail.</p>"},{"location":"slashing-policy/#iv-execution-of-slashing","title":"IV. EXECUTION OF SLASHING","text":"<p>Following review and resolution of a Validated Slashing Proposal by the Arbiter as either \u201cOperational\u201d or \u201cMisconduct\u201d, a Proposal will be delivered to the following Ethereum addresses for final review and, if thought appropriate, execution of a Slashing Proposal:</p> <p>Misconduct Complaints - the Forta Governance Council Multisig</p> <p>Operational Complaints - the Arbiter Multisig</p> <p>If the Arbiter alters the original classification of a Slashing Proposal from Malicious to Operational or vice-versa, it must provide evidence justifying such alteration on-chain and in Discord.</p>"},{"location":"slashing-policy/#arbiter-multisig-delegation","title":"Arbiter Multisig Delegation","text":"<p>Initially, the Arbiter role will be delegated by the Forta Governance Council to a 2-of-3 Gnosis Safe multisig dubbed the Community Arbitration Committee (the \u201cCAC\u201d). The CAC will determine if each Slashing Proposal is complete and being made in good faith, by investigating the evidence submitted and following up with stakeholders as necessary. Following review, the CAC will publish its determination and reasoning in the #slashing-proposals Discord channel and thereafter execute such decisions on-chain.</p> <p>The initial members of the CAC include (Discord usernames, as found in #slashing-proposals):</p> <ul> <li>ba3is#1622</li> <li>slanders#4806</li> <li>0xRoberto#8830</li> </ul> <p>If members of the CAC do not stay aligned with the community and resolve disputes appropriately, the Forta community may lobby the Council to remove or replace a member, through an FPP proposal or directly.</p> <p>Conflicts of Interest. Slashing Proposals could pose a conflict of interest due to a member of the CAC\u2019s activities in the Forta Network. If any CAC member believes that they are conflicted with respect to a Slashing Proposal, they must disclose such conflict.</p> <p>Compensation. Each member of the CAC shall receive 160 FORT for each Slashing Proposal reviewed and processed, paid by the Network monthly.</p> <p>Liability. The only recourse for the CAC not fulfilling their duties under this Slashing Policy is to be replaced via the Forta community governance process. The CAC has no legal or fiduciary responsibility to any stakeholder in the Forta Network and cannot be held responsible for any consequence that arises from Network participant behavior or any economic penalties incurred by stakeholders involved with the slashing process.</p>"},{"location":"slashing-policy/#transparency","title":"TRANSPARENCY","text":"<p>All data related to staking and slashing in the Forta Network is publicly available on the Polygon network for review. In addition, all activity undertaken by the Arbiter pursuant to this policy will be published in the Discord channel #slashing-proposals in advance of being executed on-chain, subject to redaction only where necessary to protect the security or integrity of the Forta Network. This disclosure should include posting what decisions and classifications were made and a summary of the reasoning. Any Slashing Proposal decided upon by the Council will be published in Council minutes according to the Council Bylaws. </p>"},{"location":"slashing-policy/#illustrated-process","title":"Illustrated process","text":""},{"location":"smart-contracts/","title":"Smart Contracts","text":"<p>This page provides a complete list of the Forta smart contracts as well as serving as links to their respective doc pages. The repo for them can be found here.</p>"},{"location":"smart-contracts/#accessmanager","title":"AccessManager","text":""},{"location":"smart-contracts/#agentregistry","title":"AgentRegistry","text":""},{"location":"smart-contracts/#dispatch","title":"Dispatch","text":""},{"location":"smart-contracts/#meta-transaction","title":"Meta-transaction","text":""},{"location":"smart-contracts/#scanner-pool-registry","title":"Scanner Pool Registry","text":""},{"location":"smart-contracts/#scanner-registry","title":"Scanner Registry","text":""},{"location":"smart-contracts/#scanner-to-scanner-pool-migration","title":"Scanner To Scanner Pool Migration","text":""},{"location":"smart-contracts/#staking","title":"Staking","text":""},{"location":"smart-contracts/#allocation","title":"Allocation","text":""},{"location":"smart-contracts/#stake-allocator","title":"Stake Allocator","text":""},{"location":"smart-contracts/#rewards","title":"Rewards","text":""},{"location":"smart-contracts/#accumulators","title":"Accumulators","text":""},{"location":"smart-contracts/#rewards-distributor","title":"Rewards Distributor","text":""},{"location":"smart-contracts/#slashing","title":"Slashing","text":""},{"location":"smart-contracts/#slashing-controller","title":"Slashing Controller","text":""},{"location":"smart-contracts/#slash-reasons","title":"Slash Reasons","text":""},{"location":"smart-contracts/#stake-subjects","title":"Stake Subjects","text":""},{"location":"smart-contracts/#delegated-stake-subject","title":"Delegated Stake Subject","text":""},{"location":"smart-contracts/#direct-stake-subject","title":"Direct Stake Subject","text":""},{"location":"smart-contracts/#stake-subject-gateway","title":"Stake Subject Gateway","text":""},{"location":"smart-contracts/#forta-staking","title":"Forta Staking","text":""},{"location":"smart-contracts/#forta-staking-utils","title":"Forta Staking Utils","text":""},{"location":"smart-contracts/#subject-type-validator","title":"Subject Type Validator","text":""},{"location":"smart-contracts/#utils","title":"Utils","text":""},{"location":"smart-contracts/#access-managed","title":"Access Managed","text":""},{"location":"smart-contracts/#forwarded-context","title":"Forwarded Context","text":""},{"location":"smart-contracts/#reentrancy-guard-handler","title":"Reentrancy Guard Handler","text":""},{"location":"smart-contracts/#routed","title":"Routed","text":""},{"location":"smart-contracts/#state-machines","title":"State Machines","text":""},{"location":"smart-contracts/#base-component-upgradeable","title":"Base Component Upgradeable","text":""},{"location":"smart-contracts/#roles","title":"Roles","text":""},{"location":"stablecoin-starter-kit/","title":"Stablecoin Threat Detection Kit","text":"<p>Frequent Doc Updates</p> <p>Forta will continue to add more curated security bots in the coming months, so stay tuned and come check this page frequently for new updates!</p> Bot Name Bot Details/Template Link Bot Description Anomalous Token Transfers Detection Machine Learning Bot Bot Details Alerts on anomalous transactions with erc2 token transfers. Anomalous Transaction Volume Bot Details Alerts on anomalous transaction volume (both successful and failed). Attack Detector Feed (aka Alert Combiner) Bot Details Combines past alerts under a common address to emit a high precision alert around protocol attacks. Chainalysis Sanctioned Addresses Bot Details Alerts when a Chainalysis sanctioned account interacts with the address monitored. Exploiter Addresses Bot Details Alerts when known exploiter address interacts with the address monitored. FlashBots Detector Bot Details Alerts when a transaction is routed through FlashBots framework bypassing the mempool. Flash Loan Detector Bot Details Alerts when a flash loan results in large profits indicative of an attack Ice Phishing Detection Bot Bot Details Alerts when ice phishing (social engineer users into token approvals) for a token contract monitored. Large Balance Decreases Template available on Bot Wizard \ud83e\uddd9 Identifies when the balance of an account decreases significantly. Note, this template has been deployed for the following bridges: Polygon, Avalanche, Arbitrum, Near/Aurora, Optimism, Harmony, xDAI, Boba, Ronin, THORChain and Multychain/Anyswap. Mint/Borrow Value Anomalies Bot Details Alerts when mint/borrow volume is changing in a statistically significant way. Monitor Events Template available on Bot Wizard \ud83e\uddd9 Monitors blockchain transactions for specified events emitted from specified contract addresses. This template can be used to alert events emitted from functions that should only be callable by privileged roles. USDT USDC Blocklist Events Monitor used this template to monitor stablecoin providers' blocklists. To subscribe to this bot, please visit this bot page and click on \"Subscribe to this bot\". Monitor Function Calls Template available on Bot Wizard \ud83e\uddd9 This bot monitors blockchain transactions for specific function calls to specific contract addresses. This template can be used to alert on function calls that should only be callable by privileged roles. OpenZeppelin-Gnosis Safe Contract Events Bot Details Alerts on security relevant events of the OZ contract library/ Gnosis Safe contact instances. Price Change Anomalies Bot Details Stablecoin Interaction with DeFi Protocols NA Alerts stablecoin token transfer events emitted by the OpenZeppelin-Gnosis Safe Contract Events Bot. Token transfers sent to selected DeFi Smart Contracts such as Balancer Vault, 1inch Exchange, Uniswap Router, SushiSwap Router, and PancakeSwap Router are alerted. Successful transactions with internal failures Bot Details Alerts on transactions involving the address monitored that succeed, but had internal failures. Suspicious Contract Creation Bot Details Alerts on contract creation that contained the address monitored. Time Series Analyzer Template Template available on Bot Wizard \ud83e\uddd9 This template turns an underlying noisy alert representing a time series into a statistically meaningful alert when values become abnormal. Tornado Cash Funded Account Interaction Bot Details Alerts when a Tornado Cash funded account interacts with the address monitored. Unverified Contract Creation Bot Details Alerts on contract creation that isnt verified on Etherscan."},{"location":"stake-on-detection-bot/","title":"Staking on Detection Bots","text":"<p>This page will describe how to stake on Forta Network detection bots. Staking on bots occurs on Polygon mainnet. If you need to bridge your FORT tokens from Ethereum to Polygon check out this guide.</p>"},{"location":"stake-on-detection-bot/#staking-using-forta-app-recommended","title":"Staking using Forta App (recommended)","text":"<ol> <li>Go to https://app.forta.network/bots</li> <li>Search for the bot you want to stake on. In this example we are going to stake on a bot from Lido (but you can choose any bot you prefer).</li> <li>Click on \"Add Stake\"    </li> <li>Enter the amount of FORT to stake on the bot.    </li> <li>Confirm the transaction    </li> </ol>"},{"location":"stake-on-detection-bot/#staking-using-polygonscan","title":"Staking using Polygonscan","text":""},{"location":"stake-on-detection-bot/#approve-fort","title":"Approve FORT","text":"<ol> <li>Go to the FORT token contract on Polygon<ol> <li>Click on \"Contract\"</li> <li>Click on \"Write as Proxy\"</li> <li>Click on \"Connect to Web3\"    </li> </ol> </li> <li>Approve the Forta Staking contract address (0xd2863157539b1D11F39ce23fC4834B62082F6874) to spend a specified amount of FORT (in Wei units)    </li> <li>Confirm the transaction </li> </ol>"},{"location":"stake-on-detection-bot/#stake-fort","title":"Stake FORT","text":"<p>Once approved, you can search for a bot by name using Forta App</p> <ol> <li>Go to https://app.forta.network/bots</li> <li>Search for the bot you want to stake on. In this example we are going to stake on a bot from Lido (but you can choose any bot you prefer). The bot ID can be found on the Bot Report Page specific to each bot on Forta App<ol> <li>Search for the bot</li> <li>Copy the bot ID    </li> </ol> </li> <li>Go to the Forta Staking contract page<ol> <li>Click on \"Connect to Web3\"</li> <li>In the \"deposit\" section, enter 1 for the \"subjectType\" field</li> <li>Enter the bot ID you copied from Forta App in the \"subject\" field</li> <li>Enter the amount of FORT to stake (in Wei units) in the \"stakeValue\" field    </li> </ol> </li> <li>Confirm the transaction </li> </ol>"},{"location":"starter-kit-bot-details/","title":"Starter Kit Bot Details","text":"<p>Frequent Doc Updates</p> <p>Forta will continue to add more curated security bots in the coming months, so stay tuned and come check this page frequently for new updates!</p>"},{"location":"starter-kit-bot-details/#anomalous-token-transfers-detection-machine-learning-bot","title":"Anomalous Token Transfers Detection Machine Learning Bot","text":"Bot Name Bot Stats Bot Source Code Supported Chains Anomalous Token Transfers Detection Machine Learning Bot Stats URL Github Repo URL Ethereum Mainnet <p>This bot utilizes the Isolation Forest machine learning technique to detect anomalous transactions with ERC20 token transfers.</p>"},{"location":"starter-kit-bot-details/#anomalous-transaction-volume","title":"Anomalous Transaction Volume","text":"Bot Name Bot Stats Bot Source Code Supported Chains Successful txn Stats URL Github Repo URL Ethereum Mainnet, BNB Chain, Polygon, Optimism, Fantom, Arbitrum, Avalanche <p>This bot detects successful transactions that have one or more failed internal transactions.</p>"},{"location":"starter-kit-bot-details/#asset-drained","title":"Asset Drained","text":"Bot Name Bot Stats Bot Source Code Supported Chains Asset Drained Bot Stats URL Github Repo URL Ethereum Mainnet, BNB Chain, Fantom, Avalanche <p>This bot detects when digital assets are fully drained from a contract.</p>"},{"location":"starter-kit-bot-details/#attack-detector-feed-aka-alert-combiner","title":"Attack Detector Feed (aka Alert Combiner)","text":"Bot Name Bot Stats Bot Source Code Supported Chains Attack Detector Feed Stats URL Github Repo URL All <p>The attack detector takes past alerts under a common address from a variety of underlying bots to emit a high precision alert for protocol attacks. It does so by mapping each alert to the four attack stages (Funding, Preparation, Exploitation and Money Laundering) and applying a variety of heuristics (e.g. an alert has to exist for each of the four stages) to emit an alert.</p>"},{"location":"starter-kit-bot-details/#chainalysis-sanctioned-addresses","title":"Chainalysis Sanctioned Addresses","text":"Bot Name Bot Stats Bot Source Code Supported Chains Chainalysis Sanctioned Addresses Stats URL Github Repo URL All <p>This bot detects transactions that involve Chainalysis sanctioned addresses.</p> <p>The bot listens to the Chainalysis Sanction Oracle Contract's sanctioned events and maintains a local list of sanctioned addresses.</p>"},{"location":"starter-kit-bot-details/#evidence-of-phishing-bot","title":"Evidence of Phishing Bot","text":"Bot Name Bot Stats Bot Source Code Supported Chains Evidence of Phishing Agent Stats URL Github Repo URL Ethereum Mainnet <p>Users approving token transfers to an address or contract may be a behavior indicative of an ice phishing attack.</p> <p>This bot detects when a high number of EOAs call the approve() or increaseAllowance() methods for the same target EOA/ contract over an extended period of time. This bot emits two types of alerts: first for the approvals that occurred and another when the attacker is making the transfers.</p>"},{"location":"starter-kit-bot-details/#exploiter-addresses","title":"Exploiter Addresses","text":"Bot Name Bot Stats Bot Source Code Supported Chains Exploiter Addresses Stats URL Github Repo URL All <p>This bot detects transactions that involve known exploiter addresses.</p>"},{"location":"starter-kit-bot-details/#flashbot-detection-bot","title":"Flashbot Detection Bot","text":"Bot Name Bot Stats Bot Source Code Supported Chains Flashbots Detection Bot Stats URL Github Repo URL Ethereum Mainnet <p>This bot detects if a transaction was made using Flashbots bypassing the mempool.</p>"},{"location":"starter-kit-bot-details/#flashloan-detection-bot","title":"Flashloan Detection Bot","text":"Bot Name Bot Stats Bot Source Code Supported Chains Flashloan Detection Bot Stats URL Github Repo URL Ethereum Mainnet, Optimism, BNB Chain, Polygon, Fantom, Arbitrum, Avalanche <p>This bot detects if a transaction contains a flashloan and the borrower made a significant profit.</p>"},{"location":"starter-kit-bot-details/#mintborrow-anomaly-detection-bot","title":"Mint/Borrow Anomaly Detection Bot","text":"Bot Name Bot Stats Bot Source Code Supported Chains Large Mint Borrow Volume Anomaly Detection Stats URL Github Repo URL Ethereum Mainnet <p>This bot detects if an anomalous volume of mints and/or borrows occurs.</p>"},{"location":"starter-kit-bot-details/#nft-sleep-minting-detection","title":"NFT Sleep Minting Detection","text":"Bot Name Bot Stats Bot Source Code Supported Chains NFT Sleep Minting Detection Stats URL Github Repo URL Ethereum Mainnet <p>This bot detects transactions that may indicate NFT Sleep Minting.</p> <p>Sleep Minting is when an attacker mints an NFT directly to a famous creator's wallet with permission to reclaim or pull the NFT back out of the creator's wallet. This creates the appearance that (1) a famous creator minted an NFT to themselves, and (2) the creator sent that NFT to an attacker. Based on on-chain provenance, the attacker can claim they own an NFT created by a famous artist and sell it for a high value.</p> <p>You can read more about what this is and why it matters here</p>"},{"location":"starter-kit-bot-details/#openzeppelin-gnosis-safe-contract-events","title":"OpenZeppelin-Gnosis Safe Contract Events","text":"Bot Name Bot Stats Bot Source Code Supported Chains oz-gnosis-events Stats URL Github Repo URL Ethereum Mainnet, Polygon, Avalanche, Arbitrum, Optimism <p>This bot detects ALL events from smart contracts defined in the <code>openzeppelin-contracts</code> and <code>gnosis-safe</code> Github repositories</p>"},{"location":"starter-kit-bot-details/#price-change-anomaly","title":"Price Change Anomaly","text":"Bot Name Bot Stats Bot Source Code Supported Chains Smart Price Changes Agent Stats URL Github Repo URL Ethereum Mainnet <p>This bot detects when there are drastic price change anomalies based on on-chain price oracles (i.e. Uniswap and Uniswap derivatives.)</p>"},{"location":"starter-kit-bot-details/#reentrancy-counter","title":"Reentrancy Counter","text":"Bot Name Bot Stats Bot Source Code Supported Chains Reentrancy Calls Detection Bot Stats URL Github Repo URL Ethereum Mainnet, BNB Chain, Polygon <p>This bot detects reentrancy based on the call stack provided in the transaction traces. The bot reports the number of repeated calls with different severity levels.</p>"},{"location":"starter-kit-bot-details/#scam-detector-feed-aka-alert-combiner","title":"Scam Detector Feed (aka Alert Combiner)","text":"Bot Name Bot Stats Bot Source Code Supported Chains Scam Detector Feed Stats URL Github Repo URL All <p>The attack detector takes past alerts under a common address from a variety of underlying bots to emit a high precision alert related to scams (ice phishing, rug pulls, scams). It does so by combining alerts applying a variety of heuristics (e.g. ice phishing and tornado cash funding alert fired) to emit an alert.</p>"},{"location":"starter-kit-bot-details/#suspicious-contract-creation","title":"Suspicious Contract Creation","text":"Bot Name Bot Stats Bot Source Code Supported Chains Suspicious Contract Creation Stats URL Github Repo URL Ethereum Mainnet, BNB Chain, Polygon <p>This bot detects when a suspicious contract is created. A suspicious contract can take many forms; initially, this bot will alert on contracts that were created from Tornado cash funded accounts.</p>"},{"location":"starter-kit-bot-details/#token-impersonation","title":"Token Impersonation","text":"Bot Name Bot Stats Bot Source Code Supported Chains Token Impersonation Stats URL Github Repo URL Ethereum Mainnet <p>This bot detects if an ERC-20/ ERC-721/ ERC-1155 contract gets deployed with the same symbol of an existing deployed contract. This may be indicative of a scam or phishing attack.</p>"},{"location":"starter-kit-bot-details/#tornado-cash-funded-account-interaction","title":"Tornado Cash Funded Account Interaction","text":"Bot Name Bot Stats Bot Source Code Supported Chains Tornado Cash Funded Account Interaction Stats URL Github Repo URL Ethereum Mainnet, BNB Chain, Polygon, Arbitrum, Optimism <p>This bot detects when an account that was funded by Tornado Cash interacts with any contract.</p>"},{"location":"starter-kit-bot-details/#unverified-contract-creation","title":"Unverified Contract Creation","text":"Bot Name Bot Stats Bot Source Code Supported Chains Unverified Contract Creation Stats URL Github Repo URL Ethereum Mainnet, BNB Chain, Polygon <p>This bot detects when a contract is created that isn't verified on Etherscan within 30 min of creation.</p>"},{"location":"subscribing-to-bot/","title":"Subscribing to Alerts","text":"<p>The Forta Network allows users to access the intel generated by detection bots through a variety of methods. Intel can be accessed through the GraphQL API (pull) or by subscribing to a bot directly (push) and receiving notifications via email, Slack, Telegram, Discord or webhooks. Purchasing one or more network subscriptions will give users access to both. </p> <p>Here\u2019s a step-by-step guide to subscribing directly to a bot:</p>"},{"location":"subscribing-to-bot/#subscribing-from-the-bots-profile-page","title":"Subscribing from the Bot\u2019s Profile Page","text":"<p>Step 1: Search for the detection bot you\u2019d like to receive alerts from and go to its profile page in the Forta App. Make sure to sign in to the App with your wallet.</p> <p>Once in the bot\u2019s profile page, click on the \u201cSubscribe\u201d button at the top right. </p> <p>Note</p> <p>You will only see the \u201cSubscribe\u201d button if you have already purchased the corresponding plan (or received a free trial) with the wallet you have signed in with.</p> <p></p> <p>Step 2: A new window will appear with a subscription form with the Bot ID pre-filled. You will have the option to add custom filters (e.g. only receive alerts related to a specific address), and be asked to select your preferred notification channel (Slack, Telegram, Email, Discord or Webhook).  </p> <p></p> <p>Step 3: After you\u2019ve made your selections, click \u201cSubscribe\u201d. Depending on how active the bot is, you may start receiving alerts within a few minutes.</p>"},{"location":"subscribing-to-bot/#subscribing-to-a-bot-my-subscriptions-tab-in-forta-app","title":"Subscribing to a Bot My Subscriptions tab in Forta App","text":"<p>Step 1: Navigate to https://app.forta.network/ and connect your wallet. </p> <p>Step 2: Click on your wallet address in the top right corner in order to reveal a dropdown menu and click on \u2018My Subscriptions\u2019.</p> <p></p> <p>Step 3: Here you can manage your list of different subscriptions. If this is your first time setting up a subscription, you will need to click on the purple \u2018Add Subscription\u2019 button and a window will appear. </p> <p></p> <p>Step 4: Here you will be able to enter the bots from which you want to receive real time alerts from and the method in which you would prefer to receive them. </p> <p>Paste the Bot ID and configure your custom filters and notification channel.</p> <p>Note<p>The Bot ID can be found in each detection bot\u2019s profile page. Simply click on the Bot ID and it will be copied to the clipboard.</p> </p>"},{"location":"subscribing/","title":"Subscribing to alerts","text":""},{"location":"subscribing/#using-forta-app","title":"Using Forta App","text":"<p>You can subscribe to alerts generated by your bot using the Forta App subscriptions page. You will first need to connect your Metamask wallet and sign a message to authenticate. Then you can create subscriptions to a bot ID or a contract address. Forta App currently supports email, Slack, Telegram, Discord and webhooks.</p> <p>Check out this quick video tutorial on subscribing to alerts:</p> <p>Once subscribed, this is what a Slack notification would look like:</p> <p></p> <p>And here is what an email notification would look like:</p> <p></p>"},{"location":"subscribing/#using-openzeppelin-defender","title":"Using OpenZeppelin Defender","text":"<p>Alternatively, you could receive alerts using OpenZeppelin Defender, a security operations platform for Ethereum. Check out their Forta integration docs to learn more.</p> <p>Once you have your alert subscriptions set up, you are ready to learn about maintaining your bot.</p>"},{"location":"subscriptions-api/","title":"Subscriptions API","text":"<p>The Forta Subscriptions API is a REST API that allows developers to manage their bot subscriptions programmatically (vs managing them through the Forta App UI). This page describes the available API endpoints to manage your subscriptions.</p>"},{"location":"subscriptions-api/#getting-access","title":"Getting Access","text":"<p>In order to use the Subscriptions API, a Forta API key is required. You can use the Forta App UI to generate a new API key, which will return a <code>keyId</code> as well as an <code>apiKey</code>. Both fields will need to be set in the HTTP request's <code>Authorization</code> header in the format <code>Bearer keyId:apiKey</code>.</p>"},{"location":"subscriptions-api/#create-subscription","title":"Create Subscription","text":"<p><code>POST https://api.forta.network/subscriptions</code></p> <p>You can create a new subscription by sending a POST request to the API with a body that describes what exactly you want to subscribe to (i.e. to a specific bot or specific address). The currently supported notification types are email, Slack, Telegram, Discord and custom webhooks. A confirmation message will be sent to the specified channel when successfully subscribed (except for custom webhooks).</p>"},{"location":"subscriptions-api/#email-subscription","title":"Email Subscription","text":"<p>NOTE: a verification email will be sent after creating an email subscription which contains a verification link that must be clicked before notifications can be received.</p> <p>For example, to subscribe to a bot with ID <code>0xe5c0846e6ecdcd1a1d137e42039cf0afc366cb890c12f68f40adbda1d7596cff</code>, the request body would be:</p> <pre><code>{\n  \"scopeId\": \"agent|0xe5c0846e6ecdcd1a1d137e42039cf0afc366cb890c12f68f40adbda1d7596cff\",\n  \"notifyConfigs\": [\n    {\n      \"notifyType\": \"email\",\n      \"email\": \"example@gmail.com\"\n    }\n  ]\n}\n</code></pre>"},{"location":"subscriptions-api/#slack-subscription","title":"Slack Subscription","text":"<p>Once you have generated a Slack webhook, you can use it to receive alerts. For example, to subscribe to all alerts for address <code>0x473780deaf4a2ac070bbba936b0cdefe7f267dfc</code>, the request body would be:</p> <pre><code>{\n  \"scopeId\": \"address|0x473780deaf4a2ac070bbba936b0cdefe7f267dfc\",\n  \"notifyConfigs\": [\n    {\n      \"notifyType\": \"slack\",\n      \"webhook\": \"https://hooks.slack.com/services/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\"\n    }\n  ]\n}\n</code></pre>"},{"location":"subscriptions-api/#telegram-subscription","title":"Telegram Subscription","text":"<p>Once you have generated a Telegram bot token and chat ID, you can use them to receive alerts. For example, to subscribe to a bot with ID <code>0xe5c0846e6ecdcd1a1d137e42039cf0afc366cb890c12f68f40adbda1d7596cff</code>, the request body would be:</p> <pre><code>{\n  \"scopeId\": \"agent|0xe5c0846e6ecdcd1a1d137e42039cf0afc366cb890c12f68f40adbda1d7596cff\",\n  \"notifyConfigs\": [\n    {\n      \"notifyType\": \"telegram\",\n      \"webhook\": \"https://api.telegram.org?chat_id=1622956958&amp;token=110201543:AAHdqTcvCH1vGWJxfSeofSAs0K5PALDsaw\"\n    }\n  ]\n}\n</code></pre>"},{"location":"subscriptions-api/#discord-subscription","title":"Discord Subscription","text":"<p>Once you have generated a Discord webhook, you can use it to receive alerts. For example, to subscribe to all alerts for address <code>0x473780deaf4a2ac070bbba936b0cdefe7f267dfc</code>, the request body would be:</p> <pre><code>{\n  \"scopeId\": \"address|0x473780deaf4a2ac070bbba936b0cdefe7f267dfc\",\n  \"notifyConfigs\": [\n    {\n      \"notifyType\": \"discord\",\n      \"webhook\": \"https://discord.com/api/webhooks/991697143234568285/ooIjNE98YHXXQVpdeNadedwMtWRTk6xsE5fIgjufDeuI9mU-b7oIUu7sSvqS4l1l8RD_\"\n    }\n  ]\n}\n</code></pre>"},{"location":"subscriptions-api/#webhook-subscription","title":"Webhook Subscription","text":"<p>You can receive alerts at any custom webhook of your choice. For example, to subscribe to a bot with ID <code>0xe5c0846e6ecdcd1a1d137e42039cf0afc366cb890c12f68f40adbda1d7596cff</code>, the request body would be:</p> <pre><code>{\n  \"scopeId\": \"agent|0xe5c0846e6ecdcd1a1d137e42039cf0afc366cb890c12f68f40adbda1d7596cff\",\n  \"notifyConfigs\": [\n    {\n      \"notifyType\": \"webhook\",\n      \"webhook\": \"https://yourcustomwebhook.com\"\n    }\n  ]\n}\n</code></pre>"},{"location":"subscriptions-api/#list-subscriptions","title":"List Subscriptions","text":"<p><code>GET https://api.forta.network/subscriptions</code></p> <p>To list all of the subscriptions that your wallet address has, you can send a GET request to the subscriptions API. An example response would look like:</p> <pre><code>[\n    {\n        \"scopeId\": \"agent|0xe5c0846e6ecdcd1a1d137e42039cf0afc366cb890c12f68f40adbda1d7596cff\",\n        \"notifyId\": \"92306a4e-9c73-4ebf-8e3c-588c6893e8b0\",\n        \"address\": \"0x577022b59D1C25323ab524Fe88d2F6347b5C69f1\",\n        \"notifyConfigs\": [\n            {\n                \"notifyType\": \"email\",\n                \"email\": \"example@gmail.com\",\n                \"unsubscribeToken\": \"6bfbf583-f89b-4d64-9207-db7312e36342\"\n            }\n        ],\n        \"isVerified\": false,\n        \"isEnabled\": true,\n        \"groupIds\": null,\n        \"filter\": null,\n        \"createdAt\": \"2022-10-21T12:41:34.005415903Z\"\n    }\n]\n</code></pre>"},{"location":"subscriptions-api/#update-subscription","title":"Update Subscription","text":"<p><code>PUT https://api.forta.network/subscriptions/notifyId</code></p> <p>To update an existing subscription, you need to send a PUT request with the <code>notifyId</code> in the URL path. The subscription will be updated to whatever is in the request body (using same format as creating subscriptions).</p>"},{"location":"subscriptions-api/#get-subscription","title":"Get Subscription","text":"<p><code>GET https://api.forta.network/subscriptions/notifyId</code></p> <p>To get information about a specific subscription, you can send a GET request with the <code>notifyId</code> in the URL path.</p>"},{"location":"subscriptions-api/#delete-subscription","title":"Delete Subscription","text":"<p><code>DELETE https://api.forta.network/subscriptions/notifyId</code></p> <p>To delete an existing subscription (i.e. unsubscribe), you need to send a DELETE request with the <code>notifyId</code> in the URL.</p>"},{"location":"suspicious-events-feed/","title":"Get Started","text":""},{"location":"suspicious-events-feed/#what-is-a-threat-detection-kit","title":"What is a threat detection kit?","text":"<p>If you are new to Forta, a threat detection kit will help you get started on monitoring and protecting Web3 projects and assets right away with no custom bot development needed to get security-relevant value from Forta.</p> <p>A threat detection kit consists of security detection bots and bot templates created and curated by the Forta community and security experts.</p> <p>There are currently 5 threat detection kits available, each specifically tailored to monitor different parts of the Web3 ecosystem and detect threats.</p> <ul> <li>Bridge Threat Detection Kit</li> <li>DeFi Threat Detection Kit</li> <li>Governance Threat Detection Kit</li> <li>NFT Threat Detection Kit</li> <li>Stablecoin Threat Detection Kit</li> </ul>"},{"location":"suspicious-events-feed/#how-to-subscribe-to-threat-detection-kit-detection-bots","title":"How to subscribe to threat detection kit detection bots?","text":"<p>For each threat detection kit, security experts hand-picked a list of detection bots users can subscribe to to help identify a broad range of security-related events. By subscribing to these bots, you can receive alerts on suspicious and/or anomalous activities potentially occurring at any stage of an ongoing web3 attack. To learn more about how web3 attacks happen and how Forta can mitigate them, check out the Forta illuminates the Web3 Kill Chain Blog Post.</p>"},{"location":"suspicious-events-feed/#monitoring-your-wallet-or-contracts","title":"Monitoring your wallet or contracts","text":"<ol> <li>To subscribe, first visit the Forta App.</li> <li>Click on \"Monitor my contracts\" or \"Monitor my wallet\". If you clicked on \"Monitor my contracts\", select a threat detection kit.     </li> <li>Sign in with your wallet to continue.     </li> <li>Select or update the selected threat detection kit in the \"Select Subscription type\" dropdown.</li> <li>Add a contract/wallet address to watch. For contracts, it's recommended to create a subscription for each address pertaining to your protocol, including protocol-specific token contract addresses.</li> <li>Choose notification type and destination.</li> </ol>"},{"location":"suspicious-events-feed/#what-are-detection-bot-templates","title":"What are detection bot templates?","text":"<p>While the existing threat detection kit bots provide broad coverage for security-relevant issues, sometimes the bot needs protocol-specific information. Detection bot templates allow users to create these custom bots quickly without the need to develop one from scratch.</p> <p>Bot Wizard \ud83e\uddd9 is now available!</p> <p>Non-technical users can configure and create their own detection bots without touching any code via the bot wizard interface.</p> <p>Developers can get access to security detection bot and template source code to fork, customize, and contribute.</p>"},{"location":"testing/","title":"Testing your bot","text":"<p>Once you have initialized your bot, it\u2019s now time to test it. The code for a simple Forta detection bot can be found in the src/agent.ts file. The entry point for your bot will always be a file named agent.ts (or agent.js/agent.py if using Javascript/Python, respectively). At the end of this file, you will find:</p> <pre><code>export default {\n  handleTransaction,\n  handleBlock,\n};\n</code></pre> <p>We are exporting 2 functions inside of an object: <code>handleTransaction</code> and <code>handleBlock</code>. These functions are where the logic of your bot will live. As blocks and transactions are mined to the blockchain, these functions will be invoked with blockchain data to allow the bot to scan for certain conditions and return any findings. You can export either one or both of these functions based on your requirements.</p> <p>Let\u2019s take a closer look at the <code>handleTransaction</code> function:</p> <pre><code>const ERC20_TRANSFER_EVENT = \"event Transfer(address indexed from, address indexed to, uint256 value)\";\nconst TETHER_ADDRESS = \"0xdAC17F958D2ee523a2206206994597C13D831ec7\";\nconst TETHER_DECIMALS = 6;\n\nconst handleTransaction: HandleTransaction = async (txEvent: TransactionEvent) =&gt; {\n  const findings: Finding[] = [];\n\n  // filter the transaction logs for Tether transfer events\n  const tetherTransferEvents = txEvent.filterLog(ERC20_TRANSFER_EVENT, TETHER_ADDRESS);\n\n  // for each Tether transfer event\n  tetherTransferEvents.forEach((transferEvent) =&gt; {\n    // extract transfer event arguments\n    const { to, from, value } = transferEvent.args;\n    // shift decimals of transfer value\n    const normalizedValue = value.div(10 ** TETHER_DECIMALS);\n\n    // if more than 10,000 Tether were transferred, report it\n    if (normalizedValue.gt(10000)) {\n      findings.push(\n        Finding.fromObject({\n          name: \"High Tether Transfer\",\n          description: `High amount of USDT transferred: ${normalizedValue}`,\n          alertId: \"FORTA-1\",\n          severity: FindingSeverity.Low,\n          type: FindingType.Info,\n          metadata: {\n            to,\n            from,\n          },\n        })\n      );\n    }\n  });\n\n  return findings;\n};\n</code></pre> <p>The signature of this function is <code>(txEvent: TransactionEvent) =&gt; Promise&lt;Finding[]&gt;</code>. That is, it accepts a <code>TransactionEvent</code> as an input, and returns a Promise of an array of <code>Finding</code> objects. In this simple example, we check whether there are any Tether token transfer events above 10,000 USDT. If so, we flag the transaction by creating a <code>Finding</code> object. We then return what we found in the <code>findings</code> array. Pretty straightforward.</p>"},{"location":"testing/#manual-testing","title":"Manual testing","text":"<p>Now let\u2019s run this bot locally with some real data from Ethereum mainnet to see how it behaves. We can begin throwing blockchain data at our bot and observe the output with the command:</p> <pre><code>$ npm start\n</code></pre> <p>npm scripts</p> <p>The package.json file includes a set of npm scripts which invoke the <code>forta-agent</code> CLI tool. When invoking <code>npm start</code> to run the bot, we are using the <code>forta-agent run</code> command.</p> <p>This will run blocks and transactions against your bot as they are mined. By default, blockchain data is pulled from the Cloudflare Ethereum gateway. You can also specify a JSON-RPC provider in the forta.config.json file (located in ~/.forta) by uncommenting the <code>jsonRpcUrl</code> property and setting it to a HTTP provider (e.g. <code>https://mainnet.infura.io/v3/YOUR_INFURA_API_KEY</code>).</p> <p>Since our transfer value threshold is pretty high (10 thousand), we may not flag a lot of transactions. To quickly make changes and see them take effect, try changing the threshold to a lower number and save the agent.ts file. The bot should automatically restart with your new changes.</p> <p>It is also worth mentioning that bots are long-running processes. This means you can maintain state in-memory across blocks and transactions if needed. See the high transaction volume bot as an example of a stateful bot.</p>"},{"location":"testing/#getting-test-data","title":"Getting test data","text":"<p>If you are writing a bot targeting a particular protocol or contract, you likely already have a wealth of data on the blockchain which you can use to test your bot. By visiting a block explorer (e.g. Etherscan), you can browse the history of transactions on a contract.</p> <p>For example, you can visit the Tether token page on Etherscan and see a list of transfers. From there you can easily pick out a transaction (e.g. <code>0x338c6d7095228544f27ba8479aea6cadbe5aea98806a651f66ef30b3cd7e1813</code>) and run it against your bot using:</p> <p><pre><code>$ npm run tx 0x338c6d7095228544f27ba8479aea6cadbe5aea98806a651f66ef30b3cd7e1813\n</code></pre> You could also run your bot against all the transactions in a block using:</p> <pre><code>$ npm run block 13682565\n</code></pre> <p>Also, if you visit the transaction's details page on Etherscan, you can see more information such as the block number, amount of gas used and which function was invoked. The logs generated by the transaction can also be viewed under the Logs tab.</p>"},{"location":"testing/#trace-data","title":"Trace data","text":"<p>Detection bots can use trace data to get further insights into a transaction e.g. which contract function calls were made internally. These are also known as \"internal transactions\". Forta scan nodes currently provide trace data only for Ethereum mainnet through the <code>TransactionEvent.traces</code> field (for all other chains, the traces are an empty array). These traces are fetched using the <code>trace_block</code> RPC method of the OpenEthereum trace module.</p> <p>Not all detection bots will require trace data, but depending on the presence of trace data your detection bot may behave differently (e.g. the <code>TransactionEvent.filterFunction</code> utility method will use trace data to filter internal function calls if they are available). To enable trace data locally during development, set the <code>traceRpcUrl</code> in your forta.config.json to a RPC provider that supports the OpenEthereum trace module (e.g. typically a paid provider like Alchemy). It is also worth mentioning that in production, detection bots cannot query for trace data via the scan node's <code>jsonRpcUrl</code> (unless the bot provides its own RPC endpoint).</p>"},{"location":"testing/#automated-testing","title":"Automated testing","text":"<p>A complete bot testing strategy will include automated unit tests that can quickly verify the behaviour of the bot. For your convenience, unit tests are included in the starter projects as examples. We use the <code>jest</code> testing framework in the Javascript/Typescript projects, and <code>pytest</code> in the Python project. These are only suggestions and you should feel free to use whichever testing framework you prefer. You can run the included unit tests with the following command:</p> <pre><code>$ npm test\n</code></pre> <p>When writing unit tests, you can easily create mock transactions and blocks using the SDK methods <code>createTransactionEvent</code> and <code>createBlockEvent</code>. See here for an example. Also, you can easily write tests for bots that detect log events or function calls by mocking out the SDK methods <code>filterLog</code> and <code>filterFunction</code>. See here for an example.</p>"},{"location":"testing/#advanced-testing","title":"Advanced testing","text":"<p>For more advanced testing involving simulated transactions, check out the Advanced testing pattern.</p>"},{"location":"testing/#code-review","title":"Code review","text":"<p>We strongly recommend conducting code reviews within your team as a best practice. This will help ensure that any bugs are identified and any edge cases are covered by your bot. </p>"},{"location":"testing/#best-practices","title":"Best practices","text":"<p>To learn more about bot development best practices, see the best practices section. Be sure to check out useful libraries for developing your bots as well. There are also sections describing more advanced bot development patterns like hiding sensitive data, consuming bot alerts, publishing private alerts, transaction simulation and querying other chains.</p> <p>Once you have tested and reviewed your bot, you can move on to deploying your bot.</p>"},{"location":"threat-detection-kits/","title":"Get Started","text":""},{"location":"threat-detection-kits/#what-is-a-threat-detection-kit","title":"What is a threat detection kit?","text":"<p>If you are new to Forta, a threat detection kit will help you get started on monitoring and protecting Web3 projects and assets right away with no custom bot development needed to get security-relevant value from Forta.</p> <p>A threat detection kit consists of security detection bots and bot templates created and curated by the Forta community and security experts.</p> <p>There are currently 5 threat detection kits available, each specifically tailored to monitor different parts of the Web3 ecosystem and detect threats.</p> <ul> <li>Bridge Threat Detection Kit</li> <li>DeFi Threat Detection Kit</li> <li>Governance Threat Detection Kit</li> <li>NFT Threat Detection Kit</li> <li>Stablecoin Threat Detection Kit</li> </ul>"},{"location":"threat-detection-kits/#how-to-subscribe-to-threat-detection-kit-detection-bots","title":"How to subscribe to threat detection kit detection bots?","text":"<p>For each threat detection kit, security experts hand-picked a list of detection bots users can subscribe to to help identify a broad range of security-related events. By subscribing to these bots, you can receive alerts on suspicious and/or anomalous activities potentially occurring at any stage of an ongoing web3 attack. To learn more about how web3 attacks happen and how Forta can mitigate them, check out the Forta illuminates the Web3 Kill Chain Blog Post.</p>"},{"location":"threat-detection-kits/#monitoring-your-wallet-or-contracts","title":"Monitoring your wallet or contracts","text":"<ol> <li>To subscribe, first visit the Forta App.</li> <li>Click on \"Monitor my contracts\" or \"Monitor my wallet\". If you clicked on \"Monitor my contracts\", select a threat detection kit.     </li> <li>Sign in with your wallet to continue.     </li> <li>Select or update the selected threat detection kit in the \"Select Subscription type\" dropdown.</li> <li>Add a contract/wallet address to watch. For contracts, it's recommended to create a subscription for each address pertaining to your protocol, including protocol-specific token contract addresses.</li> <li>Choose notification type and destination.</li> </ol>"},{"location":"threat-detection-kits/#what-are-detection-bot-templates","title":"What are detection bot templates?","text":"<p>While the existing threat detection kit bots provide broad coverage for security-relevant issues, sometimes the bot needs protocol-specific information. Detection bot templates allow users to create these custom bots quickly without the need to develop one from scratch.</p> <p>Bot Wizard \ud83e\uddd9 is now available!</p> <p>Non-technical users can configure and create their own detection bots without touching any code via the bot wizard interface.</p> <p>Developers can get access to security detection bot and template source code to fork, customize, and contribute.</p>"},{"location":"time-series-analysis/","title":"Time Series Analysis","text":"<p>Detection bots can be heuristic based and this often works just fine. In order, for instance, to monitor whether an account is funded by a privacy protocol, like Tornado Cash and then interacts with your protocol, you monitor funding transactions, maintain state of those funded accounts, and emit a finding when that account interacts with a protocol (Tornado Cash Funded Account Interaction).</p> <p>The approach, however, does not work well when the event itself is frequent or constantly present, such as a transaction\u2019s gas price? What is a good threshold to choose? Is a priority fee of 2 a good value? 5? 50? Further, what if it changes over time and depends on the underlying protocol\u2019s usage pattern? This may be just the nature of the protocol (some competitive aspect, like a hot NFT project where people frequently are eager to see their transaction mined quickly, so they are willing to pay higher gas to get picked up by the miners). In those instances, we see frequent spikes in gas prices that could even be seasonal (e.g. NFTs get minted every Monday), so we would expect spikes on Mondays as part of the normal course of business. If, however, we have a protocol where such seasonal patterns do not exist, gas price spikes would be rare and a spike in the future may indicate something truly unusual, such as an attack. </p> <p>The recent Ronin attack illustrates this: We do see many spikes in priority fees over time, but the attacker transaction clearly sticks out. A hard threshold approach will likely raise a lot of unnecessary findings. This is where time series anomaly detection comes in. A time series buckets numeric values (e.g. counts or absolute values) over time</p> <p></p> <p>A time series detection approach learns the historical variability as well as seasonality that may be represented in the data (e.g. gas priority fees may be higher on weekdays than on weekends). It learns a band or range and alerts when a value breaks out of the expected range:</p> <p> Source: https://medium.com/@krzysztofdrelczuk/time-series-anomaly-detection-with-python-example-a92ef262f09a </p> <p>To create a time series model in Python, the Prophet Library is a good choice. A simple model can be created by querying alerts from other detection bots or hold the timeline data in the bot directly. The following code block creates a model:</p> <pre><code>import pandas as pd\nfrom prophet import Prophet\n\ndf = pd.read_csv('../examples/example_wp_log_peyton_manning.csv')  # from https://github.com/facebook/prophet/blob/main/examples/example_wp_log_peyton_manning.csv\nm = Prophet()\nm.fit(df)\n\nfuture = m.make_future_dataframe(periods=365)\nforecast = m.predict(future)  # 'ds', 'yhat', 'yhat_lower', 'yhat_upper'\n</code></pre> <p>The image below shows a visualized timeline including the forecasted range. Each dot represents a data point of the time series. The bands represent the prediction of the model (as per the yhat_lower and yhat_upper values of the forcast model above). The dots falling outside of the prediction represent anomalous data points, which a detection bot can alert on.</p> <p></p> <p>For more information around time series analysis and how to implement both in JavaScript or Python, please refer to the Time Series Analysis with Forta blog post.</p>"},{"location":"tutorials/","title":"Video tutorials","text":"<p>Here is an excellent set of video tutorials provided by Forta core dev and community member Arbitrary Execution to help developers understand the lifecycle of building bots.</p>"},{"location":"tutorials/#1-what-are-forta-bots","title":"1) What are Forta bots?","text":""},{"location":"tutorials/#2-what-can-forta-bots-monitor-for","title":"2) What can Forta bots monitor for?","text":""},{"location":"tutorials/#3-developing-a-forta-bot","title":"3) Developing a Forta bot","text":""},{"location":"tutorials/#4-testing-your-forta-bot","title":"4) Testing your Forta bot","text":""},{"location":"tutorials/#5-reviewing-your-forta-bot","title":"5) Reviewing your Forta bot","text":""},{"location":"tutorials/#6-publishing-your-forta-bot","title":"6) Publishing your Forta bot","text":""},{"location":"tutorials/#7-maintaining-your-forta-bot","title":"7) Maintaining your Forta bot","text":""},{"location":"tutorials/#8-tips-for-successful-bots","title":"8) Tips for successful bots","text":""},{"location":"tutorials/#9-full-example-bot-walkthrough","title":"9) Full example bot walkthrough","text":""},{"location":"tutorials/#10-subscribing-to-alerts-using-forta-app","title":"10) Subscribing to alerts using Forta App","text":""},{"location":"tutorials/#11-deploying-a-bot-with-forta-connect-deprecated","title":"11) Deploying a bot with Forta Connect (deprecated)","text":""},{"location":"tutorials/#12-machine-learning-on-forta","title":"12) Machine learning on Forta","text":""},{"location":"tx-simulation/","title":"Transaction simulation","text":"<p>Transaction simulation is a powerful technique that can be used by bot developers to see the results of transactions without having to pay for on-chain execution. Using simulation, you can run transactions from any account on the latest blockchain state and view the results. An example usecase would be to flag malicious transactions in the mempool targeting your protocol before they get mined.</p> <p>This page describes how to simulate transactions using an example Typescript bot. The code for this example can be found here.</p>"},{"location":"tx-simulation/#forking-the-chain","title":"Forking the chain","text":"<p>In this example, the <code>ganache-core</code> library is used to create an in-memory fork of the blockchain from a specified block number. Since we want to fork the latest state, we create the fork inside of the <code>handleBlock</code> handler and specify the latest block number:</p> <pre><code>import ganache from \"ganache-core\";\n\nconst USER_ADDRESS = \"0x72cea5e3540956b2b71a91012a983267472d2fb1\";\n\n// returns an ethers provider pointing to a forked version of the chain from the specified block\nfunction getEthersForkProvider(blockNumber: number) {\n  return new ethers.providers.Web3Provider(\n    ganache.provider({\n      fork: getJsonRpcUrl(), // specify the chain to fork from\n      fork_block_number: blockNumber, // specify the block number to fork from\n      unlocked_accounts: [USER_ADDRESS], // specify any accounts to unlock\n    })\n  );\n}\n\nasync function handleBlock(blockEvent: BlockEvent) {\n  // create an ethers provider that points to a forked ganache chain\n  const provider = getEthersForkProvider(blockEvent.blockNumber);\n  ...\n}\n</code></pre> <p>The above code initializes an ethers provider pointing to the Ganache fork that you can use like a regular provider (e.g. invoke methods like <code>getBalance</code>). We also specify exactly which accounts we want Ganache to unlock so we can simulate transactions from that account.</p>"},{"location":"tx-simulation/#simulating-transactions","title":"Simulating transactions","text":"<p>Now we can simulate transactions using the ethers provider. In this example, we execute a Tether transfer from the specified account to some other account. First we query the balance of the account, and then transfer the entire balance.</p> <pre><code>async function handleBlock(blockEvent: BlockEvent) {\n  // create an ethers provider that points to a forked ganache chain\n  const provider = getEthersForkProvider(blockEvent.blockNumber);\n  // create an ethers contract pointing to the Tether token on the forked ganache chain\n  const tetherContract = new ethers.Contract(\n    TETHER_ADDRESS,\n    TETHER_ABI,\n    provider.getSigner(USER_ADDRESS)\n  );\n\n  try {\n    // get the user's balance\n    userBalance = await tetherContract.balanceOf(USER_ADDRESS);\n    // transfer the entire balance to another user\n    const tx = await tetherContract.transfer(USER2_ADDRESS, userBalance);\n    // wait for transaction to be mined by ganache\n    await tx.wait();\n  } catch (e) {\n    // report a finding if the simulated transaction fails\n  }\n}\n</code></pre> <p>The above transaction should succeed with no errors. Ganache will mine the transaction and increase the block number. But what happens if you try to transfer an amount higher than the user's balance? The on-chain logic will throw an error, and the <code>catch</code> block will be invoked. In this example, we return a finding if the transfer fails for any reason.</p> <p>Amazing! You now have a bot that can fork the state of the blockchain, query on-chain data, and execute transactions without needing to pay any gas.</p>"},{"location":"useful-libraries/","title":"Useful libraries","text":"<p>Here is a collection of libraries and APIs that bot developers may find useful when building their bots. Want to add your library here? Check out this section to suggest an edit.</p>"},{"location":"useful-libraries/#forta-helpers","title":"forta-helpers","text":"<p><code>forta-helpers</code> is a useful library from community member Artem Kovalchuk to speed up bot development. It provides solutions to often-repeated patterns of bot development like working with data storage, executing asynchronous requests, extracting useful information from transactions and contracts, and much more.</p>"},{"location":"useful-libraries/#forta-bot-templates","title":"forta-bot-templates","text":"<p><code>forta-bot-templates</code> is a repository of low-code bot templates developed by Forta community member Arbitrary Execution. All you have to do is modify a single json config file to build your bot. Some example templates include listening for a set of events and filtering by some conditions, or scanning for accounts that have interacted with Tornado Cash.</p>"},{"location":"useful-libraries/#forta-flashloan-detector","title":"forta-flashloan-detector","text":"<p><code>forta-flashloan-detector</code> is an awesome library developed by Forta community member LimeChain. It provides a convenient way to detect whether transactions contain flashloans from various protocols including Aave, dYdX, Euler, Iron Bank and MakerDAO.</p>"},{"location":"useful-libraries/#forta-agent-tools","title":"forta-agent-tools","text":"<p><code>forta-agent-tools</code> is a nifty library developed by Forta community member Nethermind. It includes some common bot templates, as well as some neat testing tools.</p>"},{"location":"useful-libraries/#ethers-multicall","title":"ethers-multicall","text":"<p><code>ethers-multicall</code> is useful for querying lots of data from the blockchain without having to make multiple http requests. For example, if you want to query token balances for a list of addresses, you can use this library to fetch all the balances in a single http request.</p>"},{"location":"useful-libraries/#rolling-math","title":"rolling-math","text":"<p><code>rolling-math</code> is an awesome library developed by Forta community member Arbitrary Execution. It is useful for bots that require analyzing trends across some time window.</p>"},{"location":"useful-libraries/#lru-cache","title":"lru-cache","text":"<p><code>lru-cache</code> is great for adding caching capability to your bot. You can specify the maximum number of items you want to cache and keep only the most recently used items.</p>"},{"location":"useful-libraries/#etherscan-api","title":"Etherscan API","text":"<p>The Etherscan APIs are a great resource for bot developers. They can be used to answer questions like \"which transactions was a given address involved in?\" or \"what is the ABI for a given contract address?\". Note: make sure to use obfuscation or JWT authentication if using an Etherscan API key in your code.</p>"},{"location":"why-forta/","title":"Why Forta","text":"<p>As the Web3 economy grows in value and complexity, security has become increasingly critical. More than $1 billion was lost in the first quarter of 2022 due to hacks and exploits, some of which have only been discovered several days after the attack happened. The need for real-time security and operational monitoring has become clear, allowing protocols and investors to react quickly to neutralize threats and prevent or minimize loss of funds.</p> <p>However, the rapid speed at which the Web3 industry develops makes it hard for a centralized entity to watch it all. That\u2019s where Forta comes in.</p>"},{"location":"why-forta/#threat-detection-monitoring","title":"Threat detection monitoring","text":"<p>Threat detection monitoring provides alerts on transactions and events that may indicate malicious activity. One of the main challenges in threat monitoring is determining \u201cwhat to look for\u201d in transactions. Unfortunately, there are many examples of smart contract exploits from the past few years, so there is a large body of ideas to draw from.</p> <p>For example, while the DeFi community is well aware of the anonymity that Tornado Cash mixers provide, the vast majority of DeFi market transactions do not involve Tornado Cash contracts. However, attackers have an incentive to conceal the source and/or destination of funds associated with an attack. Therefore, a useful monitoring pattern may be to identify EOAs performing transactions with a protocol and then check if those EOAs have performed withdrawals from any Tornado Cash contracts within the recent past (e.g. the previous hour, day, weeks, etc.).</p>"},{"location":"why-forta/#how-can-forta-be-used-to-prevent-smart-contract-exploits","title":"How can Forta be used to prevent smart contract exploits?","text":"<p>Certain categories of exploits, such as phishing, governance attacks, and multi-chain or bridge attacks, typically require the use of multiple transactions over multiple blocks that offer the opportunity for early detection followed by prevention before the exploit occurs or mitigation before the exploit is complete.</p> <p>Forta community members have already published multiple examples of how Forta can be used to detect and prevent or mitigate such exploits, like the Microsoft ice phishing bot or the Sleep Minting bot for NFTs. The ability to respond to Forta alerts also relies on the readiness of project teams and Forta community members have begun to work with organizations to put together emergency response plans.</p> <p>Performing on-chain actions from within a Forta detection bot is not advised, given the public nature of the Forta detection bot code and any keys it may use.</p>"},{"location":"why-forta/#examples-of-other-smart-contract-exploits-that-can-also-be-mitigated-by-forta","title":"Examples of other smart contract exploits that can also be mitigated by Forta","text":"<p>Other categories of exploits, such as those involving oracle or collateral manipulations, can also be detected by Forta, however prevention may be limited by the fact that such exploits often involve the use of flashloans or other techniques that allow them to occur in the context of a single block which itself may be privately mined. For this category of exploit, fast detection from Forta may still prove useful to mitigate attacks or prevent similar attacks on other chains or protocols.</p> <p>The Forta community is growing to include even more security researchers, leading organizations, L1 and L2 providers, and other concerned parties, who may use Forta to investigate and develop new techniques and approaches that might lead to prevention against market manipulations and zero-block vulnerabilities in the future. Visit the Forum or Discord and join the discussion today.</p>"},{"location":"why-forta/#operational-monitoring","title":"Operational monitoring","text":"<p>Operational (\u201cperformance\u201d) monitoring checks that your protocol is functioning as expected, within some predetermined bounds. These types of checks are beneficial for the protocol\u2019s community, as they provide some assurance of the overall health of the protocol while still highlighting some of the more extraordinary transactions that occur. Beyond the financial operation, this monitoring may provide information about when implementation contracts are upgraded, admin addresses change, or critical administrative smart contract methods are called. This type of monitoring would provide alerts that may be appropriate for display in a dashboard like Splunk, DataDog, etc.</p> <p>For example, the total liquidity of pools may fluctuate by \u00b11% over the course of a day, so any single transaction that affects the liquidity by more than that should trigger an alert. Alternatively, because some pools may have relatively little liquidity, it may make sense to use a fixed value threshold (denominated in USDC, ETH, USD, etc.) rather than a percentage.</p>"},{"location":"why-forta/#other-use-cases","title":"Other use cases","text":"<p>Since Forta is open for anyone to write and deploy a detection bot, the applications for Forta are limitless. Forta simply acts as the real-time monitoring layer for any use case you can imagine. For example, users might incorporate real-time Forta data as an input in algorithmic asset trading strategies to beat the market or create an automated insurance protocol that identifies a covered loss in real-time and pays out automatically. If you are interested in building on top of Forta, the community would love to hear about it in the Forum or Discord.</p>"},{"location":"why-forta/#private-monitoring","title":"Private monitoring","text":"<p>There are multiple options for users that prefer private monitoring. Forta bots are not required to publish their source code, and the bot code in the deployed container can be obfuscated in a variety of ways, as described in the Forta docs. Alert findings output from bots can be coded or encrypted. For users that prefer to deploy bots to a private environment without any public exposure, or that simply want redundancy for their bots on the public network, Forta also can support these users running private nodes, which remain completely independent of the public Forta network and do not participate in public detection bot assignment or public broadcast of detection bot findings.</p>"},{"location":"why-forta/#fees","title":"Fees","text":"<p>FP-5 was approved via Snapshot with a total of 96% \u201cyes\u201d votes. The proposal was a monumental step forward for the Network as it will introduce fees in the coming months. Fees on Forta can be paid out in USDC and FORT, and both general and specialized plans will be available. With the passing of FP-5, Forta\u2019s cryptoeconomic engine will be fully vitalized, creating a healthy and unique business model that will reward Forta Network participants.</p>"},{"location":"why-forta/#security","title":"Security","text":"<p>Staking is required for scan nodes to be discoverable in the network and emit alerts, and for Forta detection bots to be picked up by scan nodes.</p> <p>Bots are executed in individual containers and are not able to affect scan nodes or other bots. Detection bots are further restricted in a variety of ways by scan nodes during execution, and bot output can be validated by users and community members, and malicious, redundant, or inaccurate detection bots are slashed and disabled.</p> <p>Scan nodes must produce proof of scan for every block, which provides the ability for community monitoring. Malicious or inaccurate scan nodes can be slashed and disabled.</p> <p>The Forta smart contracts, node software, and other components of the network receive regular security review and the reports will be made public. Learn more about it here.</p>"},{"location":"why-forta/#how-does-forta-ensure-reliable-monitoring","title":"How does Forta ensure reliable monitoring?","text":"<p>Reliability on Forta is solved through detection bot redundancy and the monitoring and enforcement of scan node service levels by the community. On the public network, Forta detection bots are assigned to multiple scan nodes with periodic re-assignment. Scan nodes are required to provide a stake and must produce a proof of scan for every block. Scan nodes are monitored for reliability and are slashed for failure to meet the community-established service levels.</p>"},{"location":"why-forta/#how-are-forta-alerts-and-findings-validated","title":"How are Forta alerts and findings validated?","text":"<p>Forta scan nodes gather findings from detection bots for each block and then store a proof of scan on IPFS and broadcast the finding details to the Forta analyzer node. Users can obtain detailed information from the Forta analyzer node via the public API, which can be validated against the proof of scan data on IPFS. The analyzer node performs data indexing and may provide additional analysis.</p>"},{"location":"wizard/","title":"Detection Bot Wizard","text":"<p>With the Forta Detection Bot Wizard, anyone can deploy a detection bot to scan for conditions they are interested in. The wizard provides a convenient UI that does not require writing any code. Simply select what type of detection bot you want, configure it to your needs, and deploy it using the existing Forta App. You can check out the video walkthrough for the wizard here:</p> <p>The rest of this page will guide you through deploying a detection bot using the wizard UI. In this example, we will deploy a bot that alerts when there is a Tether transfer of more than 100,000 USDT.</p>"},{"location":"wizard/#select-a-template","title":"Select a template","text":"<p>Start by navigating to the wizard and ensure you are signed in using your wallet. You will see a dropdown of templates you can choose from. For this example, we will select the \"Monitor Events\" template:</p> <p></p> <p>Once selected, you can click the \"View source code\" link if you would like to see the template code. Click the \"Continue\" button to move on to configuring the template.</p>"},{"location":"wizard/#configure-the-template","title":"Configure the template","text":"<p>Each template will have its own unique configuration form. For this template, we need to specify which contract(s) to monitor as well as which event(s) from that contract we are interested in being notified about. You should see a form that looks like this:</p> <p></p>"},{"location":"wizard/#select-the-contract","title":"Select the contract","text":"<p>Click the \"+ Add\" button to specify the contracts you are interested in. The form should look like the following:</p> <p></p> <p>You can select any of the chains supported by Forta. For this example we want Ethereum since that is where the main Tether contract is deployed. You can then specify the ABI of the contract by providing its address and loading it automatically, or by manually uploading an ABI file. Paste the Tether contract address (0xdac17f958d2ee523a2206206994597c13d831ec7) into the first \"Contract Address\" field and click the \"Load ABI\" button (it should say \"Loaded\" once complete). Lastly, provide a name for the contract in the \"Contract Name\" field (e.g. \"Tether\").</p>"},{"location":"wizard/#select-events","title":"Select events","text":"<p>Now that the contract is specified, we need to tell the wizard which events we are interested in. Click the \"+ Add\" button under the \"Event Monitoring List\" label. This should bring you to a form that looks like this:</p> <p></p> <p>You can select the event you are interested in from the \"Event Signature\" dropdown. For this example, we are interested in the Transfer events. The \"Finding Type\" and \"Finding Severity\" dropdowns allow you to specify a categorization of the alert that will fire. This will depend on your specific usecase, but for this example we leave them to the default values of \"Info\".</p> <p>Lastly, there is an optional field called \"Conditional Expression\" where we can specify further conditions that the event should meet (i.e. the transfer value being higher than some amount). Since we want Transfer events over 100,000 USDT, we will enter <code>value &gt; 100000000000</code>. Notice that the left hand side of the expression matches the event parameter name from the \"Event Signature\" field. Also, notice that the right hand side of the expression is specified in base units of Tether which has 6 decimal places (this can vary per token).</p> <p>Click the \"Continue\" button to confirm the event configuration. And then click \"Continue\" again to confirm the contract configuration.</p>"},{"location":"wizard/#build-the-detection-bot","title":"Build the detection bot","text":"<p>Now that the template is configured, we can proceed to building the detection bot. The completed configuration form should look like this:</p> <p></p> <p>To begin building the bot, click the \"Continue\" button. You should then see a loading spinner like the following:</p> <p></p> <p>The detection bot should take less than one minute to generate. Once the process is complete, you should see a success message like this:</p> <p></p> <p>The resulting output of the build process will be a Docker image reference. To continue to deploy the detection bot through the Forta App, click the \"Deploy Bot\" button. Alternatively, you could also copy the Docker image reference to your clipboard if you wanted to deploy later. The Docker image reference would be in the format <code>bafybeid3vhcgruv47e4hy5texnq5ux4foi6th3cmjzeemzxt3ckir6jjjq@sha256:9464461cc98e49a25eb2dd7eead2ac098c19bc09642be89f37cb9b88d349f7cd</code></p>"},{"location":"wizard/#deploy-the-detection-bot","title":"Deploy the detection bot","text":"<p>After clicking the \"Deploy Bot\" button, you will be redirected to the detection bot deployment form:</p> <p></p> <p>Some of the fields will be prepopulated, specifically the \"Docker Image\" field will contain the image reference of the bot you just generated. Continue to fill out the remaining fields and then deploy the bot.</p>"},{"location":"wizard/#subscribing-to-alerts","title":"Subscribing to alerts","text":"<p>After your bot is deployed, you can view the alerts it generates using Forta App. You can search by your bot's ID or a contract address. Alternatively, you can query for alerts programmatically using the Forta API. To learn more about subscribing to alerts, check out this section.</p>"},{"location":"wizard/#maintaining-your-bot","title":"Maintaining your bot","text":"<p>You may need to update your bot code at some point in the future, view its logs or even disable it. To learn more about maintaining your bot, check out this section.</p>"},{"location":"contracts/components/BaseComponentUpgradeable/","title":"Base Component Upgradeable","text":""},{"location":"contracts/components/BaseComponentUpgradeable/#basecomponentupgradeable","title":"BaseComponentUpgradeable","text":"<p>_The Forta platform is composed of \"component\" smart contracts that are upgradeable, share a common access control scheme and can send use routed hooks to signal one another. They also support the multicall pattern.</p> <p>This contract contains the base of Forta components. Contracts that inherit this component must call - __BaseComponentUpgradeable_init(address manager) in their initialization process._</p>"},{"location":"contracts/components/BaseComponentUpgradeable/#__basecomponentupgradeable_init","title":"__BaseComponentUpgradeable_init","text":"<pre><code>function __BaseComponentUpgradeable_init(address __manager) internal\n</code></pre>"},{"location":"contracts/components/BaseComponentUpgradeable/#_authorizeupgrade","title":"_authorizeUpgrade","text":"<pre><code>function _authorizeUpgrade(address newImplementation) internal virtual\n</code></pre> <p>_Function that should revert when <code>msg.sender</code> is not authorized to upgrade the contract. Called by {upgradeTo} and {upgradeToAndCall}.</p> <p>Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.</p> <pre><code>function _authorizeUpgrade(address) internal override onlyOwner {}\n```_\n\n### setName\n\n```solidity\nfunction setName(address ensRegistry, string ensName) public\n</code></pre>"},{"location":"contracts/components/BaseComponentUpgradeable/#_msgsender","title":"_msgSender","text":"<pre><code>function _msgSender() internal view virtual returns (address sender)\n</code></pre> <p>Helper to get either msg msg.sender if not a meta transaction, signer of forwarder metatx if it is.</p> <p>If the tx is sent by the trusted forwarded, we assume it is a meta transaction and  the signer address is encoded in the last 20 bytes of msg.data.</p> Name Type Description sender address address of sender of the transaction of signer if meta transaction."},{"location":"contracts/components/BaseComponentUpgradeable/#_msgdata","title":"_msgData","text":"<pre><code>function _msgData() internal view virtual returns (bytes)\n</code></pre> <p>Helper to get msg.data if not a meta transaction, forwarder data in metatx if it is.</p> <p>If the tx is sent by the trusted forwarded, we assume it is a meta transaction and  msg.data must have the signer address (encoded in the last 20 bytes of msg.data) removed.</p> Name Type Description [0] bytes msg.data of the transaction of msg.data - signer address if meta transaction."},{"location":"contracts/components/BaseComponentUpgradeable/#__gap","title":"__gap","text":"<pre><code>uint256[50] __gap\n</code></pre>"},{"location":"contracts/components/Roles/","title":"Roles","text":""},{"location":"contracts/components/Roles/#default_admin_role","title":"DEFAULT_ADMIN_ROLE","text":"<pre><code>bytes32 DEFAULT_ADMIN_ROLE\n</code></pre>"},{"location":"contracts/components/Roles/#router_admin_role","title":"ROUTER_ADMIN_ROLE","text":"<pre><code>bytes32 ROUTER_ADMIN_ROLE\n</code></pre>"},{"location":"contracts/components/Roles/#ens_manager_role","title":"ENS_MANAGER_ROLE","text":"<pre><code>bytes32 ENS_MANAGER_ROLE\n</code></pre>"},{"location":"contracts/components/Roles/#upgrader_role","title":"UPGRADER_ROLE","text":"<pre><code>bytes32 UPGRADER_ROLE\n</code></pre>"},{"location":"contracts/components/Roles/#agent_admin_role","title":"AGENT_ADMIN_ROLE","text":"<pre><code>bytes32 AGENT_ADMIN_ROLE\n</code></pre>"},{"location":"contracts/components/Roles/#scanner_admin_role","title":"SCANNER_ADMIN_ROLE","text":"<pre><code>bytes32 SCANNER_ADMIN_ROLE\n</code></pre>"},{"location":"contracts/components/Roles/#scanner_pool_admin_role","title":"SCANNER_POOL_ADMIN_ROLE","text":"<pre><code>bytes32 SCANNER_POOL_ADMIN_ROLE\n</code></pre>"},{"location":"contracts/components/Roles/#scanner_2_scanner_pool_migrator_role","title":"SCANNER_2_SCANNER_POOL_MIGRATOR_ROLE","text":"<pre><code>bytes32 SCANNER_2_SCANNER_POOL_MIGRATOR_ROLE\n</code></pre>"},{"location":"contracts/components/Roles/#dispatcher_role","title":"DISPATCHER_ROLE","text":"<pre><code>bytes32 DISPATCHER_ROLE\n</code></pre>"},{"location":"contracts/components/Roles/#migration_executor_role","title":"MIGRATION_EXECUTOR_ROLE","text":"<pre><code>bytes32 MIGRATION_EXECUTOR_ROLE\n</code></pre>"},{"location":"contracts/components/Roles/#slasher_role","title":"SLASHER_ROLE","text":"<pre><code>bytes32 SLASHER_ROLE\n</code></pre>"},{"location":"contracts/components/Roles/#sweeper_role","title":"SWEEPER_ROLE","text":"<pre><code>bytes32 SWEEPER_ROLE\n</code></pre>"},{"location":"contracts/components/Roles/#rewarder_role","title":"REWARDER_ROLE","text":"<pre><code>bytes32 REWARDER_ROLE\n</code></pre>"},{"location":"contracts/components/Roles/#slashing_arbiter_role","title":"SLASHING_ARBITER_ROLE","text":"<pre><code>bytes32 SLASHING_ARBITER_ROLE\n</code></pre>"},{"location":"contracts/components/Roles/#staking_contract_role","title":"STAKING_CONTRACT_ROLE","text":"<pre><code>bytes32 STAKING_CONTRACT_ROLE\n</code></pre>"},{"location":"contracts/components/Roles/#staking_admin_role","title":"STAKING_ADMIN_ROLE","text":"<pre><code>bytes32 STAKING_ADMIN_ROLE\n</code></pre>"},{"location":"contracts/components/Roles/#allocator_contract_role","title":"ALLOCATOR_CONTRACT_ROLE","text":"<pre><code>bytes32 ALLOCATOR_CONTRACT_ROLE\n</code></pre>"},{"location":"contracts/components/Roles/#scanner_version_role","title":"SCANNER_VERSION_ROLE","text":"<pre><code>bytes32 SCANNER_VERSION_ROLE\n</code></pre>"},{"location":"contracts/components/Roles/#scanner_beta_version_role","title":"SCANNER_BETA_VERSION_ROLE","text":"<pre><code>bytes32 SCANNER_BETA_VERSION_ROLE\n</code></pre>"},{"location":"contracts/components/access/AccessManager/","title":"Access Manager","text":""},{"location":"contracts/components/access/AccessManager/#accessmanager","title":"AccessManager","text":""},{"location":"contracts/components/access/AccessManager/#version","title":"version","text":"<pre><code>string version\n</code></pre>"},{"location":"contracts/components/access/AccessManager/#constructor","title":"constructor","text":"<pre><code>constructor(address forwarder) public\n</code></pre>"},{"location":"contracts/components/access/AccessManager/#initialize","title":"initialize","text":"<pre><code>function initialize(address __admin) external\n</code></pre> <p>Initializer method, access point to initialize inheritance tree.</p> Name Type Description __admin address address to be the DEFAULT_ADMIN_ROLE."},{"location":"contracts/components/access/AccessManager/#setnewrole","title":"setNewRole","text":"<pre><code>function setNewRole(bytes32 role, bytes32 admin) external\n</code></pre> <p>Method for DEFAULT_ADMIN_ROLE to create new roles, and define their role admin.</p> Name Type Description role bytes32 id of the new role. Should be keccak256(\"\"). admin bytes32 role id that will be the role admin for the new role."},{"location":"contracts/components/access/AccessManager/#_authorizeupgrade","title":"_authorizeUpgrade","text":"<pre><code>function _authorizeUpgrade(address newImplementation) internal virtual\n</code></pre> <p>Access control for the upgrade process (UPGRADER_ROLE)</p> Name Type Description newImplementation address address of the new deployed implementation."},{"location":"contracts/components/access/AccessManager/#setname","title":"setName","text":"<pre><code>function setName(address ensRegistry, string ensName) public\n</code></pre> <p>Allow ENS_MANAGER_ROLE to set ENS reverse registration</p> Name Type Description ensRegistry address address ensName string the name to set in th registry"},{"location":"contracts/components/access/AccessManager/#_msgsender","title":"_msgSender","text":"<pre><code>function _msgSender() internal view virtual returns (address sender)\n</code></pre> <p>Helper to get either msg msg.sender if not a meta transaction, signer of forwarder metatx if it is.</p> <p>If the tx is sent by the trusted forwarded, we assume it is a meta transaction and  the signer address is encoded in the last 20 bytes of msg.data.</p> Name Type Description sender address address of sender of the transaction of signer if meta transaction."},{"location":"contracts/components/access/AccessManager/#_msgdata","title":"_msgData","text":"<pre><code>function _msgData() internal view virtual returns (bytes)\n</code></pre> <p>Helper to get msg.data if not a meta transaction, forwarder data in metatx if it is.</p> <p>If the tx is sent by the trusted forwarded, we assume it is a meta transaction and  msg.data must have the signer address (encoded in the last 20 bytes of msg.data) removed.</p> Name Type Description [0] bytes msg.data of the transaction of msg.data - signer address if meta transaction."},{"location":"contracts/components/access/AccessManager/#__gap","title":"__gap","text":"<pre><code>uint256[50] __gap\n</code></pre>"},{"location":"contracts/components/agents/AgentRegistry/","title":"Agent Registry","text":""},{"location":"contracts/components/agents/AgentRegistry/#agentregistry","title":"AgentRegistry","text":""},{"location":"contracts/components/agents/AgentRegistry/#version","title":"version","text":"<pre><code>string version\n</code></pre>"},{"location":"contracts/components/agents/AgentRegistry/#constructor","title":"constructor","text":"<pre><code>constructor(address forwarder) public\n</code></pre>"},{"location":"contracts/components/agents/AgentRegistry/#initialize","title":"initialize","text":"<pre><code>function initialize(address __manager, string __name, string __symbol) public\n</code></pre> <p>Initializer method, access point to initialize inheritance tree.</p> Name Type Description __manager address address of AccessManager. __name string ERC721 token name. __symbol string ERC721 token symbol."},{"location":"contracts/components/agents/AgentRegistry/#getagentstate","title":"getAgentState","text":"<pre><code>function getAgentState(uint256 agentId) public view returns (bool registered, address owner, uint256 agentVersion, string metadata, uint256[] chainIds, bool enabled, uint256 disabledFlags)\n</code></pre> <p>Gets all Agent state.</p> Name Type Description agentId uint256 ERC721 token id of the agent. Name Type Description registered bool if agent exists. owner address address. agentVersion uint256 of the agent. metadata string IPFS pointer. chainIds uint256[] the agent wants to run in. enabled bool true if staked over min and not disabled. disabledFlags uint256 0 if not disabled, Permission that disabled the scnner otherwise."},{"location":"contracts/components/agents/AgentRegistry/#_beforeagentupdate","title":"_beforeAgentUpdate","text":"<pre><code>function _beforeAgentUpdate(uint256 agentId, string newMetadata, uint256[] newChainIds) internal virtual\n</code></pre> <p>Inheritance disambiguation for hook fired befire agent update (and creation).</p> Name Type Description agentId uint256 id of the agent. newMetadata string IPFS pointer to agent's metadata newChainIds uint256[] chain ids that the agent wants to scan"},{"location":"contracts/components/agents/AgentRegistry/#_agentupdate","title":"_agentUpdate","text":"<pre><code>function _agentUpdate(uint256 agentId, string newMetadata, uint256[] newChainIds) internal virtual\n</code></pre> <p>Obligatory inheritance disambiguation for hook fired for agent update (and creation).</p> Name Type Description agentId uint256 id of the agent. newMetadata string IPFS pointer to agent's metadata newChainIds uint256[] chain ids that the agent wants to scan"},{"location":"contracts/components/agents/AgentRegistry/#_msgsender","title":"_msgSender","text":"<pre><code>function _msgSender() internal view virtual returns (address sender)\n</code></pre> <p>Helper to get either msg msg.sender if not a meta transaction, signer of forwarder metatx if it is.</p>"},{"location":"contracts/components/agents/AgentRegistry/#_msgdata","title":"_msgData","text":"<pre><code>function _msgData() internal view virtual returns (bytes)\n</code></pre> <p>Helper to get msg.data if not a meta transaction, forwarder data in metatx if it is.</p>"},{"location":"contracts/components/agents/AgentRegistry/#__gap","title":"__gap","text":"<pre><code>uint256[50] __gap\n</code></pre>"},{"location":"contracts/components/agents/AgentRegistry/#agentregistryenumerable","title":"AgentRegistryEnumerable","text":""},{"location":"contracts/components/agents/AgentRegistry/#_allagents","title":"_allAgents","text":"<pre><code>struct EnumerableSet.UintSet _allAgents\n</code></pre>"},{"location":"contracts/components/agents/AgentRegistry/#_chainagents","title":"_chainAgents","text":"<pre><code>mapping(uint256 =&gt; struct EnumerableSet.UintSet) _chainAgents\n</code></pre>"},{"location":"contracts/components/agents/AgentRegistry/#getagentcount","title":"getAgentCount","text":"<pre><code>function getAgentCount() public view returns (uint256)\n</code></pre> <p>Agent count.</p> <p>Helper for external iteration.</p> Name Type Description [0] uint256 total amount of registered agents."},{"location":"contracts/components/agents/AgentRegistry/#getagentbyindex","title":"getAgentByIndex","text":"<pre><code>function getAgentByIndex(uint256 index) public view returns (uint256)\n</code></pre> <p>Agent id at index in _allAgents array.</p> <p>Helper for external iteration.</p> Name Type Description index uint256 of agent in _allAgents array. Name Type Description [0] uint256 agentId at index."},{"location":"contracts/components/agents/AgentRegistry/#getagentcountbychain","title":"getAgentCountByChain","text":"<pre><code>function getAgentCountByChain(uint256 chainId) public view returns (uint256)\n</code></pre> <p>Registered agent count by chainId.</p> <p>Helper for external iteration.</p> Name Type Description [0] uint256 agent total registered by chainId."},{"location":"contracts/components/agents/AgentRegistry/#getagentbychainandindex","title":"getAgentByChainAndIndex","text":"<pre><code>function getAgentByChainAndIndex(uint256 chainId, uint256 index) public view returns (uint256)\n</code></pre> <p>Agent id at index, by chainId</p> <p>Helper for external iteration.</p> Name Type Description chainId uint256 where the agent was registered. index uint256 of agent in _chainAgents[chainId] array. Name Type Description [0] uint256 agentId at index for that chainId."},{"location":"contracts/components/agents/AgentRegistry/#_beforeagentupdate_1","title":"_beforeAgentUpdate","text":"<pre><code>function _beforeAgentUpdate(uint256 agentId, string newMetadata, uint256[] newChainIds) internal virtual\n</code></pre> <p>hook fired before agent creation or update.</p> <p>stores agent in _allAgents if it wasn't there, manages agent arrays by chain.</p> Name Type Description agentId uint256 ERC721 token id of the agent to be created or updated. newMetadata string IPFS pointer to agent's metadata JSON. newChainIds uint256[] ordered list of chainIds where the agent wants to run."},{"location":"contracts/components/agents/AgentRegistry/#__gap_1","title":"__gap","text":"<pre><code>uint256[48] __gap\n</code></pre>"},{"location":"contracts/components/agents/AgentRegistry/#agentregistrymetadata","title":"AgentRegistryMetadata","text":""},{"location":"contracts/components/agents/AgentRegistry/#agentmetadata","title":"AgentMetadata","text":"<pre><code>struct AgentMetadata {\n  uint256 version;\n  string metadata;\n  uint256[] chainIds;\n}\n</code></pre>"},{"location":"contracts/components/agents/AgentRegistry/#_agentmetadata","title":"_agentMetadata","text":"<pre><code>mapping(uint256 =&gt; struct AgentRegistryMetadata.AgentMetadata) _agentMetadata\n</code></pre>"},{"location":"contracts/components/agents/AgentRegistry/#_agentmetadatauniqueness","title":"_agentMetadataUniqueness","text":"<pre><code>mapping(bytes32 =&gt; bool) _agentMetadataUniqueness\n</code></pre>"},{"location":"contracts/components/agents/AgentRegistry/#metadatanotunique","title":"MetadataNotUnique","text":"<pre><code>error MetadataNotUnique(bytes32 hash)\n</code></pre>"},{"location":"contracts/components/agents/AgentRegistry/#getagent","title":"getAgent","text":"<pre><code>function getAgent(uint256 agentId) public view returns (bool registered, address owner, uint256 agentVersion, string metadata, uint256[] chainIds)\n</code></pre> <p>Gets agent metadata, version and chain Ids.</p> Name Type Description agentId uint256 ERC721 token id of the agent. Name Type Description registered bool if agent exists. owner address address. agentVersion uint256 of the agent. metadata string IPFS pointer. chainIds uint256[] the agent wants to run in."},{"location":"contracts/components/agents/AgentRegistry/#_agentupdate_1","title":"_agentUpdate","text":"<pre><code>function _agentUpdate(uint256 agentId, string newMetadata, uint256[] newChainIds) internal virtual\n</code></pre> <p>logic for agent update.</p> <p>checks metadata uniqueness and updates agent metadata and version.</p> Name Type Description agentId uint256 ERC721 token id of the agent to be created or updated. newMetadata string IPFS pointer to agent's metadata JSON. newChainIds uint256[] ordered list of chainIds where the agent wants to run."},{"location":"contracts/components/agents/AgentRegistry/#__gap_2","title":"__gap","text":"<pre><code>uint256[48] __gap\n</code></pre>"},{"location":"contracts/components/agents/AgentRegistry/#agentregistryenable","title":"AgentRegistryEnable","text":"<p>AgentRegistry methods and state handling disabling and enabling agents, and recognizing stake changes that might disable an agent. NOTE: This contract was deployed before StakeAwareUpgradeable was created, so __StakeAwareUpgradeable_init is not called.</p>"},{"location":"contracts/components/agents/AgentRegistry/#permission","title":"Permission","text":"<pre><code>enum Permission {\n  ADMIN,\n  OWNER,\n  length\n}\n</code></pre>"},{"location":"contracts/components/agents/AgentRegistry/#_disabled","title":"_disabled","text":"<pre><code>mapping(uint256 =&gt; struct BitMaps.BitMap) _disabled\n</code></pre>"},{"location":"contracts/components/agents/AgentRegistry/#agentenabled","title":"AgentEnabled","text":"<pre><code>event AgentEnabled(uint256 agentId, bool enabled, enum AgentRegistryEnable.Permission permission, bool value)\n</code></pre>"},{"location":"contracts/components/agents/AgentRegistry/#isenabled","title":"isEnabled","text":"<pre><code>function isEnabled(uint256 agentId) public view virtual returns (bool)\n</code></pre> <p>Check if agent is enabled</p> Name Type Description agentId uint256 ERC721 token id of the agent. Name Type Description [0] bool true if the agent exist, has not been disabled, and is staked over minimum Returns false if otherwise"},{"location":"contracts/components/agents/AgentRegistry/#enableagent","title":"enableAgent","text":"<pre><code>function enableAgent(uint256 agentId, enum AgentRegistryEnable.Permission permission) public virtual\n</code></pre> <p>Enable an agent if sender has correct permission and the agent is staked over minimum stake.</p> <p>agents can be disabled by ADMIN or OWNER.</p> Name Type Description agentId uint256 ERC721 token id of the agent. permission enum AgentRegistryEnable.Permission the sender claims to have to enable the agent."},{"location":"contracts/components/agents/AgentRegistry/#disableagent","title":"disableAgent","text":"<pre><code>function disableAgent(uint256 agentId, enum AgentRegistryEnable.Permission permission) public virtual\n</code></pre> <p>Disable an agent if sender has correct permission.</p> <p>agents can be disabled by ADMIN or OWNER.</p> Name Type Description agentId uint256 ERC721 token id of the agent. permission enum AgentRegistryEnable.Permission the sender claims to have to enable the agent."},{"location":"contracts/components/agents/AgentRegistry/#getdisableflags","title":"getDisableFlags","text":"<pre><code>function getDisableFlags(uint256 agentId) public view returns (uint256)\n</code></pre> <p>Get the disabled flags for an agentId.</p> <p>Permission (uint8) is used for indexing, so we don't need to loop.  If not disabled, all flags will be 0.</p> Name Type Description agentId uint256 ERC721 token id of the agent. Name Type Description [0] uint256 uint256 containing the byte flags."},{"location":"contracts/components/agents/AgentRegistry/#_haspermission","title":"_hasPermission","text":"<pre><code>function _hasPermission(uint256 agentId, enum AgentRegistryEnable.Permission permission) internal view returns (bool)\n</code></pre> <p>Permission check.</p> <p>it does not uses AccessManager since it is agent specific</p> Name Type Description agentId uint256 ERC721 token id of the agent. permission enum AgentRegistryEnable.Permission the sender claims to have to enable the agent. Name Type Description [0] bool true if: permission.ADMIN and _msgSender is ADMIN_ROLE, Permission.OWNER and owner of agentId, false otherwise."},{"location":"contracts/components/agents/AgentRegistry/#_enable","title":"_enable","text":"<pre><code>function _enable(uint256 agentId, enum AgentRegistryEnable.Permission permission, bool enable) internal\n</code></pre> <p>Internal methods for enabling the agent.</p> <p>fires hook _before and _after enable within the inheritance tree.</p> Name Type Description agentId uint256 ERC721 token id of the agent. permission enum AgentRegistryEnable.Permission the sender claims to have to enable the agent. enable bool true if enabling, false if disabling."},{"location":"contracts/components/agents/AgentRegistry/#_beforeagentenable","title":"_beforeAgentEnable","text":"<pre><code>function _beforeAgentEnable(uint256 agentId, enum AgentRegistryEnable.Permission permission, bool value) internal virtual\n</code></pre> <p>Hook _before agent enable</p> <p>does nothing in this contract</p> Name Type Description agentId uint256 ERC721 token id of the agent. permission enum AgentRegistryEnable.Permission the sender claims to have to enable the agent. value bool true if enabling, false if disabling."},{"location":"contracts/components/agents/AgentRegistry/#_agentenable","title":"_agentEnable","text":"<pre><code>function _agentEnable(uint256 agentId, enum AgentRegistryEnable.Permission permission, bool value) internal virtual\n</code></pre> <p>Logic for enabling agents, sets flag corresponding to permission.</p> <p>does nothing in this contract</p> Name Type Description agentId uint256 ERC721 token id of the agent. permission enum AgentRegistryEnable.Permission the sender claims to have to enable the agent. value bool true if enabling, false if disabling."},{"location":"contracts/components/agents/AgentRegistry/#_afteragentenable","title":"_afterAgentEnable","text":"<pre><code>function _afterAgentEnable(uint256 agentId, enum AgentRegistryEnable.Permission permission, bool value) internal virtual\n</code></pre> <p>Hook _after agent enable</p> <p>emits Router hook</p> Name Type Description agentId uint256 ERC721 token id of the agent. permission enum AgentRegistryEnable.Permission the sender claims to have to enable the agent. value bool true if enabling, false if disabling."},{"location":"contracts/components/agents/AgentRegistry/#_msgsender_1","title":"_msgSender","text":"<pre><code>function _msgSender() internal view virtual returns (address sender)\n</code></pre> <p>Obligatory inheritance dismambiguation of ForwardedContext's _msgSender()</p> Name Type Description sender address msg.sender if not a meta transaction, signer of forwarder metatx if it is."},{"location":"contracts/components/agents/AgentRegistry/#_msgdata_1","title":"_msgData","text":"<pre><code>function _msgData() internal view virtual returns (bytes)\n</code></pre> <p>Obligatory inheritance dismambiguation of ForwardedContext's _msgSender()</p> Name Type Description [0] bytes sender msg.data if not a meta transaction, forwarder data in metatx if it is."},{"location":"contracts/components/agents/AgentRegistry/#__gap_3","title":"__gap","text":"<pre><code>uint256[49] __gap\n</code></pre>"},{"location":"contracts/components/agents/AgentRegistry/#agentregistrycore","title":"AgentRegistryCore","text":""},{"location":"contracts/components/agents/AgentRegistry/#_stakethreshold","title":"_stakeThreshold","text":"<pre><code>struct IStakeSubject.StakeThreshold _stakeThreshold\n</code></pre>"},{"location":"contracts/components/agents/AgentRegistry/#frontrunningdelay","title":"frontRunningDelay","text":"<pre><code>uint256 frontRunningDelay\n</code></pre>"},{"location":"contracts/components/agents/AgentRegistry/#agentcommitted","title":"AgentCommitted","text":"<pre><code>event AgentCommitted(bytes32 commit)\n</code></pre>"},{"location":"contracts/components/agents/AgentRegistry/#agentupdated","title":"AgentUpdated","text":"<pre><code>event AgentUpdated(uint256 agentId, address by, string metadata, uint256[] chainIds)\n</code></pre>"},{"location":"contracts/components/agents/AgentRegistry/#stakethresholdchanged","title":"StakeThresholdChanged","text":"<pre><code>event StakeThresholdChanged(uint256 min, uint256 max, bool activated)\n</code></pre>"},{"location":"contracts/components/agents/AgentRegistry/#frontrunningdelayset","title":"FrontRunningDelaySet","text":"<pre><code>event FrontRunningDelaySet(uint256 delay)\n</code></pre>"},{"location":"contracts/components/agents/AgentRegistry/#onlyownerof","title":"onlyOwnerOf","text":"<pre><code>modifier onlyOwnerOf(uint256 agentId)\n</code></pre> <p>Checks sender (or metatx signer) is owner of the agent token.</p> Name Type Description agentId uint256 ERC721 token id of the agent."},{"location":"contracts/components/agents/AgentRegistry/#onlysorted","title":"onlySorted","text":"<pre><code>modifier onlySorted(uint256[] array)\n</code></pre> <p>Checks if array of uint256 is sorted from lower (index 0) to higher (array.length -1)</p> Name Type Description array uint256[] to check"},{"location":"contracts/components/agents/AgentRegistry/#prepareagent","title":"prepareAgent","text":"<pre><code>function prepareAgent(bytes32 commit) public\n</code></pre> <p>Save commit representing an agent to prevent frontrunning of their creation</p> Name Type Description commit bytes32 keccak256 hash of the agent creation's parameters"},{"location":"contracts/components/agents/AgentRegistry/#registeragent","title":"registerAgent","text":"<pre><code>function registerAgent(uint256 agentId, string metadata, uint256[] chainIds) public\n</code></pre> <p>Agent registration method. Mints an ERC721 token with the agent id for the sender and stores metadata.</p> <p>Agent Ids are generated through the Forta Bot SDK (by hashing UUIDs) so the agentId collision risk is minimized. Fires _before and _after hooks within the inheritance tree. If front run protection is enabled (disabled by default), it will check if the keccak256 hash of the parameters has been committed in prepareAgent(bytes32).</p> Name Type Description agentId uint256 ERC721 token id of the agent to be created. metadata string IPFS pointer to agent's metadata JSON. chainIds uint256[] ordered list of chainIds where the agent wants to run."},{"location":"contracts/components/agents/AgentRegistry/#createagent","title":"createAgent","text":"<pre><code>function createAgent(uint256 agentId, address, string metadata, uint256[] chainIds) external\n</code></pre> <p>Create agent method with old signature for backwards compatibility. Owner parameter is ignore in favour of sender. This method is deprecated and it will be removed in future versions of AgentRegistryCore</p>"},{"location":"contracts/components/agents/AgentRegistry/#isregistered","title":"isRegistered","text":"<pre><code>function isRegistered(uint256 agentId) public view returns (bool)\n</code></pre> <p>Checks if the agentId has been minted.</p> Name Type Description agentId uint256 ERC721 token id of the agent. Name Type Description [0] bool true if agentId exists, false otherwise."},{"location":"contracts/components/agents/AgentRegistry/#updateagent","title":"updateAgent","text":"<pre><code>function updateAgent(uint256 agentId, string metadata, uint256[] chainIds) public\n</code></pre> <p>Updates parameters of an agentId (metadata, image, chain IDs...) if called by the agent owner.</p> <p>fires _before and _after hooks within the inheritance tree.</p> Name Type Description agentId uint256 ERC721 token id of the agent to be updated. metadata string IPFS pointer to agent's metadata JSON. chainIds uint256[] ordered list of chainIds where the agent wants to run."},{"location":"contracts/components/agents/AgentRegistry/#setstakethreshold","title":"setStakeThreshold","text":"<pre><code>function setStakeThreshold(struct IStakeSubject.StakeThreshold newStakeThreshold) external\n</code></pre> <p>StakeThreshold setter, common to all Agents. Restricted to AGENT_ADMIN_ROLE, emits StakeThresholdChanged</p>"},{"location":"contracts/components/agents/AgentRegistry/#getstakethreshold","title":"getStakeThreshold","text":"<pre><code>function getStakeThreshold(uint256) public view returns (struct IStakeSubject.StakeThreshold)\n</code></pre> <p>stake threshold common for all agents</p>"},{"location":"contracts/components/agents/AgentRegistry/#_isstakeactivated","title":"_isStakeActivated","text":"<pre><code>function _isStakeActivated() internal view returns (bool)\n</code></pre>"},{"location":"contracts/components/agents/AgentRegistry/#_isstakedovermin","title":"_isStakedOverMin","text":"<pre><code>function _isStakedOverMin(uint256 subject) internal view returns (bool)\n</code></pre> <p>Checks if agent is staked over minimum stake</p> Name Type Description subject uint256 agentId Name Type Description [0] bool true if agent is staked over the minimum threshold and is, or staking is not enabled (stakeController = 0 or activated = false ). false otherwise"},{"location":"contracts/components/agents/AgentRegistry/#setfrontrunningdelay","title":"setFrontRunningDelay","text":"<pre><code>function setFrontRunningDelay(uint256 delay) external\n</code></pre> <p>allows AGENT_ADMIN_ROLE to activate frontrunning protection for agents</p> Name Type Description delay uint256 in seconds"},{"location":"contracts/components/agents/AgentRegistry/#_beforeagentupdate_2","title":"_beforeAgentUpdate","text":"<pre><code>function _beforeAgentUpdate(uint256 agentId, string newMetadata, uint256[] newChainIds) internal virtual\n</code></pre> <p>hook fired before agent creation or update.</p> <p>does nothing in this contract.</p> Name Type Description agentId uint256 ERC721 token id of the agent to be created or updated. newMetadata string IPFS pointer to agent's metadata JSON. newChainIds uint256[] ordered list of chainIds where the agent wants to run."},{"location":"contracts/components/agents/AgentRegistry/#_agentupdate_2","title":"_agentUpdate","text":"<pre><code>function _agentUpdate(uint256 agentId, string newMetadata, uint256[] newChainIds) internal virtual\n</code></pre> <p>logic for agent update.</p> <p>emits AgentUpdated, will be extended by child contracts.</p> Name Type Description agentId uint256 ERC721 token id of the agent to be created or updated. newMetadata string IPFS pointer to agent's metadata JSON. newChainIds uint256[] ordered list of chainIds where the agent wants to run."},{"location":"contracts/components/agents/AgentRegistry/#_afteragentupdate","title":"_afterAgentUpdate","text":"<pre><code>function _afterAgentUpdate(uint256 agentId, string newMetadata, uint256[] newChainIds) internal virtual\n</code></pre> <p>hook fired after agent creation or update.</p> <p>emits Router hook.</p> Name Type Description agentId uint256 ERC721 token id of the agent to be created or updated. newMetadata string IPFS pointer to agent's metadata JSON. newChainIds uint256[] ordered list of chainIds where the agent wants to run."},{"location":"contracts/components/agents/AgentRegistry/#_msgsender_2","title":"_msgSender","text":"<pre><code>function _msgSender() internal view virtual returns (address sender)\n</code></pre> <p>Obligatory inheritance dismambiguation of ForwardedContext's _msgSender()</p> Name Type Description sender address msg.sender if not a meta transaction, signer of forwarder metatx if it is."},{"location":"contracts/components/agents/AgentRegistry/#_msgdata_2","title":"_msgData","text":"<pre><code>function _msgData() internal view virtual returns (bytes)\n</code></pre> <p>Obligatory inheritance dismambiguation of ForwardedContext's _msgSender()</p> Name Type Description [0] bytes sender msg.data if not a meta transaction, forwarder data in metatx if it is."},{"location":"contracts/components/agents/AgentRegistry/#ownerof","title":"ownerOf","text":"<pre><code>function ownerOf(uint256 subject) public view virtual returns (address)\n</code></pre>"},{"location":"contracts/components/agents/AgentRegistry/#__gap_4","title":"__gap","text":"<pre><code>uint256[41] __gap\n</code></pre>"},{"location":"contracts/components/agents/AgentRegistryCore/","title":"AgentRegistryCore","text":""},{"location":"contracts/components/agents/AgentRegistryCore/#agentregistrycore","title":"AgentRegistryCore","text":""},{"location":"contracts/components/agents/AgentRegistryCore/#_stakethreshold","title":"_stakeThreshold","text":"<pre><code>struct IStakeSubject.StakeThreshold _stakeThreshold\n</code></pre>"},{"location":"contracts/components/agents/AgentRegistryCore/#frontrunningdelay","title":"frontRunningDelay","text":"<pre><code>uint256 frontRunningDelay\n</code></pre>"},{"location":"contracts/components/agents/AgentRegistryCore/#agentcommitted","title":"AgentCommitted","text":"<pre><code>event AgentCommitted(bytes32 commit)\n</code></pre>"},{"location":"contracts/components/agents/AgentRegistryCore/#agentupdated","title":"AgentUpdated","text":"<pre><code>event AgentUpdated(uint256 agentId, address by, string metadata, uint256[] chainIds)\n</code></pre>"},{"location":"contracts/components/agents/AgentRegistryCore/#stakethresholdchanged","title":"StakeThresholdChanged","text":"<pre><code>event StakeThresholdChanged(uint256 min, uint256 max, bool activated)\n</code></pre>"},{"location":"contracts/components/agents/AgentRegistryCore/#frontrunningdelayset","title":"FrontRunningDelaySet","text":"<pre><code>event FrontRunningDelaySet(uint256 delay)\n</code></pre>"},{"location":"contracts/components/agents/AgentRegistryCore/#onlyownerof","title":"onlyOwnerOf","text":"<pre><code>modifier onlyOwnerOf(uint256 agentId)\n</code></pre> <p>Checks sender (or metatx signer) is owner of the agent token.</p> Name Type Description agentId uint256 ERC721 token id of the agent."},{"location":"contracts/components/agents/AgentRegistryCore/#onlysorted","title":"onlySorted","text":"<pre><code>modifier onlySorted(uint256[] array)\n</code></pre> <p>Checks if array of uint256 is sorted from lower (index 0) to higher (array.length -1)</p> Name Type Description array uint256[] to check"},{"location":"contracts/components/agents/AgentRegistryCore/#prepareagent","title":"prepareAgent","text":"<pre><code>function prepareAgent(bytes32 commit) public\n</code></pre> <p>Save commit representing an agent to prevent frontrunning of their creation</p> Name Type Description commit bytes32 keccak256 hash of the agent creation's parameters"},{"location":"contracts/components/agents/AgentRegistryCore/#registeragent","title":"registerAgent","text":"<pre><code>function registerAgent(uint256 agentId, string metadata, uint256[] chainIds) public\n</code></pre> <p>Agent registration method. Mints an ERC721 token with the agent id for the sender and stores metadata.</p> <p>Agent Ids are generated through the Forta Bot SDK (by hashing UUIDs) so the agentId collision risk is minimized. Fires _before and _after hooks within the inheritance tree. If front run protection is enabled (disabled by default), it will check if the keccak256 hash of the parameters has been committed in prepareAgent(bytes32).</p> Name Type Description agentId uint256 ERC721 token id of the agent to be created. metadata string IPFS pointer to agent's metadata JSON. chainIds uint256[] ordered list of chainIds where the agent wants to run."},{"location":"contracts/components/agents/AgentRegistryCore/#createagent","title":"createAgent","text":"<pre><code>function createAgent(uint256 agentId, address, string metadata, uint256[] chainIds) external\n</code></pre> <p>Create agent method with old signature for backwards compatibility. Owner parameter is ignore in favour of sender. This method is deprecated and it will be removed in future versions of AgentRegistryCore</p>"},{"location":"contracts/components/agents/AgentRegistryCore/#isregistered","title":"isRegistered","text":"<pre><code>function isRegistered(uint256 agentId) public view returns (bool)\n</code></pre> <p>Checks if the agentId has been minted.</p> Name Type Description agentId uint256 ERC721 token id of the agent. Name Type Description [0] bool true if agentId exists, false otherwise."},{"location":"contracts/components/agents/AgentRegistryCore/#updateagent","title":"updateAgent","text":"<pre><code>function updateAgent(uint256 agentId, string metadata, uint256[] chainIds) public\n</code></pre> <p>Updates parameters of an agentId (metadata, image, chain IDs...) if called by the agent owner.</p> <p>fires _before and _after hooks within the inheritance tree.</p> Name Type Description agentId uint256 ERC721 token id of the agent to be updated. metadata string IPFS pointer to agent's metadata JSON. chainIds uint256[] ordered list of chainIds where the agent wants to run."},{"location":"contracts/components/agents/AgentRegistryCore/#setstakethreshold","title":"setStakeThreshold","text":"<pre><code>function setStakeThreshold(struct IStakeSubject.StakeThreshold newStakeThreshold) external\n</code></pre> <p>StakeThreshold setter, common to all Agents. Restricted to AGENT_ADMIN_ROLE, emits StakeThresholdChanged</p>"},{"location":"contracts/components/agents/AgentRegistryCore/#getstakethreshold","title":"getStakeThreshold","text":"<pre><code>function getStakeThreshold(uint256) public view returns (struct IStakeSubject.StakeThreshold)\n</code></pre> <p>stake threshold common for all agents</p>"},{"location":"contracts/components/agents/AgentRegistryCore/#_isstakeactivated","title":"_isStakeActivated","text":"<pre><code>function _isStakeActivated() internal view returns (bool)\n</code></pre>"},{"location":"contracts/components/agents/AgentRegistryCore/#_isstakedovermin","title":"_isStakedOverMin","text":"<pre><code>function _isStakedOverMin(uint256 subject) internal view returns (bool)\n</code></pre> <p>Checks if agent is staked over minimum stake</p> Name Type Description subject uint256 agentId Name Type Description [0] bool true if agent is staked over the minimum threshold and is, or staking is not enabled (stakeController = 0 or activated = false ). false otherwise"},{"location":"contracts/components/agents/AgentRegistryCore/#setfrontrunningdelay","title":"setFrontRunningDelay","text":"<pre><code>function setFrontRunningDelay(uint256 delay) external\n</code></pre> <p>allows AGENT_ADMIN_ROLE to activate frontrunning protection for agents</p> Name Type Description delay uint256 in seconds"},{"location":"contracts/components/agents/AgentRegistryCore/#_beforeagentupdate","title":"_beforeAgentUpdate","text":"<pre><code>function _beforeAgentUpdate(uint256 agentId, string newMetadata, uint256[] newChainIds) internal virtual\n</code></pre> <p>hook fired before agent creation or update.</p> <p>does nothing in this contract.</p> Name Type Description agentId uint256 ERC721 token id of the agent to be created or updated. newMetadata string IPFS pointer to agent's metadata JSON. newChainIds uint256[] ordered list of chainIds where the agent wants to run."},{"location":"contracts/components/agents/AgentRegistryCore/#_agentupdate","title":"_agentUpdate","text":"<pre><code>function _agentUpdate(uint256 agentId, string newMetadata, uint256[] newChainIds) internal virtual\n</code></pre> <p>logic for agent update.</p> <p>emits AgentUpdated, will be extended by child contracts.</p> Name Type Description agentId uint256 ERC721 token id of the agent to be created or updated. newMetadata string IPFS pointer to agent's metadata JSON. newChainIds uint256[] ordered list of chainIds where the agent wants to run."},{"location":"contracts/components/agents/AgentRegistryCore/#_afteragentupdate","title":"_afterAgentUpdate","text":"<pre><code>function _afterAgentUpdate(uint256 agentId, string newMetadata, uint256[] newChainIds) internal virtual\n</code></pre> <p>hook fired after agent creation or update.</p> <p>emits Router hook.</p> Name Type Description agentId uint256 ERC721 token id of the agent to be created or updated. newMetadata string IPFS pointer to agent's metadata JSON. newChainIds uint256[] ordered list of chainIds where the agent wants to run."},{"location":"contracts/components/agents/AgentRegistryCore/#_msgsender","title":"_msgSender","text":"<pre><code>function _msgSender() internal view virtual returns (address sender)\n</code></pre> <p>Obligatory inheritance dismambiguation of ForwardedContext's _msgSender()</p> Name Type Description sender address msg.sender if not a meta transaction, signer of forwarder metatx if it is."},{"location":"contracts/components/agents/AgentRegistryCore/#_msgdata","title":"_msgData","text":"<pre><code>function _msgData() internal view virtual returns (bytes)\n</code></pre> <p>Obligatory inheritance dismambiguation of ForwardedContext's _msgSender()</p> Name Type Description [0] bytes sender msg.data if not a meta transaction, forwarder data in metatx if it is."},{"location":"contracts/components/agents/AgentRegistryCore/#ownerof","title":"ownerOf","text":"<pre><code>function ownerOf(uint256 subject) public view virtual returns (address)\n</code></pre>"},{"location":"contracts/components/agents/AgentRegistryCore/#__gap","title":"__gap","text":"<pre><code>uint256[41] __gap\n</code></pre>"},{"location":"contracts/components/agents/AgentRegistryEnable/","title":"AgentRegistryEnable","text":""},{"location":"contracts/components/agents/AgentRegistryEnable/#agentregistryenable","title":"AgentRegistryEnable","text":"<p>AgentRegistry methods and state handling disabling and enabling agents, and recognizing stake changes that might disable an agent. NOTE: This contract was deployed before StakeAwareUpgradeable was created, so __StakeAwareUpgradeable_init is not called.</p>"},{"location":"contracts/components/agents/AgentRegistryEnable/#permission","title":"Permission","text":"<pre><code>enum Permission {\n  ADMIN,\n  OWNER,\n  length\n}\n</code></pre>"},{"location":"contracts/components/agents/AgentRegistryEnable/#_disabled","title":"_disabled","text":"<pre><code>mapping(uint256 =&gt; struct BitMaps.BitMap) _disabled\n</code></pre>"},{"location":"contracts/components/agents/AgentRegistryEnable/#agentenabled","title":"AgentEnabled","text":"<pre><code>event AgentEnabled(uint256 agentId, bool enabled, enum AgentRegistryEnable.Permission permission, bool value)\n</code></pre>"},{"location":"contracts/components/agents/AgentRegistryEnable/#isenabled","title":"isEnabled","text":"<pre><code>function isEnabled(uint256 agentId) public view virtual returns (bool)\n</code></pre> <p>Check if agent is enabled</p> Name Type Description agentId uint256 ERC721 token id of the agent. Name Type Description [0] bool true if the agent exist, has not been disabled, and is staked over minimum Returns false if otherwise"},{"location":"contracts/components/agents/AgentRegistryEnable/#enableagent","title":"enableAgent","text":"<pre><code>function enableAgent(uint256 agentId, enum AgentRegistryEnable.Permission permission) public virtual\n</code></pre> <p>Enable an agent if sender has correct permission and the agent is staked over minimum stake.</p> <p>agents can be disabled by ADMIN or OWNER.</p> Name Type Description agentId uint256 ERC721 token id of the agent. permission enum AgentRegistryEnable.Permission the sender claims to have to enable the agent."},{"location":"contracts/components/agents/AgentRegistryEnable/#disableagent","title":"disableAgent","text":"<pre><code>function disableAgent(uint256 agentId, enum AgentRegistryEnable.Permission permission) public virtual\n</code></pre> <p>Disable an agent if sender has correct permission.</p> <p>agents can be disabled by ADMIN or OWNER.</p> Name Type Description agentId uint256 ERC721 token id of the agent. permission enum AgentRegistryEnable.Permission the sender claims to have to enable the agent."},{"location":"contracts/components/agents/AgentRegistryEnable/#getdisableflags","title":"getDisableFlags","text":"<pre><code>function getDisableFlags(uint256 agentId) public view returns (uint256)\n</code></pre> <p>Get the disabled flags for an agentId.</p> <p>Permission (uint8) is used for indexing, so we don't need to loop.  If not disabled, all flags will be 0.</p> Name Type Description agentId uint256 ERC721 token id of the agent. Name Type Description [0] uint256 uint256 containing the byte flags."},{"location":"contracts/components/agents/AgentRegistryEnable/#_haspermission","title":"_hasPermission","text":"<pre><code>function _hasPermission(uint256 agentId, enum AgentRegistryEnable.Permission permission) internal view returns (bool)\n</code></pre> <p>Permission check.</p> <p>it does not uses AccessManager since it is agent specific</p> Name Type Description agentId uint256 ERC721 token id of the agent. permission enum AgentRegistryEnable.Permission the sender claims to have to enable the agent. Name Type Description [0] bool true if: permission.ADMIN and _msgSender is ADMIN_ROLE, Permission.OWNER and owner of agentId, false otherwise."},{"location":"contracts/components/agents/AgentRegistryEnable/#_enable","title":"_enable","text":"<pre><code>function _enable(uint256 agentId, enum AgentRegistryEnable.Permission permission, bool enable) internal\n</code></pre> <p>Internal methods for enabling the agent.</p> <p>fires hook _before and _after enable within the inheritance tree.</p> Name Type Description agentId uint256 ERC721 token id of the agent. permission enum AgentRegistryEnable.Permission the sender claims to have to enable the agent. enable bool true if enabling, false if disabling."},{"location":"contracts/components/agents/AgentRegistryEnable/#_beforeagentenable","title":"_beforeAgentEnable","text":"<pre><code>function _beforeAgentEnable(uint256 agentId, enum AgentRegistryEnable.Permission permission, bool value) internal virtual\n</code></pre> <p>Hook _before agent enable</p> <p>does nothing in this contract</p> Name Type Description agentId uint256 ERC721 token id of the agent. permission enum AgentRegistryEnable.Permission the sender claims to have to enable the agent. value bool true if enabling, false if disabling."},{"location":"contracts/components/agents/AgentRegistryEnable/#_agentenable","title":"_agentEnable","text":"<pre><code>function _agentEnable(uint256 agentId, enum AgentRegistryEnable.Permission permission, bool value) internal virtual\n</code></pre> <p>Logic for enabling agents, sets flag corresponding to permission.</p> <p>does nothing in this contract</p> Name Type Description agentId uint256 ERC721 token id of the agent. permission enum AgentRegistryEnable.Permission the sender claims to have to enable the agent. value bool true if enabling, false if disabling."},{"location":"contracts/components/agents/AgentRegistryEnable/#_afteragentenable","title":"_afterAgentEnable","text":"<pre><code>function _afterAgentEnable(uint256 agentId, enum AgentRegistryEnable.Permission permission, bool value) internal virtual\n</code></pre> <p>Hook _after agent enable</p> <p>emits Router hook</p> Name Type Description agentId uint256 ERC721 token id of the agent. permission enum AgentRegistryEnable.Permission the sender claims to have to enable the agent. value bool true if enabling, false if disabling."},{"location":"contracts/components/agents/AgentRegistryEnable/#_msgsender","title":"_msgSender","text":"<pre><code>function _msgSender() internal view virtual returns (address sender)\n</code></pre> <p>Obligatory inheritance dismambiguation of ForwardedContext's _msgSender()</p> Name Type Description sender address msg.sender if not a meta transaction, signer of forwarder metatx if it is."},{"location":"contracts/components/agents/AgentRegistryEnable/#_msgdata","title":"_msgData","text":"<pre><code>function _msgData() internal view virtual returns (bytes)\n</code></pre> <p>Obligatory inheritance dismambiguation of ForwardedContext's _msgSender()</p> Name Type Description [0] bytes sender msg.data if not a meta transaction, forwarder data in metatx if it is."},{"location":"contracts/components/agents/AgentRegistryEnable/#__gap","title":"__gap","text":"<pre><code>uint256[49] __gap\n</code></pre>"},{"location":"contracts/components/agents/AgentRegistryEnumerable/","title":"AgentRegistryEnumerable","text":""},{"location":"contracts/components/agents/AgentRegistryEnumerable/#agentregistryenumerable","title":"AgentRegistryEnumerable","text":""},{"location":"contracts/components/agents/AgentRegistryEnumerable/#_allagents","title":"_allAgents","text":"<pre><code>struct EnumerableSet.UintSet _allAgents\n</code></pre>"},{"location":"contracts/components/agents/AgentRegistryEnumerable/#_chainagents","title":"_chainAgents","text":"<pre><code>mapping(uint256 =&gt; struct EnumerableSet.UintSet) _chainAgents\n</code></pre>"},{"location":"contracts/components/agents/AgentRegistryEnumerable/#getagentcount","title":"getAgentCount","text":"<pre><code>function getAgentCount() public view returns (uint256)\n</code></pre> <p>Agent count.</p> <p>Helper for external iteration.</p> Name Type Description [0] uint256 total amount of registered agents."},{"location":"contracts/components/agents/AgentRegistryEnumerable/#getagentbyindex","title":"getAgentByIndex","text":"<pre><code>function getAgentByIndex(uint256 index) public view returns (uint256)\n</code></pre> <p>Agent id at index in _allAgents array.</p> <p>Helper for external iteration.</p> Name Type Description index uint256 of agent in _allAgents array. Name Type Description [0] uint256 agentId at index."},{"location":"contracts/components/agents/AgentRegistryEnumerable/#getagentcountbychain","title":"getAgentCountByChain","text":"<pre><code>function getAgentCountByChain(uint256 chainId) public view returns (uint256)\n</code></pre> <p>Registered agent count by chainId.</p> <p>Helper for external iteration.</p> Name Type Description [0] uint256 agent total registered by chainId."},{"location":"contracts/components/agents/AgentRegistryEnumerable/#getagentbychainandindex","title":"getAgentByChainAndIndex","text":"<pre><code>function getAgentByChainAndIndex(uint256 chainId, uint256 index) public view returns (uint256)\n</code></pre> <p>Agent id at index, by chainId</p> <p>Helper for external iteration.</p> Name Type Description chainId uint256 where the agent was registered. index uint256 of agent in _chainAgents[chainId] array. Name Type Description [0] uint256 agentId at index for that chainId."},{"location":"contracts/components/agents/AgentRegistryEnumerable/#_beforeagentupdate","title":"_beforeAgentUpdate","text":"<pre><code>function _beforeAgentUpdate(uint256 agentId, string newMetadata, uint256[] newChainIds) internal virtual\n</code></pre> <p>hook fired before agent creation or update.</p> <p>stores agent in _allAgents if it wasn't there, manages agent arrays by chain.</p> Name Type Description agentId uint256 ERC721 token id of the agent to be created or updated. newMetadata string IPFS pointer to agent's metadata JSON. newChainIds uint256[] ordered list of chainIds where the agent wants to run."},{"location":"contracts/components/agents/AgentRegistryEnumerable/#__gap","title":"__gap","text":"<pre><code>uint256[48] __gap\n</code></pre>"},{"location":"contracts/components/agents/AgentRegistryMetadata/","title":"AgentRegistryMetadata","text":""},{"location":"contracts/components/agents/AgentRegistryMetadata/#agentregistrymetadata","title":"AgentRegistryMetadata","text":""},{"location":"contracts/components/agents/AgentRegistryMetadata/#agentmetadata","title":"AgentMetadata","text":"<pre><code>struct AgentMetadata {\n  uint256 version;\n  string metadata;\n  uint256[] chainIds;\n}\n</code></pre>"},{"location":"contracts/components/agents/AgentRegistryMetadata/#_agentmetadata","title":"_agentMetadata","text":"<pre><code>mapping(uint256 =&gt; struct AgentRegistryMetadata.AgentMetadata) _agentMetadata\n</code></pre>"},{"location":"contracts/components/agents/AgentRegistryMetadata/#_agentmetadatauniqueness","title":"_agentMetadataUniqueness","text":"<pre><code>mapping(bytes32 =&gt; bool) _agentMetadataUniqueness\n</code></pre>"},{"location":"contracts/components/agents/AgentRegistryMetadata/#metadatanotunique","title":"MetadataNotUnique","text":"<pre><code>error MetadataNotUnique(bytes32 hash)\n</code></pre>"},{"location":"contracts/components/agents/AgentRegistryMetadata/#getagent","title":"getAgent","text":"<pre><code>function getAgent(uint256 agentId) public view returns (bool registered, address owner, uint256 agentVersion, string metadata, uint256[] chainIds)\n</code></pre> <p>Gets agent metadata, version and chain Ids.</p> Name Type Description agentId uint256 ERC721 token id of the agent. Name Type Description registered bool if agent exists. owner address address. agentVersion uint256 of the agent. metadata string IPFS pointer. chainIds uint256[] the agent wants to run in."},{"location":"contracts/components/agents/AgentRegistryMetadata/#_agentupdate","title":"_agentUpdate","text":"<pre><code>function _agentUpdate(uint256 agentId, string newMetadata, uint256[] newChainIds) internal virtual\n</code></pre> <p>logic for agent update.</p> <p>checks metadata uniqueness and updates agent metadata and version.</p> Name Type Description agentId uint256 ERC721 token id of the agent to be created or updated. newMetadata string IPFS pointer to agent's metadata JSON. newChainIds uint256[] ordered list of chainIds where the agent wants to run."},{"location":"contracts/components/agents/AgentRegistryMetadata/#__gap","title":"__gap","text":"<pre><code>uint256[48] __gap\n</code></pre>"},{"location":"contracts/components/dispatch/Dispatch/","title":"Dispatch","text":""},{"location":"contracts/components/dispatch/Dispatch/#dispatch","title":"Dispatch","text":""},{"location":"contracts/components/dispatch/Dispatch/#disabled","title":"Disabled","text":"<pre><code>error Disabled(string name)\n</code></pre>"},{"location":"contracts/components/dispatch/Dispatch/#invalidid","title":"InvalidId","text":"<pre><code>error InvalidId(string name, uint256 id)\n</code></pre>"},{"location":"contracts/components/dispatch/Dispatch/#setagentregistry","title":"SetAgentRegistry","text":"<pre><code>event SetAgentRegistry(address registry)\n</code></pre>"},{"location":"contracts/components/dispatch/Dispatch/#setscannerregistry","title":"SetScannerRegistry","text":"<pre><code>event SetScannerRegistry(address registry)\n</code></pre>"},{"location":"contracts/components/dispatch/Dispatch/#setscannerpoolregistry","title":"SetScannerPoolRegistry","text":"<pre><code>event SetScannerPoolRegistry(address registry)\n</code></pre>"},{"location":"contracts/components/dispatch/Dispatch/#alreadylinked","title":"AlreadyLinked","text":"<pre><code>event AlreadyLinked(uint256 agentId, uint256 scannerId, bool enable)\n</code></pre>"},{"location":"contracts/components/dispatch/Dispatch/#link","title":"Link","text":"<pre><code>event Link(uint256 agentId, uint256 scannerId, bool enable)\n</code></pre>"},{"location":"contracts/components/dispatch/Dispatch/#constructor","title":"constructor","text":"<pre><code>constructor(address forwarder) public\n</code></pre>"},{"location":"contracts/components/dispatch/Dispatch/#initialize","title":"initialize","text":"<pre><code>function initialize(address __manager, address __agents, address __scanners, address __scannerPools) public\n</code></pre> <p>Initializer method, access point to initialize inheritance tree.</p> Name Type Description __manager address address of AccessManager. __agents address address of AgentRegistry. __scanners address address of ScannerRegistry. __scannerPools address address of ScannerPoolRegistry."},{"location":"contracts/components/dispatch/Dispatch/#agentregistry","title":"agentRegistry","text":"<pre><code>function agentRegistry() public view returns (contract AgentRegistry)\n</code></pre>"},{"location":"contracts/components/dispatch/Dispatch/#scannerregistry","title":"scannerRegistry","text":"<pre><code>function scannerRegistry() public view returns (contract ScannerRegistry)\n</code></pre>"},{"location":"contracts/components/dispatch/Dispatch/#scannerpoolregistry","title":"scannerPoolRegistry","text":"<pre><code>function scannerPoolRegistry() public view returns (contract ScannerPoolRegistry)\n</code></pre>"},{"location":"contracts/components/dispatch/Dispatch/#numagentsfor","title":"numAgentsFor","text":"<pre><code>function numAgentsFor(uint256 scannerId) public view returns (uint256)\n</code></pre> <p>Get total agents linked to a scanner.</p> <p>helper for external iteration.</p> Name Type Description scannerId uint256 address of the scanner converted to uint256 Name Type Description [0] uint256 total agents linked to a scanner"},{"location":"contracts/components/dispatch/Dispatch/#numscannersfor","title":"numScannersFor","text":"<pre><code>function numScannersFor(uint256 agentId) public view returns (uint256)\n</code></pre> <p>Get total scanners where an agent is running in.</p> <p>helper for external iteration.</p> Name Type Description agentId uint256 ERC721 token id of the agent. Name Type Description [0] uint256 total scanners running an scanner"},{"location":"contracts/components/dispatch/Dispatch/#agentat","title":"agentAt","text":"<pre><code>function agentAt(uint256 scannerId, uint256 pos) public view returns (uint256)\n</code></pre> <p>Get agentId linked to a scanner in certain position.</p> <p>helper for external iteration.</p> Name Type Description scannerId uint256 address of the scanner converted to uint256 pos uint256 index for iteration. Name Type Description [0] uint256 ERC721 token id of the agent."},{"location":"contracts/components/dispatch/Dispatch/#agentrefat","title":"agentRefAt","text":"<pre><code>function agentRefAt(uint256 scannerId, uint256 pos) external view returns (bool registered, address owner, uint256 agentId, uint256 agentVersion, string metadata, uint256[] chainIds, bool enabled, uint256 disabledFlags)\n</code></pre> <p>Get data of an agent linked to a scanner at a certain position.</p> <p>helper for external iteration.</p> Name Type Description scannerId uint256 address of the scanner converted to uint256 pos uint256 index for iteration. Name Type Description registered bool bool if agent exists, false otherwise. owner address address. agentId uint256 ERC721 token id of the agent. agentVersion uint256 agent version number. metadata string IPFS pointer for agent metadata. chainIds uint256[] ordered array of chainId were the agent wants to run. enabled bool bool if agent is enabled, false otherwise. disabledFlags uint256 0 if not disabled, Permission that disabled the scnner otherwise."},{"location":"contracts/components/dispatch/Dispatch/#scannerat","title":"scannerAt","text":"<pre><code>function scannerAt(uint256 agentId, uint256 pos) public view returns (uint256)\n</code></pre> <p>Get scannerId running an agent at a certain position.</p> <p>helper for external iteration.</p> Name Type Description agentId uint256 ERC721 token id of the scanner. pos uint256 index for iteration. Name Type Description [0] uint256 ERC721 token id of the scanner."},{"location":"contracts/components/dispatch/Dispatch/#scannerrefat","title":"scannerRefAt","text":"<pre><code>function scannerRefAt(uint256 agentId, uint256 pos) external view returns (bool registered, uint256 scannerId, address owner, uint256 chainId, string metadata, bool operational, bool disabled)\n</code></pre> <p>Get data of ascanner running an agent at a certain position.</p> <p>helper for external iteration.</p> Name Type Description agentId uint256 ERC721 token id of the agent. pos uint256 index for iteration. Name Type Description registered bool true if scanner is registered. scannerId uint256 ERC721 token id of the scanner. owner address address. chainId uint256 that the scanner monitors. metadata string IPFS pointer for agent metadata. operational bool true if scanner is not disabled and staked over min, false otherwise. disabled bool true if disabled by ScannerPool or scanner itself."},{"location":"contracts/components/dispatch/Dispatch/#aretheylinked","title":"areTheyLinked","text":"<pre><code>function areTheyLinked(uint256 agentId, uint256 scannerId) external view returns (bool)\n</code></pre> <p>Returns true if scanner and agents are linked, false otherwise.</p>"},{"location":"contracts/components/dispatch/Dispatch/#link_1","title":"link","text":"<pre><code>function link(uint256 agentId, uint256 scannerId) public\n</code></pre> <p>Assigns the job of running an agent to a scanner.</p> <p>currently only allowed for DISPATCHER_ROLE (Assigner software). emits Link(agentId, scannerId, true) event.</p> Name Type Description agentId uint256 ERC721 token id of the agent. scannerId uint256 address of the scanner converted to uint256"},{"location":"contracts/components/dispatch/Dispatch/#unlink","title":"unlink","text":"<pre><code>function unlink(uint256 agentId, uint256 scannerId) public\n</code></pre> <p>Unassigns the job of running an agent to a scanner.</p> <p>currently only allowed for DISPATCHER_ROLE (Assigner software). emits Link(agentId, scannerId, false) event.</p> Name Type Description agentId uint256 ERC721 token id of the agent. scannerId uint256 address of the scanner converted to uint256"},{"location":"contracts/components/dispatch/Dispatch/#setagentregistry_1","title":"setAgentRegistry","text":"<pre><code>function setAgentRegistry(address newAgentRegistry) public\n</code></pre> <p>Sets agent registry address.</p> <p>only DEFAULT_ADMIN_ROLE (governance).</p> Name Type Description newAgentRegistry address agent of the new AgentRegistry."},{"location":"contracts/components/dispatch/Dispatch/#_setagentregistry","title":"_setAgentRegistry","text":"<pre><code>function _setAgentRegistry(address newAgentRegistry) private\n</code></pre>"},{"location":"contracts/components/dispatch/Dispatch/#setscannerregistry_1","title":"setScannerRegistry","text":"<pre><code>function setScannerRegistry(address newScannerRegistry) public\n</code></pre> <p>Sets scanner registry address.</p> <p>only DEFAULT_ADMIN_ROLE (governance).</p> Name Type Description newScannerRegistry address agent of the new ScannerRegistry."},{"location":"contracts/components/dispatch/Dispatch/#setscannerpoolregistry_1","title":"setScannerPoolRegistry","text":"<pre><code>function setScannerPoolRegistry(address newScannerPoolRegistry) external\n</code></pre> <p>Sets ScannerPool registry address.</p> <p>only DEFAULT_ADMIN_ROLE (governance).</p> Name Type Description newScannerPoolRegistry address agent of the new ScannerRegistry."},{"location":"contracts/components/dispatch/Dispatch/#agenthash","title":"agentHash","text":"<pre><code>function agentHash(uint256 agentId) external view returns (uint256 length, bytes32 manifest)\n</code></pre> <p>Method to hash the amount of scanners an agent is running in, and their status</p> <p>method marked for deprecation in next version.</p>"},{"location":"contracts/components/dispatch/Dispatch/#scannerhash","title":"scannerHash","text":"<pre><code>function scannerHash(uint256 scannerId) external view returns (uint256 length, bytes32 manifest)\n</code></pre> <p>method used by Scanner Node software to know if their list of assigned agents has changed, their enabled state or version has changed so they can start managing changes (loading new agent images, removing not assigned agents, updating agents...).</p> Name Type Description scannerId uint256 address of the scanner converted to uint256 Name Type Description length uint256 amount of agents. manifest bytes32 keccak256 of list of agents, list of agentVersion and list of enabled states."},{"location":"contracts/components/dispatch/Dispatch/#__gap","title":"__gap","text":"<pre><code>uint256[47] __gap\n</code></pre>"},{"location":"contracts/components/metatx/EIP712WithNonce/","title":"EIP712WithNonce","text":""},{"location":"contracts/components/metatx/EIP712WithNonce/#eip712withnonce","title":"EIP712WithNonce","text":""},{"location":"contracts/components/metatx/EIP712WithNonce/#nonceused","title":"NonceUsed","text":"<pre><code>event NonceUsed(address user, uint256 timeline, uint256 nonce)\n</code></pre>"},{"location":"contracts/components/metatx/EIP712WithNonce/#invalidnonce","title":"InvalidNonce","text":"<pre><code>error InvalidNonce(uint256 nonce)\n</code></pre>"},{"location":"contracts/components/metatx/EIP712WithNonce/#_nonces","title":"_nonces","text":"<pre><code>mapping(address =&gt; mapping(uint256 =&gt; uint256)) _nonces\n</code></pre>"},{"location":"contracts/components/metatx/EIP712WithNonce/#domain_separator","title":"DOMAIN_SEPARATOR","text":"<pre><code>function DOMAIN_SEPARATOR() external view returns (bytes32)\n</code></pre> <p>Domain Separator as defined in EIP712</p> Name Type Description [0] bytes32 keccak256(typeHash, nameHash, versionHash, block.chainid, address(this))"},{"location":"contracts/components/metatx/EIP712WithNonce/#getnonce","title":"getNonce","text":"<pre><code>function getNonce(address from) public view virtual returns (uint256)\n</code></pre> <p>Gets nonce for the from address in the \"default\" timeline</p> <p>For a detailed explanation: https://github.com/amxx/permit#out-of-order-execution</p> Name Type Description from address address Name Type Description [0] uint256 nonce"},{"location":"contracts/components/metatx/EIP712WithNonce/#getnonce_1","title":"getNonce","text":"<pre><code>function getNonce(address from, uint256 timeline) public view virtual returns (uint256)\n</code></pre> <p>Gets nonce for the from address in the specified timeline</p> <p>For a detailed explanation: https://github.com/amxx/permit#out-of-order-execution</p> Name Type Description from address address timeline uint256 where the nonce lives Name Type Description [0] uint256 nonce"},{"location":"contracts/components/metatx/EIP712WithNonce/#_verifyandconsumenonce","title":"_verifyAndConsumeNonce","text":"<pre><code>function _verifyAndConsumeNonce(address user, uint256 fullNonce) internal virtual\n</code></pre> <p>Extract timeline from nonce, iterates it to consume it, checks for replay protection.</p> <p>emits NonceUsed(user, timeline, nonce). WARNING: Failed transactions would not consume a nonce, since the reverted transaction won't be able to save in storage.</p> Name Type Description user address address sending the nonce. fullNonce uint256 nonce and timeline info in uint256 space"},{"location":"contracts/components/metatx/Forwarder/","title":"Meta-transaction","text":""},{"location":"contracts/components/metatx/Forwarder/#forwarder","title":"Forwarder","text":""},{"location":"contracts/components/metatx/Forwarder/#forwardrequest","title":"ForwardRequest","text":"<pre><code>struct ForwardRequest {\n  address from;\n  address to;\n  uint256 value;\n  uint256 gas;\n  uint256 nonce;\n  uint256 deadline;\n  bytes data;\n}\n</code></pre>"},{"location":"contracts/components/metatx/Forwarder/#_forwardrequest_typehash","title":"_FORWARDREQUEST_TYPEHASH","text":"<pre><code>bytes32 _FORWARDREQUEST_TYPEHASH\n</code></pre>"},{"location":"contracts/components/metatx/Forwarder/#deadlineexpired","title":"DeadlineExpired","text":"<pre><code>error DeadlineExpired()\n</code></pre>"},{"location":"contracts/components/metatx/Forwarder/#signaturedoesnotmatch","title":"SignatureDoesNotMatch","text":"<pre><code>error SignatureDoesNotMatch()\n</code></pre>"},{"location":"contracts/components/metatx/Forwarder/#constructor","title":"constructor","text":"<pre><code>constructor() public\n</code></pre>"},{"location":"contracts/components/metatx/Forwarder/#execute","title":"execute","text":"<pre><code>function execute(struct Forwarder.ForwardRequest req, bytes signature) external payable returns (bool, bytes)\n</code></pre> <p>Executes a ForwardRequest (meta-tx) if signature is verified, deadline is met and nonce is valid</p> <p>This implementations allows for out of order execution, by allowing several \"timelines\" per nonce by splitting the uint256 type space into 128 bit subspaces where each subspace is interpreted as maintaining an ordered timeline. The intent of the design is to allow multiple nonces to be valid at any given time. For a detailed explanation: https://github.com/amxx/permit#out-of-order-execution For an example on how to leverage this functionality, see tests/forwarder/forwarder.test.js Will emit NonceUsed(user, timeline, nonce) for better reporting / UX  WARNING: failed transactions do not consume a nonce, unlinke regular ethereum transactions. Please make use of the deadline functionality, and if you want to cancel a request, submit a successful transaction with the same nonce.</p> Name Type Description req struct Forwarder.ForwardRequest ForwardRequest to be executed signature bytes EIP-712 signature of the ForwardRequest Name Type Description [0] bool (success, returnData) of the executed request [1] bytes"},{"location":"contracts/components/metatx/Forwarder/#eip712withnonce","title":"EIP712WithNonce","text":""},{"location":"contracts/components/metatx/Forwarder/#nonceused","title":"NonceUsed","text":"<pre><code>event NonceUsed(address user, uint256 timeline, uint256 nonce)\n</code></pre>"},{"location":"contracts/components/metatx/Forwarder/#invalidnonce","title":"InvalidNonce","text":"<pre><code>error InvalidNonce(uint256 nonce)\n</code></pre>"},{"location":"contracts/components/metatx/Forwarder/#_nonces","title":"_nonces","text":"<pre><code>mapping(address =&gt; mapping(uint256 =&gt; uint256)) _nonces\n</code></pre>"},{"location":"contracts/components/metatx/Forwarder/#domain_separator","title":"DOMAIN_SEPARATOR","text":"<pre><code>function DOMAIN_SEPARATOR() external view returns (bytes32)\n</code></pre> <p>Domain Separator as defined in EIP712</p> Name Type Description [0] bytes32 keccak256(typeHash, nameHash, versionHash, block.chainid, address(this))"},{"location":"contracts/components/metatx/Forwarder/#getnonce","title":"getNonce","text":"<pre><code>function getNonce(address from) public view virtual returns (uint256)\n</code></pre> <p>Gets nonce for the from address in the \"default\" timeline</p> <p>For a detailed explanation: https://github.com/amxx/permit#out-of-order-execution</p> Name Type Description from address address Name Type Description [0] uint256 nonce"},{"location":"contracts/components/metatx/Forwarder/#getnonce_1","title":"getNonce","text":"<pre><code>function getNonce(address from, uint256 timeline) public view virtual returns (uint256)\n</code></pre> <p>Gets nonce for the from address in the specified timeline</p> <p>For a detailed explanation: https://github.com/amxx/permit#out-of-order-execution</p> Name Type Description from address address timeline uint256 where the nonce lives Name Type Description [0] uint256 nonce"},{"location":"contracts/components/metatx/Forwarder/#_verifyandconsumenonce","title":"_verifyAndConsumeNonce","text":"<pre><code>function _verifyAndConsumeNonce(address user, uint256 fullNonce) internal virtual\n</code></pre> <p>Extract timeline from nonce, iterates it to consume it, checks for replay protection.</p> <p>emits NonceUsed(user, timeline, nonce). WARNING: Failed transactions would not consume a nonce, since the reverted transaction won't be able to save in storage.</p> Name Type Description user address address sending the nonce. fullNonce uint256 nonce and timeline info in uint256 space"},{"location":"contracts/components/scanner_pools/ScannerPoolRegistry/","title":"Scanner Pool Registry","text":""},{"location":"contracts/components/scanner_pools/ScannerPoolRegistry/#scannerpoolregistry","title":"ScannerPoolRegistry","text":"<p>ERC721 Registry of Scanner Pools. Each scanner ScannerPool EOA controls a number of Scanner Nodes through the ownership of this NFT, represented by their EOA address. The Scanner Pool must register themselves, then register scanner addresses to be controlled by their scannerPoolId (incremental uint). Registered Scanner Pools can also assign managers to manage the scanners. Each Scanner Pool has a single \"chainId\" for all the scanners, and each scanner has metadata (string that can point to a URL, IPFS\u2026). Scanner Pool owners and managers can update said metadata. Scanner Nodes can be enabled or disabled by: - the Scanner itself, - the ScannerPool owner - any of the scanner managers</p> <p>If the scannerId is staked under the minimum stake, it can\u2019t be <code>enabled()</code> and <code>isEnabled()</code> will return false, regardless of the disabled flag. If the scanner is not registered, <code>isEnabled()</code> will return false. A Scanner Node that is not enabled will not receive work (bot assignments)</p>"},{"location":"contracts/components/scanner_pools/ScannerPoolRegistry/#version","title":"version","text":"<pre><code>string version\n</code></pre>"},{"location":"contracts/components/scanner_pools/ScannerPoolRegistry/#constructor","title":"constructor","text":"<pre><code>constructor(address forwarder, address stakeAllocator) public\n</code></pre>"},{"location":"contracts/components/scanner_pools/ScannerPoolRegistry/#registermigratedscannerpool","title":"registerMigratedScannerPool","text":"<pre><code>function registerMigratedScannerPool(address scannerPoolAddress, uint256 chainId) external returns (uint256 scannerPoolId)\n</code></pre>"},{"location":"contracts/components/scanner_pools/ScannerPoolRegistry/#registermigratedscannernode","title":"registerMigratedScannerNode","text":"<pre><code>function registerMigratedScannerNode(struct ScannerPoolRegistryCore.ScannerNodeRegistration req, bool disabled) external\n</code></pre>"},{"location":"contracts/components/scanner_pools/ScannerPoolRegistry/#_cansetenablestate","title":"_canSetEnableState","text":"<pre><code>function _canSetEnableState(address scanner) internal view virtual returns (bool)\n</code></pre> <p>disambiguation of _canSetEnableState, adding SCANNER_2_SCANNER_POOL_MIGRATOR_ROLE to the allowed setters.</p> Name Type Description scanner address address Name Type Description [0] bool true if _msgSender() is the ScannerPool owning the Scanner or the Scanner Node itself"},{"location":"contracts/components/scanner_pools/ScannerPoolRegistry/#_msgsender","title":"_msgSender","text":"<pre><code>function _msgSender() internal view virtual returns (address sender)\n</code></pre> <p>Helper to get either msg msg.sender if not a meta transaction, signer of forwarder metatx if it is.</p>"},{"location":"contracts/components/scanner_pools/ScannerPoolRegistry/#_msgdata","title":"_msgData","text":"<pre><code>function _msgData() internal view virtual returns (bytes)\n</code></pre> <p>Helper to get msg.data if not a meta transaction, forwarder data in metatx if it is.</p>"},{"location":"contracts/components/scanner_pools/ScannerPoolRegistry/#__gap","title":"__gap","text":"<pre><code>uint256[50] __gap\n</code></pre>"},{"location":"contracts/components/scanner_pools/ScannerPoolRegistry/#scannerpoolregistrymanaged","title":"ScannerPoolRegistryManaged","text":""},{"location":"contracts/components/scanner_pools/ScannerPoolRegistry/#managerenabled","title":"ManagerEnabled","text":"<pre><code>event ManagerEnabled(uint256 scannerPoolId, address manager, bool enabled)\n</code></pre>"},{"location":"contracts/components/scanner_pools/ScannerPoolRegistry/#sendernotmanager","title":"SenderNotManager","text":"<pre><code>error SenderNotManager(address sender, uint256 scannerPoolId)\n</code></pre>"},{"location":"contracts/components/scanner_pools/ScannerPoolRegistry/#onlymanagerof","title":"onlyManagerOf","text":"<pre><code>modifier onlyManagerOf(uint256 scannerPoolId)\n</code></pre> <p>Checks sender (or metatx signer) is manager of the scanner pool token.</p> Name Type Description scannerPoolId uint256 ERC721 token id of the ScannerPool"},{"location":"contracts/components/scanner_pools/ScannerPoolRegistry/#ismanager","title":"isManager","text":"<pre><code>function isManager(uint256 scannerPoolId, address manager) public view returns (bool)\n</code></pre> <p>Checks if address is defined as a manager for a ScannerPool's registered Scanner Nodes.</p> Name Type Description scannerPoolId uint256 ERC721 token id of the ScannerPool manager address address to check. Name Type Description [0] bool true if defined as manager for ScannerPool, false otherwise."},{"location":"contracts/components/scanner_pools/ScannerPoolRegistry/#getmanagercount","title":"getManagerCount","text":"<pre><code>function getManagerCount(uint256 scannerPoolId) public view virtual returns (uint256)\n</code></pre> <p>Gets total managers defined for a ScannerPool's registered Scanner Nodes.</p> <p>helper for external iteration.</p> Name Type Description scannerPoolId uint256 ERC721 token id of the ScannerPool Name Type Description [0] uint256 total managers defined for a ScannerPool."},{"location":"contracts/components/scanner_pools/ScannerPoolRegistry/#getmanagerat","title":"getManagerAt","text":"<pre><code>function getManagerAt(uint256 scannerPoolId, uint256 index) public view virtual returns (address)\n</code></pre> <p>Gets manager address at certain position of the ScannerPool's registered Scanner Nodes.</p> <p>helper for external iteration.</p> Name Type Description scannerPoolId uint256 ERC721 token id of the ScannerPool index uint256 position in the set. Name Type Description [0] address address of the manager at index."},{"location":"contracts/components/scanner_pools/ScannerPoolRegistry/#setmanager","title":"setManager","text":"<pre><code>function setManager(uint256 scannerPoolId, address manager, bool enable) public\n</code></pre> <p>Adds or removes a manager to a certain ScannerPool's registered Scanner Nodes. Restricted to ScannerPoolRegistry owner.</p> Name Type Description scannerPoolId uint256 ERC721 token id of the ScannerPool manager address address to be added or removed from manager list for the ScannerPool. enable bool true for adding, false for removing."},{"location":"contracts/components/scanner_pools/ScannerPoolRegistry/#__gap_1","title":"__gap","text":"<pre><code>uint256[49] __gap\n</code></pre>"},{"location":"contracts/components/scanner_pools/ScannerPoolRegistry/#scannerpoolregistrycore","title":"ScannerPoolRegistryCore","text":""},{"location":"contracts/components/scanner_pools/ScannerPoolRegistry/#scannerupdated","title":"ScannerUpdated","text":"<pre><code>event ScannerUpdated(uint256 scannerId, uint256 chainId, string metadata, uint256 scannerPool)\n</code></pre>"},{"location":"contracts/components/scanner_pools/ScannerPoolRegistry/#managedstakethresholdchanged","title":"ManagedStakeThresholdChanged","text":"<pre><code>event ManagedStakeThresholdChanged(uint256 chainId, uint256 min, uint256 max, bool activated)\n</code></pre>"},{"location":"contracts/components/scanner_pools/ScannerPoolRegistry/#registrationdelayset","title":"RegistrationDelaySet","text":"<pre><code>event RegistrationDelaySet(uint256 delay)\n</code></pre>"},{"location":"contracts/components/scanner_pools/ScannerPoolRegistry/#scannerenabled","title":"ScannerEnabled","text":"<pre><code>event ScannerEnabled(uint256 scannerId, bool enabled, address sender, bool disableFlag)\n</code></pre>"},{"location":"contracts/components/scanner_pools/ScannerPoolRegistry/#enabledscannerschanged","title":"EnabledScannersChanged","text":"<pre><code>event EnabledScannersChanged(uint256 scannerPoolId, uint256 enabledScanners)\n</code></pre>"},{"location":"contracts/components/scanner_pools/ScannerPoolRegistry/#scannerpoolregistered","title":"ScannerPoolRegistered","text":"<pre><code>event ScannerPoolRegistered(uint256 scannerPoolId, uint256 chainId)\n</code></pre>"},{"location":"contracts/components/scanner_pools/ScannerPoolRegistry/#scannerpoolnotregistered","title":"ScannerPoolNotRegistered","text":"<pre><code>error ScannerPoolNotRegistered(uint256 scannerPoolId)\n</code></pre>"},{"location":"contracts/components/scanner_pools/ScannerPoolRegistry/#scannerexists","title":"ScannerExists","text":"<pre><code>error ScannerExists(address scanner)\n</code></pre>"},{"location":"contracts/components/scanner_pools/ScannerPoolRegistry/#scannernotregistered","title":"ScannerNotRegistered","text":"<pre><code>error ScannerNotRegistered(address scanner)\n</code></pre>"},{"location":"contracts/components/scanner_pools/ScannerPoolRegistry/#publicregistrationdisabled","title":"PublicRegistrationDisabled","text":"<pre><code>error PublicRegistrationDisabled(uint256 chainId)\n</code></pre>"},{"location":"contracts/components/scanner_pools/ScannerPoolRegistry/#registeringtoolate","title":"RegisteringTooLate","text":"<pre><code>error RegisteringTooLate()\n</code></pre>"},{"location":"contracts/components/scanner_pools/ScannerPoolRegistry/#signaturedoesnotmatch","title":"SignatureDoesNotMatch","text":"<pre><code>error SignatureDoesNotMatch()\n</code></pre>"},{"location":"contracts/components/scanner_pools/ScannerPoolRegistry/#cannotsetscanneractivation","title":"CannotSetScannerActivation","text":"<pre><code>error CannotSetScannerActivation()\n</code></pre>"},{"location":"contracts/components/scanner_pools/ScannerPoolRegistry/#sendernotscannerpool","title":"SenderNotScannerPool","text":"<pre><code>error SenderNotScannerPool(address sender, uint256 scannerPoolId)\n</code></pre>"},{"location":"contracts/components/scanner_pools/ScannerPoolRegistry/#chainidmismatch","title":"ChainIdMismatch","text":"<pre><code>error ChainIdMismatch(uint256 expected, uint256 provided)\n</code></pre>"},{"location":"contracts/components/scanner_pools/ScannerPoolRegistry/#actionshutsdownpool","title":"ActionShutsDownPool","text":"<pre><code>error ActionShutsDownPool()\n</code></pre>"},{"location":"contracts/components/scanner_pools/ScannerPoolRegistry/#scannerpreviouslyenabled","title":"ScannerPreviouslyEnabled","text":"<pre><code>error ScannerPreviouslyEnabled(address scanner)\n</code></pre>"},{"location":"contracts/components/scanner_pools/ScannerPoolRegistry/#scannerpreviouslydisabled","title":"ScannerPreviouslyDisabled","text":"<pre><code>error ScannerPreviouslyDisabled(address scanner)\n</code></pre>"},{"location":"contracts/components/scanner_pools/ScannerPoolRegistry/#constructor_1","title":"constructor","text":"<pre><code>constructor(address __stakeAllocator) internal\n</code></pre>"},{"location":"contracts/components/scanner_pools/ScannerPoolRegistry/#__scannerpoolregistrycore_init","title":"__ScannerPoolRegistryCore_init","text":"<pre><code>function __ScannerPoolRegistryCore_init(string __name, string __symbol, address __stakeSubjectGateway, uint256 __registrationDelay) internal\n</code></pre> <p>Initializer method</p> Name Type Description __name string ERC721 token name. __symbol string ERC721 token symbol. __stakeSubjectGateway address address of StakeSubjectGateway __registrationDelay uint256 amount of time allowed from scanner signing a ScannerNodeRegistration and it's execution by ScannerPool"},{"location":"contracts/components/scanner_pools/ScannerPoolRegistry/#isregistered","title":"isRegistered","text":"<pre><code>function isRegistered(uint256 scannerPoolId) public view returns (bool)\n</code></pre> <p>Checks if scannerPoolId has been registered (minted).</p> Name Type Description scannerPoolId uint256 ERC721 token id of the ScannerPool. Name Type Description [0] bool true if scannerPoolId exists, false otherwise."},{"location":"contracts/components/scanner_pools/ScannerPoolRegistry/#registerscannerpool","title":"registerScannerPool","text":"<pre><code>function registerScannerPool(uint256 chainId) external returns (uint256 scannerPoolId)\n</code></pre> <p>mints a ScannerPoolRegistry ERC721 NFT to sender Transferring ownership of a ScannerPoolRegistry NFT will transfer ownership of all its registered Scanner Node addresses</p> Name Type Description scannerPoolId uint256 (autoincremented uint)"},{"location":"contracts/components/scanner_pools/ScannerPoolRegistry/#monitoredchainid","title":"monitoredChainId","text":"<pre><code>function monitoredChainId(uint256 scannerPoolId) public view returns (uint256)\n</code></pre>"},{"location":"contracts/components/scanner_pools/ScannerPoolRegistry/#isscannerregistered","title":"isScannerRegistered","text":"<pre><code>function isScannerRegistered(address scanner) public view returns (bool)\n</code></pre> <p>Checks if scanner address has been registered</p> Name Type Description scanner address address. Name Type Description [0] bool true if scanner is registered, false otherwise."},{"location":"contracts/components/scanner_pools/ScannerPoolRegistry/#isscannerregisteredto","title":"isScannerRegisteredTo","text":"<pre><code>function isScannerRegisteredTo(address scanner, uint256 scannerPoolId) public view returns (bool)\n</code></pre> <p>Checks if scanner address has been registered to a specific scannerPoolId</p> Name Type Description scanner address address. scannerPoolId uint256 ERC721 token id of the ScannerPool. Name Type Description [0] bool true if scanner is registered to scannerPoolId, false otherwise."},{"location":"contracts/components/scanner_pools/ScannerPoolRegistry/#registerscannernode","title":"registerScannerNode","text":"<pre><code>function registerScannerNode(struct ScannerPoolRegistryCore.ScannerNodeRegistration req, bytes signature) external\n</code></pre> <p>Method to register a Scanner Node and associate it with a scannerPoolId. Before executing this method, make sure to have enough FORT staked by the owner of the Scanner Pool to be allocated to the new scanner, then register a scanner with Forta Scan Node CLI and obtain the parameters for this methods by executing forta auth. Follow the instructions here https://docs.forta.network/en/latest/scan-node/introduction/ This method will try to allocate stake from unallocated stake if necessary. Individual ownership of a scaner node is not transferrable. A scanner node can be disabled, but not unregistered</p> Name Type Description req struct ScannerPoolRegistryCore.ScannerNodeRegistration ScannerNodeRegistration struct with the Scanner Node data. signature bytes ERC712 signature, result from signed req by the scanner."},{"location":"contracts/components/scanner_pools/ScannerPoolRegistry/#updatescannermetadata","title":"updateScannerMetadata","text":"<pre><code>function updateScannerMetadata(address scanner, string metadata) external\n</code></pre> <p>Method to update a registered Scanner Node metadata string. Only the ScannerPool that owns the scanner can update.</p> Name Type Description scanner address address. metadata string IPFS string pointing to Scanner Node metadata."},{"location":"contracts/components/scanner_pools/ScannerPoolRegistry/#totalscannersregistered","title":"totalScannersRegistered","text":"<pre><code>function totalScannersRegistered(uint256 scannerPoolId) public view returns (uint256)\n</code></pre> <p>gets the amount of Scanner Nodes ever registered to a ScannerPool Id. Useful for external iteration.</p> Name Type Description scannerPoolId uint256 ERC721 token id of the ScannerPool."},{"location":"contracts/components/scanner_pools/ScannerPoolRegistry/#registeredscanneratindex","title":"registeredScannerAtIndex","text":"<pre><code>function registeredScannerAtIndex(uint256 scannerPoolId, uint256 index) external view returns (struct ScannerPoolRegistryCore.ScannerNode)\n</code></pre> <p>gets the Scanner Node address at index registered to scannerPoolId Useful for external iteration.</p> Name Type Description scannerPoolId uint256 ERC721 token id of the ScannerPool. index uint256 of the registered Scanner Node. Must be lower than totalScannersRegistered(scannerPoolId)"},{"location":"contracts/components/scanner_pools/ScannerPoolRegistry/#registeredscanneraddressatindex","title":"registeredScannerAddressAtIndex","text":"<pre><code>function registeredScannerAddressAtIndex(uint256 scannerPoolId, uint256 index) external view returns (address)\n</code></pre> <p>gets the Scanner Node data struct at index registered to scannerPoolId Useful for external iteration.</p> Name Type Description scannerPoolId uint256 ERC721 token id of the ScannerPool. index uint256 of the registered Scanner Node. Must be lower than totalScannersRegistered(scannerPoolId)"},{"location":"contracts/components/scanner_pools/ScannerPoolRegistry/#scanneraddresstoid","title":"scannerAddressToId","text":"<pre><code>function scannerAddressToId(address scanner) public pure returns (uint256)\n</code></pre> <p>Converts scanner address to uint256 for FortaStaking Token Id.</p>"},{"location":"contracts/components/scanner_pools/ScannerPoolRegistry/#scanneridtoaddress","title":"scannerIdToAddress","text":"<pre><code>function scannerIdToAddress(uint256 scannerId) public pure returns (address)\n</code></pre> <p>Converts FortaStaking uint256 id to address.</p>"},{"location":"contracts/components/scanner_pools/ScannerPoolRegistry/#isscannerdisabled","title":"isScannerDisabled","text":"<pre><code>function isScannerDisabled(address scanner) public view returns (bool)\n</code></pre> <p>Gets if the disabled flag has been set for a Scanner Node Address</p>"},{"location":"contracts/components/scanner_pools/ScannerPoolRegistry/#isscanneroperational","title":"isScannerOperational","text":"<pre><code>function isScannerOperational(address scanner) public view returns (bool)\n</code></pre> <p>Checks if the Scanner Node is considered operational by the Forta Network, and is thus eligible for bot (Agent) assignment.</p> Name Type Description scanner address address Name Type Description [0] bool true if: - Scanner Node is registered AND - Scanner Node's disabled flag is not set (is false) AND - (Scanner Node has more than minimum stake allocated to it OR staking is not activated for the Scanner Node's chain)"},{"location":"contracts/components/scanner_pools/ScannerPoolRegistry/#willnewscannershutdownpool","title":"willNewScannerShutdownPool","text":"<pre><code>function willNewScannerShutdownPool(uint256 scannerPoolId) public view returns (bool)\n</code></pre> <p>returns true if one more enabled scanner (or one registration) would put ALL scanners under min threshold, (not operational)</p>"},{"location":"contracts/components/scanner_pools/ScannerPoolRegistry/#enablescanner","title":"enableScanner","text":"<pre><code>function enableScanner(address scanner) public\n</code></pre> <p>Sets Scanner Node disabled flag to false. It's not possible to re-enable a Scanner Node if allocatedStake / enabled scanners &lt; min. If there is enough unallocated stake, this method will allocate it. If not, it will revert.</p> Name Type Description scanner address address"},{"location":"contracts/components/scanner_pools/ScannerPoolRegistry/#disablescanner","title":"disableScanner","text":"<pre><code>function disableScanner(address scanner) public\n</code></pre> <p>Sets Scanner Node disabled flag to true. This will result in the scanner unlinking from assigned bots (process happens off-chain in Assigner software) and not being able to be linked to any bot until re-enabled.</p> Name Type Description scanner address address"},{"location":"contracts/components/scanner_pools/ScannerPoolRegistry/#updateenabledscanners","title":"updateEnabledScanners","text":"<pre><code>function updateEnabledScanners(uint256 scannerPoolId, uint256 count) external\n</code></pre> <p>Updates enabled scanner count of a pool</p> Name Type Description scannerPoolId uint256 ERC721 token id of the ScannerPool count uint256"},{"location":"contracts/components/scanner_pools/ScannerPoolRegistry/#getscanner","title":"getScanner","text":"<pre><code>function getScanner(address scanner) public view returns (struct ScannerPoolRegistryCore.ScannerNode)\n</code></pre> <p>Gets ScannerNode struct for address</p>"},{"location":"contracts/components/scanner_pools/ScannerPoolRegistry/#getscannerstate","title":"getScannerState","text":"<pre><code>function getScannerState(address scanner) external view returns (bool registered, address owner, uint256 chainId, string metadata, bool operational, bool disabled)\n</code></pre> <p>Gets ScannerNode data for address</p>"},{"location":"contracts/components/scanner_pools/ScannerPoolRegistry/#setmanagedstakethreshold","title":"setManagedStakeThreshold","text":"<pre><code>function setManagedStakeThreshold(struct IStakeSubject.StakeThreshold newStakeThreshold, uint256 chainId) external\n</code></pre> <p>Sets stake parameters (min, max, activated) for scanners. Restricted to SCANNER_POOL_ADMIN_ROLE</p> Name Type Description newStakeThreshold struct IStakeSubject.StakeThreshold struct with stake parameters. chainId uint256 scanned chain the thresholds applies to."},{"location":"contracts/components/scanner_pools/ScannerPoolRegistry/#getmanagedstakethreshold","title":"getManagedStakeThreshold","text":"<pre><code>function getManagedStakeThreshold(uint256 managedId) public view returns (struct IStakeSubject.StakeThreshold)\n</code></pre> <p>Getter for StakeThreshold for the scanner with id <code>subject</code></p>"},{"location":"contracts/components/scanner_pools/ScannerPoolRegistry/#gettotalmanagedsubjects","title":"getTotalManagedSubjects","text":"<pre><code>function getTotalManagedSubjects(uint256 subject) public view virtual returns (uint256)\n</code></pre> <p>Total scanners registered to a ScannerPool</p>"},{"location":"contracts/components/scanner_pools/ScannerPoolRegistry/#setregistrationdelay","title":"setRegistrationDelay","text":"<pre><code>function setRegistrationDelay(uint256 delay) external\n</code></pre> <p>Sets maximum delay between execution of forta auth in Scan Node CLI and execution of registerScanner() in this contract</p>"},{"location":"contracts/components/scanner_pools/ScannerPoolRegistry/#_msgsender_1","title":"_msgSender","text":"<pre><code>function _msgSender() internal view virtual returns (address sender)\n</code></pre> <p>Helper to get either msg msg.sender if not a meta transaction, signer of forwarder metatx if it is.</p>"},{"location":"contracts/components/scanner_pools/ScannerPoolRegistry/#_msgdata_1","title":"_msgData","text":"<pre><code>function _msgData() internal view virtual returns (bytes)\n</code></pre> <p>Helper to get msg.data if not a meta transaction, forwarder data in metatx if it is.</p>"},{"location":"contracts/components/scanner_pools/ScannerPoolRegistry/#ownerof","title":"ownerOf","text":"<pre><code>function ownerOf(uint256 subject) public view virtual returns (address)\n</code></pre> <p>disambiguation of ownerOf.</p> <p>See {IERC721-ownerOf}.</p>"},{"location":"contracts/components/scanner_pools/ScannerPoolRegistry/#__gap_2","title":"__gap","text":"<pre><code>uint256[38] __gap\n</code></pre>"},{"location":"contracts/components/scanner_pools/ScannerPoolRegistryCore/","title":"ScannerPoolRegistryCore","text":""},{"location":"contracts/components/scanner_pools/ScannerPoolRegistryCore/#scannerpoolregistrycore","title":"ScannerPoolRegistryCore","text":""},{"location":"contracts/components/scanner_pools/ScannerPoolRegistryCore/#scannerupdated","title":"ScannerUpdated","text":"<pre><code>event ScannerUpdated(uint256 scannerId, uint256 chainId, string metadata, uint256 scannerPool)\n</code></pre>"},{"location":"contracts/components/scanner_pools/ScannerPoolRegistryCore/#managedstakethresholdchanged","title":"ManagedStakeThresholdChanged","text":"<pre><code>event ManagedStakeThresholdChanged(uint256 chainId, uint256 min, uint256 max, bool activated)\n</code></pre>"},{"location":"contracts/components/scanner_pools/ScannerPoolRegistryCore/#registrationdelayset","title":"RegistrationDelaySet","text":"<pre><code>event RegistrationDelaySet(uint256 delay)\n</code></pre>"},{"location":"contracts/components/scanner_pools/ScannerPoolRegistryCore/#scannerenabled","title":"ScannerEnabled","text":"<pre><code>event ScannerEnabled(uint256 scannerId, bool enabled, address sender, bool disableFlag)\n</code></pre>"},{"location":"contracts/components/scanner_pools/ScannerPoolRegistryCore/#enabledscannerschanged","title":"EnabledScannersChanged","text":"<pre><code>event EnabledScannersChanged(uint256 scannerPoolId, uint256 enabledScanners)\n</code></pre>"},{"location":"contracts/components/scanner_pools/ScannerPoolRegistryCore/#scannerpoolregistered","title":"ScannerPoolRegistered","text":"<pre><code>event ScannerPoolRegistered(uint256 scannerPoolId, uint256 chainId)\n</code></pre>"},{"location":"contracts/components/scanner_pools/ScannerPoolRegistryCore/#scannerpoolnotregistered","title":"ScannerPoolNotRegistered","text":"<pre><code>error ScannerPoolNotRegistered(uint256 scannerPoolId)\n</code></pre>"},{"location":"contracts/components/scanner_pools/ScannerPoolRegistryCore/#scannerexists","title":"ScannerExists","text":"<pre><code>error ScannerExists(address scanner)\n</code></pre>"},{"location":"contracts/components/scanner_pools/ScannerPoolRegistryCore/#scannernotregistered","title":"ScannerNotRegistered","text":"<pre><code>error ScannerNotRegistered(address scanner)\n</code></pre>"},{"location":"contracts/components/scanner_pools/ScannerPoolRegistryCore/#publicregistrationdisabled","title":"PublicRegistrationDisabled","text":"<pre><code>error PublicRegistrationDisabled(uint256 chainId)\n</code></pre>"},{"location":"contracts/components/scanner_pools/ScannerPoolRegistryCore/#registeringtoolate","title":"RegisteringTooLate","text":"<pre><code>error RegisteringTooLate()\n</code></pre>"},{"location":"contracts/components/scanner_pools/ScannerPoolRegistryCore/#signaturedoesnotmatch","title":"SignatureDoesNotMatch","text":"<pre><code>error SignatureDoesNotMatch()\n</code></pre>"},{"location":"contracts/components/scanner_pools/ScannerPoolRegistryCore/#cannotsetscanneractivation","title":"CannotSetScannerActivation","text":"<pre><code>error CannotSetScannerActivation()\n</code></pre>"},{"location":"contracts/components/scanner_pools/ScannerPoolRegistryCore/#sendernotscannerpool","title":"SenderNotScannerPool","text":"<pre><code>error SenderNotScannerPool(address sender, uint256 scannerPoolId)\n</code></pre>"},{"location":"contracts/components/scanner_pools/ScannerPoolRegistryCore/#chainidmismatch","title":"ChainIdMismatch","text":"<pre><code>error ChainIdMismatch(uint256 expected, uint256 provided)\n</code></pre>"},{"location":"contracts/components/scanner_pools/ScannerPoolRegistryCore/#actionshutsdownpool","title":"ActionShutsDownPool","text":"<pre><code>error ActionShutsDownPool()\n</code></pre>"},{"location":"contracts/components/scanner_pools/ScannerPoolRegistryCore/#scannerpreviouslyenabled","title":"ScannerPreviouslyEnabled","text":"<pre><code>error ScannerPreviouslyEnabled(address scanner)\n</code></pre>"},{"location":"contracts/components/scanner_pools/ScannerPoolRegistryCore/#scannerpreviouslydisabled","title":"ScannerPreviouslyDisabled","text":"<pre><code>error ScannerPreviouslyDisabled(address scanner)\n</code></pre>"},{"location":"contracts/components/scanner_pools/ScannerPoolRegistryCore/#constructor","title":"constructor","text":"<pre><code>constructor(address __stakeAllocator) internal\n</code></pre>"},{"location":"contracts/components/scanner_pools/ScannerPoolRegistryCore/#__scannerpoolregistrycore_init","title":"__ScannerPoolRegistryCore_init","text":"<pre><code>function __ScannerPoolRegistryCore_init(string __name, string __symbol, address __stakeSubjectGateway, uint256 __registrationDelay) internal\n</code></pre> <p>Initializer method</p> Name Type Description __name string ERC721 token name. __symbol string ERC721 token symbol. __stakeSubjectGateway address address of StakeSubjectGateway __registrationDelay uint256 amount of time allowed from scanner signing a ScannerNodeRegistration and it's execution by ScannerPool"},{"location":"contracts/components/scanner_pools/ScannerPoolRegistryCore/#isregistered","title":"isRegistered","text":"<pre><code>function isRegistered(uint256 scannerPoolId) public view returns (bool)\n</code></pre> <p>Checks if scannerPoolId has been registered (minted).</p> Name Type Description scannerPoolId uint256 ERC721 token id of the ScannerPool. Name Type Description [0] bool true if scannerPoolId exists, false otherwise."},{"location":"contracts/components/scanner_pools/ScannerPoolRegistryCore/#registerscannerpool","title":"registerScannerPool","text":"<pre><code>function registerScannerPool(uint256 chainId) external returns (uint256 scannerPoolId)\n</code></pre> <p>mints a ScannerPoolRegistry ERC721 NFT to sender Transferring ownership of a ScannerPoolRegistry NFT will transfer ownership of all its registered Scanner Node addresses</p> Name Type Description scannerPoolId uint256 (autoincremented uint)"},{"location":"contracts/components/scanner_pools/ScannerPoolRegistryCore/#monitoredchainid","title":"monitoredChainId","text":"<pre><code>function monitoredChainId(uint256 scannerPoolId) public view returns (uint256)\n</code></pre>"},{"location":"contracts/components/scanner_pools/ScannerPoolRegistryCore/#isscannerregistered","title":"isScannerRegistered","text":"<pre><code>function isScannerRegistered(address scanner) public view returns (bool)\n</code></pre> <p>Checks if scanner address has been registered</p> Name Type Description scanner address address. Name Type Description [0] bool true if scanner is registered, false otherwise."},{"location":"contracts/components/scanner_pools/ScannerPoolRegistryCore/#isscannerregisteredto","title":"isScannerRegisteredTo","text":"<pre><code>function isScannerRegisteredTo(address scanner, uint256 scannerPoolId) public view returns (bool)\n</code></pre> <p>Checks if scanner address has been registered to a specific scannerPoolId</p> Name Type Description scanner address address. scannerPoolId uint256 ERC721 token id of the ScannerPool. Name Type Description [0] bool true if scanner is registered to scannerPoolId, false otherwise."},{"location":"contracts/components/scanner_pools/ScannerPoolRegistryCore/#registerscannernode","title":"registerScannerNode","text":"<pre><code>function registerScannerNode(struct ScannerPoolRegistryCore.ScannerNodeRegistration req, bytes signature) external\n</code></pre> <p>Method to register a Scanner Node and associate it with a scannerPoolId. Before executing this method, make sure to have enough FORT staked by the owner of the Scanner Pool to be allocated to the new scanner, then register a scanner with Forta Scan Node CLI and obtain the parameters for this methods by executing forta auth. Follow the instructions https://docs.forta.network/en/latest/scan-node/introduction/ This method will try to allocate stake from unallocated stake if necessary. Individual ownership of a scaner node is not transferrable. A scanner node can be disabled, but not unregistered</p> Name Type Description req struct ScannerPoolRegistryCore.ScannerNodeRegistration ScannerNodeRegistration struct with the Scanner Node data. signature bytes ERC712 signature, result from signed req by the scanner."},{"location":"contracts/components/scanner_pools/ScannerPoolRegistryCore/#updatescannermetadata","title":"updateScannerMetadata","text":"<pre><code>function updateScannerMetadata(address scanner, string metadata) external\n</code></pre> <p>Method to update a registered Scanner Node metadata string. Only the ScannerPool that owns the scanner can update.</p> Name Type Description scanner address address. metadata string IPFS string pointing to Scanner Node metadata."},{"location":"contracts/components/scanner_pools/ScannerPoolRegistryCore/#totalscannersregistered","title":"totalScannersRegistered","text":"<pre><code>function totalScannersRegistered(uint256 scannerPoolId) public view returns (uint256)\n</code></pre> <p>gets the amount of Scanner Nodes ever registered to a ScannerPool Id. Useful for external iteration.</p> Name Type Description scannerPoolId uint256 ERC721 token id of the ScannerPool."},{"location":"contracts/components/scanner_pools/ScannerPoolRegistryCore/#registeredscanneratindex","title":"registeredScannerAtIndex","text":"<pre><code>function registeredScannerAtIndex(uint256 scannerPoolId, uint256 index) external view returns (struct ScannerPoolRegistryCore.ScannerNode)\n</code></pre> <p>gets the Scanner Node address at index registered to scannerPoolId Useful for external iteration.</p> Name Type Description scannerPoolId uint256 ERC721 token id of the ScannerPool. index uint256 of the registered Scanner Node. Must be lower than totalScannersRegistered(scannerPoolId)"},{"location":"contracts/components/scanner_pools/ScannerPoolRegistryCore/#registeredscanneraddressatindex","title":"registeredScannerAddressAtIndex","text":"<pre><code>function registeredScannerAddressAtIndex(uint256 scannerPoolId, uint256 index) external view returns (address)\n</code></pre> <p>gets the Scanner Node data struct at index registered to scannerPoolId Useful for external iteration.</p> Name Type Description scannerPoolId uint256 ERC721 token id of the ScannerPool. index uint256 of the registered Scanner Node. Must be lower than totalScannersRegistered(scannerPoolId)"},{"location":"contracts/components/scanner_pools/ScannerPoolRegistryCore/#scanneraddresstoid","title":"scannerAddressToId","text":"<pre><code>function scannerAddressToId(address scanner) public pure returns (uint256)\n</code></pre> <p>Converts scanner address to uint256 for FortaStaking Token Id.</p>"},{"location":"contracts/components/scanner_pools/ScannerPoolRegistryCore/#scanneridtoaddress","title":"scannerIdToAddress","text":"<pre><code>function scannerIdToAddress(uint256 scannerId) public pure returns (address)\n</code></pre> <p>Converts FortaStaking uint256 id to address.</p>"},{"location":"contracts/components/scanner_pools/ScannerPoolRegistryCore/#isscannerdisabled","title":"isScannerDisabled","text":"<pre><code>function isScannerDisabled(address scanner) public view returns (bool)\n</code></pre> <p>Gets if the disabled flag has been set for a Scanner Node Address</p>"},{"location":"contracts/components/scanner_pools/ScannerPoolRegistryCore/#isscanneroperational","title":"isScannerOperational","text":"<pre><code>function isScannerOperational(address scanner) public view returns (bool)\n</code></pre> <p>Checks if the Scanner Node is considered operational by the Forta Network, and is thus eligible for bot (Agent) assignment.</p> Name Type Description scanner address address Name Type Description [0] bool true if: - Scanner Node is registered AND - Scanner Node's disabled flag is not set (is false) AND - (Scanner Node has more than minimum stake allocated to it OR staking is not activated for the Scanner Node's chain)"},{"location":"contracts/components/scanner_pools/ScannerPoolRegistryCore/#willnewscannershutdownpool","title":"willNewScannerShutdownPool","text":"<pre><code>function willNewScannerShutdownPool(uint256 scannerPoolId) public view returns (bool)\n</code></pre> <p>returns true if one more enabled scanner (or one registration) would put ALL scanners under min threshold, (not operational)</p>"},{"location":"contracts/components/scanner_pools/ScannerPoolRegistryCore/#enablescanner","title":"enableScanner","text":"<pre><code>function enableScanner(address scanner) public\n</code></pre> <p>Sets Scanner Node disabled flag to false. It's not possible to re-enable a Scanner Node if allocatedStake / enabled scanners &lt; min. If there is enough unallocated stake, this method will allocate it. If not, it will revert.</p> Name Type Description scanner address address"},{"location":"contracts/components/scanner_pools/ScannerPoolRegistryCore/#disablescanner","title":"disableScanner","text":"<pre><code>function disableScanner(address scanner) public\n</code></pre> <p>Sets Scanner Node disabled flag to true. This will result in the scanner unlinking from assigned bots (process happens off-chain in Assigner software) and not being able to be linked to any bot until re-enabled.</p> Name Type Description scanner address address"},{"location":"contracts/components/scanner_pools/ScannerPoolRegistryCore/#updateenabledscanners","title":"updateEnabledScanners","text":"<pre><code>function updateEnabledScanners(uint256 scannerPoolId, uint256 count) external\n</code></pre> <p>Updates enabled scanner count of a pool</p> Name Type Description scannerPoolId uint256 ERC721 token id of the ScannerPool count uint256"},{"location":"contracts/components/scanner_pools/ScannerPoolRegistryCore/#getscanner","title":"getScanner","text":"<pre><code>function getScanner(address scanner) public view returns (struct ScannerPoolRegistryCore.ScannerNode)\n</code></pre> <p>Gets ScannerNode struct for address</p>"},{"location":"contracts/components/scanner_pools/ScannerPoolRegistryCore/#getscannerstate","title":"getScannerState","text":"<pre><code>function getScannerState(address scanner) external view returns (bool registered, address owner, uint256 chainId, string metadata, bool operational, bool disabled)\n</code></pre> <p>Gets ScannerNode data for address</p>"},{"location":"contracts/components/scanner_pools/ScannerPoolRegistryCore/#setmanagedstakethreshold","title":"setManagedStakeThreshold","text":"<pre><code>function setManagedStakeThreshold(struct IStakeSubject.StakeThreshold newStakeThreshold, uint256 chainId) external\n</code></pre> <p>Sets stake parameters (min, max, activated) for scanners. Restricted to SCANNER_POOL_ADMIN_ROLE</p> Name Type Description newStakeThreshold struct IStakeSubject.StakeThreshold struct with stake parameters. chainId uint256 scanned chain the thresholds applies to."},{"location":"contracts/components/scanner_pools/ScannerPoolRegistryCore/#getmanagedstakethreshold","title":"getManagedStakeThreshold","text":"<pre><code>function getManagedStakeThreshold(uint256 managedId) public view returns (struct IStakeSubject.StakeThreshold)\n</code></pre> <p>Getter for StakeThreshold for the scanner with id <code>subject</code></p>"},{"location":"contracts/components/scanner_pools/ScannerPoolRegistryCore/#gettotalmanagedsubjects","title":"getTotalManagedSubjects","text":"<pre><code>function getTotalManagedSubjects(uint256 subject) public view virtual returns (uint256)\n</code></pre> <p>Total scanners registered to a ScannerPool</p>"},{"location":"contracts/components/scanner_pools/ScannerPoolRegistryCore/#setregistrationdelay","title":"setRegistrationDelay","text":"<pre><code>function setRegistrationDelay(uint256 delay) external\n</code></pre> <p>Sets maximum delay between execution of forta auth in Scan Node CLI and execution of registerScanner() in this contract</p>"},{"location":"contracts/components/scanner_pools/ScannerPoolRegistryCore/#_msgsender","title":"_msgSender","text":"<pre><code>function _msgSender() internal view virtual returns (address sender)\n</code></pre> <p>Helper to get either msg msg.sender if not a meta transaction, signer of forwarder metatx if it is.</p>"},{"location":"contracts/components/scanner_pools/ScannerPoolRegistryCore/#_msgdata","title":"_msgData","text":"<pre><code>function _msgData() internal view virtual returns (bytes)\n</code></pre> <p>Helper to get msg.data if not a meta transaction, forwarder data in metatx if it is.</p>"},{"location":"contracts/components/scanner_pools/ScannerPoolRegistryCore/#ownerof","title":"ownerOf","text":"<pre><code>function ownerOf(uint256 subject) public view virtual returns (address)\n</code></pre> <p>disambiguation of ownerOf.</p> <p>See {IERC721-ownerOf}.</p>"},{"location":"contracts/components/scanner_pools/ScannerPoolRegistryCore/#__gap","title":"__gap","text":"<pre><code>uint256[38] __gap\n</code></pre>"},{"location":"contracts/components/scanner_pools/ScannerPoolRegistryManaged/","title":"ScannerPoolRegistryManaged","text":""},{"location":"contracts/components/scanner_pools/ScannerPoolRegistryManaged/#scannerpoolregistrymanaged","title":"ScannerPoolRegistryManaged","text":""},{"location":"contracts/components/scanner_pools/ScannerPoolRegistryManaged/#managerenabled","title":"ManagerEnabled","text":"<pre><code>event ManagerEnabled(uint256 scannerPoolId, address manager, bool enabled)\n</code></pre>"},{"location":"contracts/components/scanner_pools/ScannerPoolRegistryManaged/#sendernotmanager","title":"SenderNotManager","text":"<pre><code>error SenderNotManager(address sender, uint256 scannerPoolId)\n</code></pre>"},{"location":"contracts/components/scanner_pools/ScannerPoolRegistryManaged/#onlymanagerof","title":"onlyManagerOf","text":"<pre><code>modifier onlyManagerOf(uint256 scannerPoolId)\n</code></pre> <p>Checks sender (or metatx signer) is manager of the scanner pool token.</p> Name Type Description scannerPoolId uint256 ERC721 token id of the ScannerPool"},{"location":"contracts/components/scanner_pools/ScannerPoolRegistryManaged/#ismanager","title":"isManager","text":"<pre><code>function isManager(uint256 scannerPoolId, address manager) public view returns (bool)\n</code></pre> <p>Checks if address is defined as a manager for a ScannerPool's registered Scanner Nodes.</p> Name Type Description scannerPoolId uint256 ERC721 token id of the ScannerPool manager address address to check. Name Type Description [0] bool true if defined as manager for ScannerPool, false otherwise."},{"location":"contracts/components/scanner_pools/ScannerPoolRegistryManaged/#getmanagercount","title":"getManagerCount","text":"<pre><code>function getManagerCount(uint256 scannerPoolId) public view virtual returns (uint256)\n</code></pre> <p>Gets total managers defined for a ScannerPool's registered Scanner Nodes.</p> <p>helper for external iteration.</p> Name Type Description scannerPoolId uint256 ERC721 token id of the ScannerPool Name Type Description [0] uint256 total managers defined for a ScannerPool."},{"location":"contracts/components/scanner_pools/ScannerPoolRegistryManaged/#getmanagerat","title":"getManagerAt","text":"<pre><code>function getManagerAt(uint256 scannerPoolId, uint256 index) public view virtual returns (address)\n</code></pre> <p>Gets manager address at certain position of the ScannerPool's registered Scanner Nodes.</p> <p>helper for external iteration.</p> Name Type Description scannerPoolId uint256 ERC721 token id of the ScannerPool index uint256 position in the set. Name Type Description [0] address address of the manager at index."},{"location":"contracts/components/scanner_pools/ScannerPoolRegistryManaged/#setmanager","title":"setManager","text":"<pre><code>function setManager(uint256 scannerPoolId, address manager, bool enable) public\n</code></pre> <p>Adds or removes a manager to a certain ScannerPool's registered Scanner Nodes. Restricted to ScannerPoolRegistry owner.</p> Name Type Description scannerPoolId uint256 ERC721 token id of the ScannerPool manager address address to be added or removed from manager list for the ScannerPool. enable bool true for adding, false for removing."},{"location":"contracts/components/scanner_pools/ScannerPoolRegistryManaged/#__gap","title":"__gap","text":"<pre><code>uint256[49] __gap\n</code></pre>"},{"location":"contracts/components/scanners/ScannerNodeVersion/","title":"ScannerNodeVersion","text":""},{"location":"contracts/components/scanners/ScannerNodeVersion/#scannernodeversion","title":"ScannerNodeVersion","text":"<p>Contract that will trigger software autoupdate of the Scanner Node software. Forta Governance, through SCANNER_VERSION_ROLE, will propose and approve updates and the nodes will listen to the resulting event, downloading the new version from IPFS. A similar system is provided for pre release version.</p>"},{"location":"contracts/components/scanners/ScannerNodeVersion/#scannernodeversion_1","title":"scannerNodeVersion","text":"<pre><code>string scannerNodeVersion\n</code></pre> <p>Version of the scanner image software the network expects (IPFS hash) Starts empty</p>"},{"location":"contracts/components/scanners/ScannerNodeVersion/#scannernodebetaversion","title":"scannerNodeBetaVersion","text":"<pre><code>string scannerNodeBetaVersion\n</code></pre> <p>Version of the scanner image software for pre release version (IPFS hash) Starts empty</p>"},{"location":"contracts/components/scanners/ScannerNodeVersion/#version","title":"version","text":"<pre><code>string version\n</code></pre> <p>Contract version</p>"},{"location":"contracts/components/scanners/ScannerNodeVersion/#scannernodeversionupdated","title":"ScannerNodeVersionUpdated","text":"<pre><code>event ScannerNodeVersionUpdated(string newVersion, string oldVersion)\n</code></pre>"},{"location":"contracts/components/scanners/ScannerNodeVersion/#scannernodebetaversionupdated","title":"ScannerNodeBetaVersionUpdated","text":"<pre><code>event ScannerNodeBetaVersionUpdated(string newVersion, string oldVersion)\n</code></pre>"},{"location":"contracts/components/scanners/ScannerNodeVersion/#samescannernodeversion","title":"SameScannerNodeVersion","text":"<pre><code>error SameScannerNodeVersion()\n</code></pre>"},{"location":"contracts/components/scanners/ScannerNodeVersion/#constructor","title":"constructor","text":"<pre><code>constructor(address forwarder) public\n</code></pre>"},{"location":"contracts/components/scanners/ScannerNodeVersion/#initialize","title":"initialize","text":"<pre><code>function initialize(address __manager) public\n</code></pre> <p>Initializer method, access point to initialize inheritance tree.</p> Name Type Description __manager address address of AccessManager."},{"location":"contracts/components/scanners/ScannerNodeVersion/#setscannernodeversion","title":"setScannerNodeVersion","text":"<pre><code>function setScannerNodeVersion(string _version) public\n</code></pre> <p>Signal to the Scanner Nodes that they have to update their binaries downloading the new version from IPFS, by emitting ScannerNodeVersionUpdated(newVersion, oldVersion).</p> <p>restricted to SCANNER_VERSION_ROLE.</p> Name Type Description _version string IPFS pointer to the new image."},{"location":"contracts/components/scanners/ScannerNodeVersion/#setscannernodebetaversion","title":"setScannerNodeBetaVersion","text":"<pre><code>function setScannerNodeBetaVersion(string _version) public\n</code></pre> <p>Signal to the Scanner Nodes that there is a new beta release downloadable from from IPFS, by emitting ScannerNodeVersionUpdated(newVersion, oldVersion).</p> <p>restricted to SCANNER_BETA_VERSION_ROLE.</p> Name Type Description _version string IPFS pointer to the new image."},{"location":"contracts/components/scanners/ScannerNodeVersion/#__gap","title":"__gap","text":"<pre><code>uint256[48] __gap\n</code></pre>"},{"location":"contracts/components/scanners/ScannerRegistry/","title":"Scanner Registry","text":""},{"location":"contracts/components/scanners/ScannerRegistry/#scannerregistry","title":"ScannerRegistry","text":""},{"location":"contracts/components/scanners/ScannerRegistry/#deregisteredscanner","title":"DeregisteredScanner","text":"<pre><code>event DeregisteredScanner(uint256 scannerId)\n</code></pre>"},{"location":"contracts/components/scanners/ScannerRegistry/#configuredmigration","title":"ConfiguredMigration","text":"<pre><code>event ConfiguredMigration(uint256 sunsettingTime, address scannerPoolRegistry)\n</code></pre>"},{"location":"contracts/components/scanners/ScannerRegistry/#version","title":"version","text":"<pre><code>string version\n</code></pre>"},{"location":"contracts/components/scanners/ScannerRegistry/#constructor","title":"constructor","text":"<pre><code>constructor(address forwarder) public\n</code></pre>"},{"location":"contracts/components/scanners/ScannerRegistry/#cannotderegister","title":"CannotDeregister","text":"<pre><code>error CannotDeregister(uint256 scannerId)\n</code></pre>"},{"location":"contracts/components/scanners/ScannerRegistry/#initialize","title":"initialize","text":"<pre><code>function initialize(address __manager, string __name, string __symbol) public\n</code></pre> <p>Initializer method, access point to initialize inheritance tree.</p> Name Type Description __manager address address of AccessManager. __name string ERC721 token name. __symbol string ERC721 token symbol."},{"location":"contracts/components/scanners/ScannerRegistry/#getscannerstate","title":"getScannerState","text":"<pre><code>function getScannerState(uint256 scannerId) external view returns (bool registered, address owner, uint256 chainId, string metadata, bool enabled, uint256 disabledFlags)\n</code></pre> <p>Gets all scanner properties and state</p> Name Type Description scannerId uint256 ERC721 token id of the scanner. Name Type Description registered bool true if scanner exists. owner address address. chainId uint256 the scanner is monitoring. metadata string IPFS pointer for the scanner's JSON metadata. enabled bool true if staked over minimum and not disabled. disabledFlags uint256 0 if not disabled, Permission if disabled."},{"location":"contracts/components/scanners/ScannerRegistry/#getscanner","title":"getScanner","text":"<pre><code>function getScanner(uint256 scannerId) public view virtual returns (bool registered, address owner, uint256 chainId, string metadata)\n</code></pre> <p>Gets all scanner properties.</p> Name Type Description scannerId uint256 ERC721 token id of the scanner. Name Type Description registered bool true if scanner exists. owner address address. chainId uint256 the scanner is monitoring. metadata string IPFS pointer for the scanner's JSON metadata."},{"location":"contracts/components/scanners/ScannerRegistry/#isenabled","title":"isEnabled","text":"<pre><code>function isEnabled(uint256 scannerId) public view virtual returns (bool)\n</code></pre> <p>Check if scanner is enabled</p> Name Type Description scannerId uint256 ERC721 token id of the scanner. Name Type Description [0] bool true if the scanner is registered, has not been disabled, and is staked over minimum value. Returns false if otherwise"},{"location":"contracts/components/scanners/ScannerRegistry/#hasmigrationended","title":"hasMigrationEnded","text":"<pre><code>function hasMigrationEnded() public view returns (bool)\n</code></pre>"},{"location":"contracts/components/scanners/ScannerRegistry/#deregisterscannernode","title":"deregisterScannerNode","text":"<pre><code>function deregisterScannerNode(uint256 scannerId) external\n</code></pre>"},{"location":"contracts/components/scanners/ScannerRegistry/#setmigrationprefrence","title":"setMigrationPrefrence","text":"<pre><code>function setMigrationPrefrence(uint256 scannerId, bool isOut) external\n</code></pre> <p>Declares preference for migration from ScanerRegistry to ScannerPoolRegistry. Default is yes.</p> Name Type Description scannerId uint256 ERC721 id isOut bool true if the scanner does not want to be migrated to the ScannerPoolRegistry (and deleted)"},{"location":"contracts/components/scanners/ScannerRegistry/#configuremigration","title":"configureMigration","text":"<pre><code>function configureMigration(uint256 _sunsettingTime, address _scannerPoolRegistry) external\n</code></pre> <p>Configures migration params</p> Name Type Description _sunsettingTime uint256 time after which the scanners won't be operational (isEnabled will return false) and will not get bot assignments or rewards. _scannerPoolRegistry address new registry, for compatibility for off chain components during migration"},{"location":"contracts/components/scanners/ScannerRegistry/#_getstakethreshold","title":"_getStakeThreshold","text":"<pre><code>function _getStakeThreshold(uint256 subject) internal view virtual returns (struct IStakeSubject.StakeThreshold)\n</code></pre> <p>inheritance disambiguation for _getStakeThreshold see ScannerRegistryMetadata</p>"},{"location":"contracts/components/scanners/ScannerRegistry/#_msgsender","title":"_msgSender","text":"<pre><code>function _msgSender() internal view virtual returns (address sender)\n</code></pre> <p>Helper to get either msg msg.sender if not a meta transaction, signer of forwarder metatx if it is.</p>"},{"location":"contracts/components/scanners/ScannerRegistry/#_msgdata","title":"_msgData","text":"<pre><code>function _msgData() internal view virtual returns (bytes)\n</code></pre> <p>Helper to get msg.data if not a meta transaction, forwarder data in metatx if it is.</p>"},{"location":"contracts/components/scanners/ScannerRegistry/#__gap","title":"__gap","text":"<pre><code>uint256[47] __gap\n</code></pre>"},{"location":"contracts/components/scanners/ScannerRegistry/#scannerregistrymetadata","title":"ScannerRegistryMetadata","text":""},{"location":"contracts/components/scanners/ScannerRegistry/#scannermetadata","title":"ScannerMetadata","text":"<pre><code>struct ScannerMetadata {\n  uint256 chainId;\n  string metadata;\n}\n</code></pre>"},{"location":"contracts/components/scanners/ScannerRegistry/#_scannermetadata","title":"_scannerMetadata","text":"<pre><code>mapping(uint256 =&gt; struct ScannerRegistryMetadata.ScannerMetadata) _scannerMetadata\n</code></pre>"},{"location":"contracts/components/scanners/ScannerRegistry/#getscanner_1","title":"getScanner","text":"<pre><code>function getScanner(uint256 scannerId) public view virtual returns (bool registered, address owner, uint256 chainId, string metadata)\n</code></pre> <p>Gets all scanner properties.</p> Name Type Description scannerId uint256 ERC721 token id of the scanner. Name Type Description registered bool true if scanner exists. owner address address. chainId uint256 the scanner is monitoring. metadata string IPFS pointer for the scanner's JSON metadata."},{"location":"contracts/components/scanners/ScannerRegistry/#getscannerchainid","title":"getScannerChainId","text":"<pre><code>function getScannerChainId(uint256 scannerId) public view returns (uint256)\n</code></pre> <p>Gets scanner chain Ids.</p> Name Type Description scannerId uint256 ERC721 token id of the scanner. Name Type Description [0] uint256 chainId the scanner is monitoring."},{"location":"contracts/components/scanners/ScannerRegistry/#_getstakethreshold_1","title":"_getStakeThreshold","text":"<pre><code>function _getStakeThreshold(uint256 subject) internal view virtual returns (struct IStakeSubject.StakeThreshold)\n</code></pre> <p>checks the StakeThreshold for the chainId the scanner with id <code>subject</code> was registered to monitor.</p> Name Type Description subject uint256 ERC721 token id of the scanner. Name Type Description [0] struct IStakeSubject.StakeThreshold StakeThreshold registered for <code>chainId</code>, or StakeThreshold(0,0,false) if <code>chainId</code> not found."},{"location":"contracts/components/scanners/ScannerRegistry/#__gap_1","title":"__gap","text":"<pre><code>uint256[49] __gap\n</code></pre>"},{"location":"contracts/components/scanners/ScannerRegistry/#scannerregistryenable","title":"ScannerRegistryEnable","text":"<p>ScannerRegistry methods and state handling disabling and enabling scanners, and recognizing stake changes that might disable a scanner. NOTE: This contract was deployed before StakeAwareUpgradeable was created, so __StakeAwareUpgradeable_init is not called.</p>"},{"location":"contracts/components/scanners/ScannerRegistry/#permission","title":"Permission","text":"<pre><code>enum Permission {\n  ADMIN,\n  SELF,\n  OWNER,\n  MANAGER,\n  length\n}\n</code></pre>"},{"location":"contracts/components/scanners/ScannerRegistry/#scannerenabled","title":"ScannerEnabled","text":"<pre><code>event ScannerEnabled(uint256 scannerId, bool enabled, enum ScannerRegistryEnable.Permission permission, bool value)\n</code></pre>"},{"location":"contracts/components/scanners/ScannerRegistry/#isenabled_1","title":"isEnabled","text":"<pre><code>function isEnabled(uint256 scannerId) public view virtual returns (bool)\n</code></pre> <p>Check if scanner is enabled</p> Name Type Description scannerId uint256 ERC721 token id of the scanner. Name Type Description [0] bool true if the scanner is registered, has not been disabled, and is staked over minimum value. Returns false if otherwise"},{"location":"contracts/components/scanners/ScannerRegistry/#enablescanner","title":"enableScanner","text":"<pre><code>function enableScanner(uint256 scannerId, enum ScannerRegistryEnable.Permission permission) public virtual\n</code></pre> <p>Public method to enable a scanner, if caller has permission. Scanner must be staked over minimum defined for the scanner's chainId.</p> Name Type Description scannerId uint256 ERC721 token id of the scanner. permission enum ScannerRegistryEnable.Permission the caller claims to have."},{"location":"contracts/components/scanners/ScannerRegistry/#disablescanner","title":"disableScanner","text":"<pre><code>function disableScanner(uint256 scannerId, enum ScannerRegistryEnable.Permission permission) public virtual\n</code></pre> <p>Public method to disable a scanner, if caller has permission.</p> Name Type Description scannerId uint256 ERC721 token id of the scanner. permission enum ScannerRegistryEnable.Permission the caller claims to have."},{"location":"contracts/components/scanners/ScannerRegistry/#_getdisableflags","title":"_getDisableFlags","text":"<pre><code>function _getDisableFlags(uint256 scannerId) internal view returns (uint256)\n</code></pre> <p>Get the disabled flags for an agentId. Permission (uint8) is used for indexing, so we don't need to loop.  If not disabled, all flags will be 0</p> Name Type Description scannerId uint256 ERC721 token id of the scanner. Name Type Description [0] uint256 uint256 containing the byte flags."},{"location":"contracts/components/scanners/ScannerRegistry/#_haspermission","title":"_hasPermission","text":"<pre><code>function _hasPermission(uint256 scannerId, enum ScannerRegistryEnable.Permission permission) internal view returns (bool)\n</code></pre> <p>Method that does permission checks.</p> <p>AccessManager is not used since the permission is specific for scannerId</p> Name Type Description scannerId uint256 ERC721 token id of the scanner. permission enum ScannerRegistryEnable.Permission the caller claims to have. Name Type Description [0] bool true if (ADMIN and _msgSender() has SCANNER_ADMIN_ROLE), if _msgSender() is the scanner itself, its owner or manager for each respective permission, false otherwise."},{"location":"contracts/components/scanners/ScannerRegistry/#_enable","title":"_enable","text":"<pre><code>function _enable(uint256 scannerId, enum ScannerRegistryEnable.Permission permission, bool enable) internal\n</code></pre> <p>Internal method to enable a scanner.</p> <p>will trigger _before and _after enable hooks within the inheritance tree.</p> Name Type Description scannerId uint256 ERC721 token id of the scanner. permission enum ScannerRegistryEnable.Permission the caller claims to have. enable bool true for enabling, false for disabling"},{"location":"contracts/components/scanners/ScannerRegistry/#_msgsender_1","title":"_msgSender","text":"<pre><code>function _msgSender() internal view virtual returns (address sender)\n</code></pre> <p>Obligatory inheritance dismambiguation of ForwardedContext's _msgSender()</p> Name Type Description sender address msg.sender if not a meta transaction, signer of forwarder metatx if it is."},{"location":"contracts/components/scanners/ScannerRegistry/#_msgdata_1","title":"_msgData","text":"<pre><code>function _msgData() internal view virtual returns (bytes)\n</code></pre> <p>Obligatory inheritance dismambiguation of ForwardedContext's _msgSender()</p> Name Type Description [0] bytes sender msg.data if not a meta transaction, forwarder data in metatx if it is."},{"location":"contracts/components/scanners/ScannerRegistry/#__gap_2","title":"__gap","text":"<pre><code>uint256[49] __gap\n</code></pre>"},{"location":"contracts/components/scanners/ScannerRegistry/#scannerregistrymanaged","title":"ScannerRegistryManaged","text":""},{"location":"contracts/components/scanners/ScannerRegistry/#_managers","title":"_managers","text":"<pre><code>mapping(uint256 =&gt; struct EnumerableSet.AddressSet) _managers\n</code></pre>"},{"location":"contracts/components/scanners/ScannerRegistry/#managerenabled","title":"ManagerEnabled","text":"<pre><code>event ManagerEnabled(uint256 scannerId, address manager, bool enabled)\n</code></pre>"},{"location":"contracts/components/scanners/ScannerRegistry/#sendernotmanager","title":"SenderNotManager","text":"<pre><code>error SenderNotManager(address sender, uint256 scannerId)\n</code></pre>"},{"location":"contracts/components/scanners/ScannerRegistry/#onlymanagerof","title":"onlyManagerOf","text":"<pre><code>modifier onlyManagerOf(uint256 scannerId)\n</code></pre> <p>Checks sender (or metatx signer) is manager of the scanner token.</p> Name Type Description scannerId uint256 ERC721 token id of the scanner."},{"location":"contracts/components/scanners/ScannerRegistry/#ismanager","title":"isManager","text":"<pre><code>function isManager(uint256 scannerId, address manager) public view virtual returns (bool)\n</code></pre> <p>Checks if address is defined as a manager for a scanner.</p> Name Type Description scannerId uint256 ERC721 token id of the scanner. manager address address to check. Name Type Description [0] bool true if defined as manager for scanner, false otherwise."},{"location":"contracts/components/scanners/ScannerRegistry/#getmanagercount","title":"getManagerCount","text":"<pre><code>function getManagerCount(uint256 scannerId) public view virtual returns (uint256)\n</code></pre> <p>Gets total managers defined for a scanner.</p> <p>helper for external iteration.</p> Name Type Description scannerId uint256 ERC721 token id of the scanner. Name Type Description [0] uint256 total managers defined for a scanner."},{"location":"contracts/components/scanners/ScannerRegistry/#getmanagerat","title":"getManagerAt","text":"<pre><code>function getManagerAt(uint256 scannerId, uint256 index) public view virtual returns (address)\n</code></pre> <p>Gets manager address at certain position of the scanner's manager set.</p> <p>helper for external iteration.</p> Name Type Description scannerId uint256 ERC721 token id of the scanner. index uint256 position in the set. Name Type Description [0] address address of the manager at index."},{"location":"contracts/components/scanners/ScannerRegistry/#__gap_3","title":"__gap","text":"<pre><code>uint256[49] __gap\n</code></pre>"},{"location":"contracts/components/scanners/ScannerRegistry/#scannerregistrycore","title":"ScannerRegistryCore","text":""},{"location":"contracts/components/scanners/ScannerRegistry/#scannerupdated","title":"ScannerUpdated","text":"<pre><code>event ScannerUpdated(uint256 scannerId, uint256 chainId, string metadata)\n</code></pre>"},{"location":"contracts/components/scanners/ScannerRegistry/#stakethresholdchanged","title":"StakeThresholdChanged","text":"<pre><code>event StakeThresholdChanged(uint256 chainId, uint256 min, uint256 max, bool activated)\n</code></pre>"},{"location":"contracts/components/scanners/ScannerRegistry/#scannernotregistered","title":"ScannerNotRegistered","text":"<pre><code>error ScannerNotRegistered(address scanner)\n</code></pre>"},{"location":"contracts/components/scanners/ScannerRegistry/#onlyownerof","title":"onlyOwnerOf","text":"<pre><code>modifier onlyOwnerOf(uint256 scannerId)\n</code></pre> <p>Checks sender (or metatx signer) is owner of the scanner token.</p> Name Type Description scannerId uint256 ERC721 token id of the scanner."},{"location":"contracts/components/scanners/ScannerRegistry/#isregistered","title":"isRegistered","text":"<pre><code>function isRegistered(uint256 scannerId) public view returns (bool)\n</code></pre> <p>Checks if scannerId has been registered (minted).</p> Name Type Description scannerId uint256 ERC721 token id of the scanner. Name Type Description [0] bool true if scannerId exists, false otherwise."},{"location":"contracts/components/scanners/ScannerRegistry/#scanneraddresstoid","title":"scannerAddressToId","text":"<pre><code>function scannerAddressToId(address scanner) public pure returns (uint256)\n</code></pre> <p>Converts scanner address to uint256 for ERC721 Token Id.</p>"},{"location":"contracts/components/scanners/ScannerRegistry/#setstakethreshold","title":"setStakeThreshold","text":"<pre><code>function setStakeThreshold(struct IStakeSubject.StakeThreshold newStakeThreshold, uint256 chainId) external\n</code></pre> <p>Sets stake parameters (min, max, activated) for a <code>chainId</code>. Restricted to SCANNER_ADMIN_ROLE</p> Name Type Description newStakeThreshold struct IStakeSubject.StakeThreshold struct with stake parameters. chainId uint256 chain the parameters will affect."},{"location":"contracts/components/scanners/ScannerRegistry/#getstakethreshold","title":"getStakeThreshold","text":"<pre><code>function getStakeThreshold(uint256 subject) external view returns (struct IStakeSubject.StakeThreshold)\n</code></pre> <p>Getter for StakeThreshold for the scanner with id <code>subject</code></p>"},{"location":"contracts/components/scanners/ScannerRegistry/#_msgsender_2","title":"_msgSender","text":"<pre><code>function _msgSender() internal view virtual returns (address sender)\n</code></pre> <p>Helper to get either msg msg.sender if not a meta transaction, signer of forwarder metatx if it is.</p>"},{"location":"contracts/components/scanners/ScannerRegistry/#_msgdata_2","title":"_msgData","text":"<pre><code>function _msgData() internal view virtual returns (bytes)\n</code></pre> <p>Helper to get msg.data if not a meta transaction, forwarder data in metatx if it is.</p>"},{"location":"contracts/components/scanners/ScannerRegistry/#ownerof","title":"ownerOf","text":"<pre><code>function ownerOf(uint256 subject) public view virtual returns (address)\n</code></pre> <p>disambiguation of ownerOf.</p> <p>See {IERC721-ownerOf}.</p>"},{"location":"contracts/components/scanners/ScannerRegistry/#__gap_4","title":"__gap","text":"<pre><code>uint256[44] __gap\n</code></pre>"},{"location":"contracts/components/scanners/ScannerRegistryCore/","title":"ScannerRegistryCore","text":""},{"location":"contracts/components/scanners/ScannerRegistryCore/#scannerregistrycore","title":"ScannerRegistryCore","text":""},{"location":"contracts/components/scanners/ScannerRegistryCore/#scannerupdated","title":"ScannerUpdated","text":"<pre><code>event ScannerUpdated(uint256 scannerId, uint256 chainId, string metadata)\n</code></pre>"},{"location":"contracts/components/scanners/ScannerRegistryCore/#stakethresholdchanged","title":"StakeThresholdChanged","text":"<pre><code>event StakeThresholdChanged(uint256 chainId, uint256 min, uint256 max, bool activated)\n</code></pre>"},{"location":"contracts/components/scanners/ScannerRegistryCore/#scannernotregistered","title":"ScannerNotRegistered","text":"<pre><code>error ScannerNotRegistered(address scanner)\n</code></pre>"},{"location":"contracts/components/scanners/ScannerRegistryCore/#onlyownerof","title":"onlyOwnerOf","text":"<pre><code>modifier onlyOwnerOf(uint256 scannerId)\n</code></pre> <p>Checks sender (or metatx signer) is owner of the scanner token.</p> Name Type Description scannerId uint256 ERC721 token id of the scanner."},{"location":"contracts/components/scanners/ScannerRegistryCore/#isregistered","title":"isRegistered","text":"<pre><code>function isRegistered(uint256 scannerId) public view returns (bool)\n</code></pre> <p>Checks if scannerId has been registered (minted).</p> Name Type Description scannerId uint256 ERC721 token id of the scanner. Name Type Description [0] bool true if scannerId exists, false otherwise."},{"location":"contracts/components/scanners/ScannerRegistryCore/#scanneraddresstoid","title":"scannerAddressToId","text":"<pre><code>function scannerAddressToId(address scanner) public pure returns (uint256)\n</code></pre> <p>Converts scanner address to uint256 for ERC721 Token Id.</p>"},{"location":"contracts/components/scanners/ScannerRegistryCore/#setstakethreshold","title":"setStakeThreshold","text":"<pre><code>function setStakeThreshold(struct IStakeSubject.StakeThreshold newStakeThreshold, uint256 chainId) external\n</code></pre> <p>Sets stake parameters (min, max, activated) for a <code>chainId</code>. Restricted to SCANNER_ADMIN_ROLE</p> Name Type Description newStakeThreshold struct IStakeSubject.StakeThreshold struct with stake parameters. chainId uint256 chain the parameters will affect."},{"location":"contracts/components/scanners/ScannerRegistryCore/#getstakethreshold","title":"getStakeThreshold","text":"<pre><code>function getStakeThreshold(uint256 subject) external view returns (struct IStakeSubject.StakeThreshold)\n</code></pre> <p>Getter for StakeThreshold for the scanner with id <code>subject</code></p>"},{"location":"contracts/components/scanners/ScannerRegistryCore/#_msgsender","title":"_msgSender","text":"<pre><code>function _msgSender() internal view virtual returns (address sender)\n</code></pre> <p>Helper to get either msg msg.sender if not a meta transaction, signer of forwarder metatx if it is.</p>"},{"location":"contracts/components/scanners/ScannerRegistryCore/#_msgdata","title":"_msgData","text":"<pre><code>function _msgData() internal view virtual returns (bytes)\n</code></pre> <p>Helper to get msg.data if not a meta transaction, forwarder data in metatx if it is.</p>"},{"location":"contracts/components/scanners/ScannerRegistryCore/#ownerof","title":"ownerOf","text":"<pre><code>function ownerOf(uint256 subject) public view virtual returns (address)\n</code></pre> <p>disambiguation of ownerOf.</p> <p>See {IERC721-ownerOf}.</p>"},{"location":"contracts/components/scanners/ScannerRegistryCore/#__gap","title":"__gap","text":"<pre><code>uint256[44] __gap\n</code></pre>"},{"location":"contracts/components/scanners/ScannerRegistryEnable/","title":"ScannerRegistryEnable","text":""},{"location":"contracts/components/scanners/ScannerRegistryEnable/#scannerregistryenable","title":"ScannerRegistryEnable","text":"<p>ScannerRegistry methods and state handling disabling and enabling scanners, and recognizing stake changes that might disable a scanner. NOTE: This contract was deployed before StakeAwareUpgradeable was created, so __StakeAwareUpgradeable_init is not called.</p>"},{"location":"contracts/components/scanners/ScannerRegistryEnable/#permission","title":"Permission","text":"<pre><code>enum Permission {\n  ADMIN,\n  SELF,\n  OWNER,\n  MANAGER,\n  length\n}\n</code></pre>"},{"location":"contracts/components/scanners/ScannerRegistryEnable/#scannerenabled","title":"ScannerEnabled","text":"<pre><code>event ScannerEnabled(uint256 scannerId, bool enabled, enum ScannerRegistryEnable.Permission permission, bool value)\n</code></pre>"},{"location":"contracts/components/scanners/ScannerRegistryEnable/#isenabled","title":"isEnabled","text":"<pre><code>function isEnabled(uint256 scannerId) public view virtual returns (bool)\n</code></pre> <p>Check if scanner is enabled</p> Name Type Description scannerId uint256 ERC721 token id of the scanner. Name Type Description [0] bool true if the scanner is registered, has not been disabled, and is staked over minimum value. Returns false if otherwise"},{"location":"contracts/components/scanners/ScannerRegistryEnable/#enablescanner","title":"enableScanner","text":"<pre><code>function enableScanner(uint256 scannerId, enum ScannerRegistryEnable.Permission permission) public virtual\n</code></pre> <p>Public method to enable a scanner, if caller has permission. Scanner must be staked over minimum defined for the scanner's chainId.</p> Name Type Description scannerId uint256 ERC721 token id of the scanner. permission enum ScannerRegistryEnable.Permission the caller claims to have."},{"location":"contracts/components/scanners/ScannerRegistryEnable/#disablescanner","title":"disableScanner","text":"<pre><code>function disableScanner(uint256 scannerId, enum ScannerRegistryEnable.Permission permission) public virtual\n</code></pre> <p>Public method to disable a scanner, if caller has permission.</p> Name Type Description scannerId uint256 ERC721 token id of the scanner. permission enum ScannerRegistryEnable.Permission the caller claims to have."},{"location":"contracts/components/scanners/ScannerRegistryEnable/#_getdisableflags","title":"_getDisableFlags","text":"<pre><code>function _getDisableFlags(uint256 scannerId) internal view returns (uint256)\n</code></pre> <p>Get the disabled flags for an agentId. Permission (uint8) is used for indexing, so we don't need to loop.  If not disabled, all flags will be 0</p> Name Type Description scannerId uint256 ERC721 token id of the scanner. Name Type Description [0] uint256 uint256 containing the byte flags."},{"location":"contracts/components/scanners/ScannerRegistryEnable/#_haspermission","title":"_hasPermission","text":"<pre><code>function _hasPermission(uint256 scannerId, enum ScannerRegistryEnable.Permission permission) internal view returns (bool)\n</code></pre> <p>Method that does permission checks.</p> <p>AccessManager is not used since the permission is specific for scannerId</p> Name Type Description scannerId uint256 ERC721 token id of the scanner. permission enum ScannerRegistryEnable.Permission the caller claims to have. Name Type Description [0] bool true if (ADMIN and _msgSender() has SCANNER_ADMIN_ROLE), if _msgSender() is the scanner itself, its owner or manager for each respective permission, false otherwise."},{"location":"contracts/components/scanners/ScannerRegistryEnable/#_enable","title":"_enable","text":"<pre><code>function _enable(uint256 scannerId, enum ScannerRegistryEnable.Permission permission, bool enable) internal\n</code></pre> <p>Internal method to enable a scanner.</p> <p>will trigger _before and _after enable hooks within the inheritance tree.</p> Name Type Description scannerId uint256 ERC721 token id of the scanner. permission enum ScannerRegistryEnable.Permission the caller claims to have. enable bool true for enabling, false for disabling"},{"location":"contracts/components/scanners/ScannerRegistryEnable/#_msgsender","title":"_msgSender","text":"<pre><code>function _msgSender() internal view virtual returns (address sender)\n</code></pre> <p>Obligatory inheritance dismambiguation of ForwardedContext's _msgSender()</p> Name Type Description sender address msg.sender if not a meta transaction, signer of forwarder metatx if it is."},{"location":"contracts/components/scanners/ScannerRegistryEnable/#_msgdata","title":"_msgData","text":"<pre><code>function _msgData() internal view virtual returns (bytes)\n</code></pre> <p>Obligatory inheritance dismambiguation of ForwardedContext's _msgSender()</p> Name Type Description [0] bytes sender msg.data if not a meta transaction, forwarder data in metatx if it is."},{"location":"contracts/components/scanners/ScannerRegistryEnable/#__gap","title":"__gap","text":"<pre><code>uint256[49] __gap\n</code></pre>"},{"location":"contracts/components/scanners/ScannerRegistryManaged/","title":"ScannerRegistryManaged","text":""},{"location":"contracts/components/scanners/ScannerRegistryManaged/#scannerregistrymanaged","title":"ScannerRegistryManaged","text":""},{"location":"contracts/components/scanners/ScannerRegistryManaged/#_managers","title":"_managers","text":"<pre><code>mapping(uint256 =&gt; struct EnumerableSet.AddressSet) _managers\n</code></pre>"},{"location":"contracts/components/scanners/ScannerRegistryManaged/#managerenabled","title":"ManagerEnabled","text":"<pre><code>event ManagerEnabled(uint256 scannerId, address manager, bool enabled)\n</code></pre>"},{"location":"contracts/components/scanners/ScannerRegistryManaged/#sendernotmanager","title":"SenderNotManager","text":"<pre><code>error SenderNotManager(address sender, uint256 scannerId)\n</code></pre>"},{"location":"contracts/components/scanners/ScannerRegistryManaged/#onlymanagerof","title":"onlyManagerOf","text":"<pre><code>modifier onlyManagerOf(uint256 scannerId)\n</code></pre> <p>Checks sender (or metatx signer) is manager of the scanner token.</p> Name Type Description scannerId uint256 ERC721 token id of the scanner."},{"location":"contracts/components/scanners/ScannerRegistryManaged/#ismanager","title":"isManager","text":"<pre><code>function isManager(uint256 scannerId, address manager) public view virtual returns (bool)\n</code></pre> <p>Checks if address is defined as a manager for a scanner.</p> Name Type Description scannerId uint256 ERC721 token id of the scanner. manager address address to check. Name Type Description [0] bool true if defined as manager for scanner, false otherwise."},{"location":"contracts/components/scanners/ScannerRegistryManaged/#getmanagercount","title":"getManagerCount","text":"<pre><code>function getManagerCount(uint256 scannerId) public view virtual returns (uint256)\n</code></pre> <p>Gets total managers defined for a scanner.</p> <p>helper for external iteration.</p> Name Type Description scannerId uint256 ERC721 token id of the scanner. Name Type Description [0] uint256 total managers defined for a scanner."},{"location":"contracts/components/scanners/ScannerRegistryManaged/#getmanagerat","title":"getManagerAt","text":"<pre><code>function getManagerAt(uint256 scannerId, uint256 index) public view virtual returns (address)\n</code></pre> <p>Gets manager address at certain position of the scanner's manager set.</p> <p>helper for external iteration.</p> Name Type Description scannerId uint256 ERC721 token id of the scanner. index uint256 position in the set. Name Type Description [0] address address of the manager at index."},{"location":"contracts/components/scanners/ScannerRegistryManaged/#__gap","title":"__gap","text":"<pre><code>uint256[49] __gap\n</code></pre>"},{"location":"contracts/components/scanners/ScannerRegistryMetadata/","title":"ScannerRegistryMetadata","text":""},{"location":"contracts/components/scanners/ScannerRegistryMetadata/#scannerregistrymetadata","title":"ScannerRegistryMetadata","text":""},{"location":"contracts/components/scanners/ScannerRegistryMetadata/#scannermetadata","title":"ScannerMetadata","text":"<pre><code>struct ScannerMetadata {\n  uint256 chainId;\n  string metadata;\n}\n</code></pre>"},{"location":"contracts/components/scanners/ScannerRegistryMetadata/#_scannermetadata","title":"_scannerMetadata","text":"<pre><code>mapping(uint256 =&gt; struct ScannerRegistryMetadata.ScannerMetadata) _scannerMetadata\n</code></pre>"},{"location":"contracts/components/scanners/ScannerRegistryMetadata/#getscanner","title":"getScanner","text":"<pre><code>function getScanner(uint256 scannerId) public view virtual returns (bool registered, address owner, uint256 chainId, string metadata)\n</code></pre> <p>Gets all scanner properties.</p> Name Type Description scannerId uint256 ERC721 token id of the scanner. Name Type Description registered bool true if scanner exists. owner address address. chainId uint256 the scanner is monitoring. metadata string IPFS pointer for the scanner's JSON metadata."},{"location":"contracts/components/scanners/ScannerRegistryMetadata/#getscannerchainid","title":"getScannerChainId","text":"<pre><code>function getScannerChainId(uint256 scannerId) public view returns (uint256)\n</code></pre> <p>Gets scanner chain Ids.</p> Name Type Description scannerId uint256 ERC721 token id of the scanner. Name Type Description [0] uint256 chainId the scanner is monitoring."},{"location":"contracts/components/scanners/ScannerRegistryMetadata/#_getstakethreshold","title":"_getStakeThreshold","text":"<pre><code>function _getStakeThreshold(uint256 subject) internal view virtual returns (struct IStakeSubject.StakeThreshold)\n</code></pre> <p>checks the StakeThreshold for the chainId the scanner with id <code>subject</code> was registered to monitor.</p> Name Type Description subject uint256 ERC721 token id of the scanner. Name Type Description [0] struct IStakeSubject.StakeThreshold StakeThreshold registered for <code>chainId</code>, or StakeThreshold(0,0,false) if <code>chainId</code> not found."},{"location":"contracts/components/scanners/ScannerRegistryMetadata/#__gap","title":"__gap","text":"<pre><code>uint256[49] __gap\n</code></pre>"},{"location":"contracts/components/scanners/ScannerToNodeRunnerMigration/","title":"Scanner To Scanner Pool Migration","text":""},{"location":"contracts/components/scanners/ScannerToNodeRunnerMigration/#scannertoscannerpoolmigration","title":"ScannerToScannerPoolMigration","text":"<p>Migration of ScannerRegistry to ScannerPoolRegistry</p>"},{"location":"contracts/components/scanners/ScannerToNodeRunnerMigration/#version","title":"version","text":"<pre><code>string version\n</code></pre> <p>Contract version</p>"},{"location":"contracts/components/scanners/ScannerToNodeRunnerMigration/#migrationexecuted","title":"MigrationExecuted","text":"<pre><code>event MigrationExecuted(uint256 scannersMigrated, uint256 scannersIgnored, uint256 scannerPoolId, bool mintedScannerPool)\n</code></pre>"},{"location":"contracts/components/scanners/ScannerToNodeRunnerMigration/#notownerofscannerpool","title":"NotOwnerOfScannerPool","text":"<pre><code>error NotOwnerOfScannerPool(address pretender, uint256 scannerPoolId)\n</code></pre>"},{"location":"contracts/components/scanners/ScannerToNodeRunnerMigration/#wrongscannerchainid","title":"WrongScannerChainId","text":"<pre><code>error WrongScannerChainId(uint256 expected, uint256 provided, address scanner)\n</code></pre>"},{"location":"contracts/components/scanners/ScannerToNodeRunnerMigration/#wrongscannerpoolchainid","title":"WrongScannerPoolChainId","text":"<pre><code>error WrongScannerPoolChainId(uint256 expected, uint256 provided, uint256 scannerPoolId)\n</code></pre>"},{"location":"contracts/components/scanners/ScannerToNodeRunnerMigration/#scannerpoolalreadymigrated","title":"ScannerPoolAlreadyMigrated","text":"<pre><code>error ScannerPoolAlreadyMigrated(uint256 scannerPoolId)\n</code></pre>"},{"location":"contracts/components/scanners/ScannerToNodeRunnerMigration/#constructor","title":"constructor","text":"<pre><code>constructor(address _forwarder, address _scannerNodeRegistry, address _scannerPoolRegistry, address _stakeMigrator) public\n</code></pre>"},{"location":"contracts/components/scanners/ScannerToNodeRunnerMigration/#selfmigrate","title":"selfMigrate","text":"<pre><code>function selfMigrate(address[] scanners, uint256 scannerPoolId, uint256 chainId) external returns (uint256)\n</code></pre> <p>Method to self migrate from the old ScannerRegistry NFTs to a single ScannerPoolRegistry NFT, per chain. WARNING: ScannerNodeRegistry's manager addresses will not be migrated, please user ScannerPoolRegistry's methods to set them again.</p> Name Type Description scanners address[] array of scanner addresses to be migrated. All the scanners willing to migrate (optingOutOfMigration flags set to false) ScannerRegistry ERC721 identified by the uint256(address) in the input array will be: - Registered in ScannerPoolRegistry to the scannerPoolId either indicated or generated, with the same chainId and metadata. - Deleted in ScannerNodeRegistry. The ERC721 will be burned, disabled flags and managers deleted from storage. Scanners with optingOutOfMigration flags == true will be ignored (opted out), and will stay in ScannerNodeRegistry. At migration end, they will stop receiving work and rewards. scannerPoolId uint256 If set as 0, a new ScannerPoolRegistry ERC721 will be minted to scannerPool, otherwise it must be set as a valid ScannerPoolRegistry ERC721 id owned by scannerPool. chainId uint256 Name Type Description [0] uint256 ScannerPoolRegistry ERC721 id the scanners are migrated to."},{"location":"contracts/components/scanners/ScannerToNodeRunnerMigration/#migrate","title":"migrate","text":"<pre><code>function migrate(address[] scanners, uint256 scannerPoolId, address scannerPool, uint256 chainId) external returns (uint256)\n</code></pre> <p>Method to migrate from the old ScannerRegistry NFTs to a single ScannerPoolRegistry NFT, executed by an address with the role MIGRATION_EXECUTOR_ROLE. WARNING: ScannerNodeRegistry's manager addresses will not be migrated, please user ScannerPoolRegistry's methods to set them again.</p> Name Type Description scanners address[] array of scanner addresses to be migrated. All the scanners willing to migrate (optingOutOfMigration flags set to false) ScannerRegistry ERC721 identified by the uint256(address) in the input array will be: - Registered in ScannerPoolRegistry to the scannerPoolId either indicated or generated, with the same chainId and metadata. - Deleted in ScannerNodeRegistry. The ERC721 will be burned, disabled flags and managers deleted from storage. Scanners with with optingOutOfMigration flags == true will be ignored (opted out), and will stay in ScannerNodeRegistry. scannerPoolId uint256 If set as 0, a new ScannerPoolRegistry ERC721 will be minted to scannerPool, otherwise it must be set as a valid ScannerPoolRegistry ERC721 id owned by scannerPool. scannerPool address address that owns the scanners and will own the ScannerPoolRegistry ERC721 chainId uint256 Name Type Description [0] uint256 ScannerPoolRegistry ERC721 id the scanners are migrated to."},{"location":"contracts/components/scanners/ScannerToNodeRunnerMigration/#__gap","title":"__gap","text":"<pre><code>uint256[49] __gap\n</code></pre>"},{"location":"contracts/components/staking/Accumulators/","title":"Accumulators","text":""},{"location":"contracts/components/staking/Accumulators/#epoch_length","title":"EPOCH_LENGTH","text":""},{"location":"contracts/components/staking/Accumulators/#accumulators","title":"Accumulators","text":""},{"location":"contracts/components/staking/Accumulators/#getlatestaccumulated","title":"getLatestAccumulated","text":"<pre><code>function getLatestAccumulated(struct Accumulators.Accumulator acc) internal view returns (uint256)\n</code></pre>"},{"location":"contracts/components/staking/Accumulators/#getaccumulatedforepoch","title":"getAccumulatedForEpoch","text":"<pre><code>function getAccumulatedForEpoch(struct Accumulators.Accumulator acc, uint256 epoch) internal view returns (uint256)\n</code></pre>"},{"location":"contracts/components/staking/Accumulators/#getepochtotalfrominitialrate","title":"getEpochTotalFromInitialRate","text":"<pre><code>function getEpochTotalFromInitialRate(struct Accumulators.Accumulator acc, uint256 epoch) internal view returns (uint256)\n</code></pre>"},{"location":"contracts/components/staking/Accumulators/#isfirstepoch","title":"isFirstEpoch","text":"<pre><code>function isFirstEpoch(struct Accumulators.Accumulator acc, uint256 epoch) internal view returns (bool)\n</code></pre>"},{"location":"contracts/components/staking/Accumulators/#addrate","title":"addRate","text":"<pre><code>function addRate(struct Accumulators.Accumulator acc, uint256 rate) internal\n</code></pre>"},{"location":"contracts/components/staking/Accumulators/#subrate","title":"subRate","text":"<pre><code>function subRate(struct Accumulators.Accumulator acc, uint256 rate) internal\n</code></pre>"},{"location":"contracts/components/staking/Accumulators/#setrate","title":"setRate","text":"<pre><code>function setRate(struct Accumulators.Accumulator acc, uint256 rate) internal\n</code></pre>"},{"location":"contracts/components/staking/Accumulators/#latest","title":"latest","text":"<pre><code>function latest(struct Accumulators.Accumulator acc) internal view returns (struct Accumulators.EpochCheckpoint)\n</code></pre>"},{"location":"contracts/components/staking/Accumulators/#checkpointlength","title":"checkPointLength","text":"<pre><code>function checkPointLength(struct Accumulators.Accumulator acc) internal view returns (uint256)\n</code></pre>"},{"location":"contracts/components/staking/Accumulators/#getcheckpointatepoch","title":"getCheckpointAtEpoch","text":"<pre><code>function getCheckpointAtEpoch(struct Accumulators.Accumulator acc, uint256 epochNumber) internal view returns (struct Accumulators.EpochCheckpoint)\n</code></pre> <p>Returns the most recent checkpoint during a given epoch. If a checkpoint is not available at that epoch, the closest one before it is returned, or a zero epoch checkpoint otherwise.</p>"},{"location":"contracts/components/staking/Accumulators/#zeroepoch","title":"zeroEpoch","text":"<pre><code>function zeroEpoch() private pure returns (struct Accumulators.EpochCheckpoint)\n</code></pre>"},{"location":"contracts/components/staking/Accumulators/#getepochnumber","title":"getEpochNumber","text":"<pre><code>function getEpochNumber(uint256 timestamp) internal pure returns (uint32)\n</code></pre>"},{"location":"contracts/components/staking/Accumulators/#getcurrentepochnumber","title":"getCurrentEpochNumber","text":"<pre><code>function getCurrentEpochNumber() internal view returns (uint32)\n</code></pre>"},{"location":"contracts/components/staking/Accumulators/#getepochstarttimestamp","title":"getEpochStartTimestamp","text":"<pre><code>function getEpochStartTimestamp(uint256 epochNumber) internal pure returns (uint256)\n</code></pre>"},{"location":"contracts/components/staking/Accumulators/#getcurrentepochstarttimestamp","title":"getCurrentEpochStartTimestamp","text":"<pre><code>function getCurrentEpochStartTimestamp() internal view returns (uint256)\n</code></pre>"},{"location":"contracts/components/staking/Accumulators/#getepochendtimestamp","title":"getEpochEndTimestamp","text":"<pre><code>function getEpochEndTimestamp(uint256 epochNumber) internal pure returns (uint256)\n</code></pre>"},{"location":"contracts/components/staking/Accumulators/#getcurrentepochendtimestamp","title":"getCurrentEpochEndTimestamp","text":"<pre><code>function getCurrentEpochEndTimestamp() internal view returns (uint256)\n</code></pre>"},{"location":"contracts/components/staking/Accumulators/#iscurrentepoch","title":"isCurrentEpoch","text":"<pre><code>function isCurrentEpoch(uint256 timestamp) internal view returns (bool)\n</code></pre>"},{"location":"contracts/components/staking/DelegatedStakeSubject/","title":"Delegated Stake Subject","text":""},{"location":"contracts/components/staking/DelegatedStakeSubject/#delegatedstakesubjectupgradeable","title":"DelegatedStakeSubjectUpgradeable","text":""},{"location":"contracts/components/staking/DelegatedStakeSubject/#subjecthandlerupdated","title":"SubjectHandlerUpdated","text":"<pre><code>event SubjectHandlerUpdated(address newHandler)\n</code></pre>"},{"location":"contracts/components/staking/DelegatedStakeSubject/#stakedunderminimum","title":"StakedUnderMinimum","text":"<pre><code>error StakedUnderMinimum(uint256 subject)\n</code></pre>"},{"location":"contracts/components/staking/DelegatedStakeSubject/#setsubjecthandler","title":"setSubjectHandler","text":"<pre><code>function setSubjectHandler(address subjectGateway) public\n</code></pre> <p>Stake controller setter, restricted to DEFAULT_ADMIN_ROLE</p>"},{"location":"contracts/components/staking/DelegatedStakeSubject/#getsubjecthandler","title":"getSubjectHandler","text":"<pre><code>function getSubjectHandler() public view returns (contract IStakeSubjectGateway)\n</code></pre> <p>Getter for subjectGateway</p>"},{"location":"contracts/components/staking/DelegatedStakeSubject/#__gap","title":"__gap","text":"<pre><code>uint256[4] __gap\n</code></pre>"},{"location":"contracts/components/staking/DirectStakeSubject/","title":"Direct Stake Subject","text":""},{"location":"contracts/components/staking/DirectStakeSubject/#directstakesubjectupgradeable","title":"DirectStakeSubjectUpgradeable","text":""},{"location":"contracts/components/staking/DirectStakeSubject/#subjecthandlerupdated","title":"SubjectHandlerUpdated","text":"<pre><code>event SubjectHandlerUpdated(address newHandler)\n</code></pre>"},{"location":"contracts/components/staking/DirectStakeSubject/#stakedunderminimum","title":"StakedUnderMinimum","text":"<pre><code>error StakedUnderMinimum(uint256 subject)\n</code></pre>"},{"location":"contracts/components/staking/DirectStakeSubject/#setsubjecthandler","title":"setSubjectHandler","text":"<pre><code>function setSubjectHandler(address subjectGateway) public\n</code></pre> <p>Stake controller setter, restricted to DEFAULT_ADMIN_ROLE</p>"},{"location":"contracts/components/staking/DirectStakeSubject/#getsubjecthandler","title":"getSubjectHandler","text":"<pre><code>function getSubjectHandler() public view returns (contract IStakeSubjectGateway)\n</code></pre> <p>Getter for subjectGateway</p>"},{"location":"contracts/components/staking/DirectStakeSubject/#isstakedovermin","title":"isStakedOverMin","text":"<pre><code>function isStakedOverMin(uint256 subject) external view virtual returns (bool)\n</code></pre> <p>Returns true if <code>subject</code> amount of staked tokens is bigger or equal the minimum stake set for it. It's for contracts implementing <code>StakeSubjectUpgradeable</code> to decide what that means.</p>"},{"location":"contracts/components/staking/DirectStakeSubject/#ownerof","title":"ownerOf","text":"<pre><code>function ownerOf(uint256 subject) external view virtual returns (address)\n</code></pre>"},{"location":"contracts/components/staking/DirectStakeSubject/#__gap","title":"__gap","text":"<pre><code>uint256[4] __gap\n</code></pre>"},{"location":"contracts/components/staking/FortaStaking/","title":"Forta Staking","text":""},{"location":"contracts/components/staking/FortaStaking/#fortastaking","title":"FortaStaking","text":"<p>_This is a generic staking contract for the Forta platform. It allows any account to deposit ERC20 tokens to delegate their \"power\" by staking on behalf of a particular subject. The subject can be scanner, or any other actor in the Forta ecosystem, who need to lock assets in order to contribute to the system.</p> <p>Stakers take risks with their funds, as bad action from a subject can lead to slashing of the funds. In the meantime, stakers are elligible for rewards. Rewards distributed to a particular subject's stakers are distributed following to each staker's share in the subject.</p> <p>Stakers can withdraw their funds, following a withdrawal delay. During the withdrawal delay, funds are no longer counting toward the active stake of a subject, but are still slashable.</p> <p>The SLASHER_ROLE should be given to a smart contract that will be in charge of handling the slashing proposal process.</p> <p>Stakers receive ERC1155 shares in exchange for their stake, making the active stake transferable. When a withdrawal is initiated, similarly the ERC1155 tokens representing the (transferable) active shares are burned in exchange for non-transferable ERC1155 tokens representing the inactive shares.</p> <p>ERC1155 shares representing active stake are transferable, and can be used in an AMM. Their value is however subject to quick devaluation in case of slashing event for the corresponding subject. Thus, trading of such shares should be be done very carefully.</p> <p>WARNING: To stake from another smart contract (smart contract wallets included), it must be fully ERC1155 compatible, implementing ERC1155Receiver. If not, minting of active and inactive shares will fail. Do not deposit on the constructor if you don't implement ERC1155Receiver. During the construction, the minting will succeed but you will not be able to withdraw or mint new shares from the contract. If this happens, transfer your shares to an EOA or fully ERC1155 compatible contract._</p>"},{"location":"contracts/components/staking/FortaStaking/#stakedtoken","title":"stakedToken","text":"<pre><code>contract IERC20 stakedToken\n</code></pre>"},{"location":"contracts/components/staking/FortaStaking/#_activestake","title":"_activeStake","text":"<pre><code>struct Distributions.Balances _activeStake\n</code></pre>"},{"location":"contracts/components/staking/FortaStaking/#_inactivestake","title":"_inactiveStake","text":"<pre><code>struct Distributions.Balances _inactiveStake\n</code></pre>"},{"location":"contracts/components/staking/FortaStaking/#_lockingdelay","title":"_lockingDelay","text":"<pre><code>mapping(uint256 =&gt; mapping(address =&gt; struct Timers.Timestamp)) _lockingDelay\n</code></pre>"},{"location":"contracts/components/staking/FortaStaking/#_rewards","title":"_rewards","text":"<pre><code>struct Distributions.Balances _rewards\n</code></pre>"},{"location":"contracts/components/staking/FortaStaking/#_released","title":"_released","text":"<pre><code>mapping(uint256 =&gt; struct Distributions.SignedBalances) _released\n</code></pre>"},{"location":"contracts/components/staking/FortaStaking/#_deprecated_frozen","title":"_deprecated_frozen","text":"<pre><code>mapping(uint256 =&gt; bool) _deprecated_frozen\n</code></pre>"},{"location":"contracts/components/staking/FortaStaking/#_withdrawaldelay","title":"_withdrawalDelay","text":"<pre><code>uint64 _withdrawalDelay\n</code></pre>"},{"location":"contracts/components/staking/FortaStaking/#_treasury","title":"_treasury","text":"<pre><code>address _treasury\n</code></pre>"},{"location":"contracts/components/staking/FortaStaking/#subjectgateway","title":"subjectGateway","text":"<pre><code>contract IStakeSubjectGateway subjectGateway\n</code></pre>"},{"location":"contracts/components/staking/FortaStaking/#slashdelegatorspercent","title":"slashDelegatorsPercent","text":"<pre><code>uint256 slashDelegatorsPercent\n</code></pre>"},{"location":"contracts/components/staking/FortaStaking/#allocator","title":"allocator","text":"<pre><code>contract IStakeAllocator allocator\n</code></pre>"},{"location":"contracts/components/staking/FortaStaking/#openproposals","title":"openProposals","text":"<pre><code>mapping(uint256 =&gt; uint256) openProposals\n</code></pre>"},{"location":"contracts/components/staking/FortaStaking/#_reentrancystatus","title":"_reentrancyStatus","text":"<pre><code>uint256 _reentrancyStatus\n</code></pre>"},{"location":"contracts/components/staking/FortaStaking/#min_withdrawal_delay","title":"MIN_WITHDRAWAL_DELAY","text":"<pre><code>uint256 MIN_WITHDRAWAL_DELAY\n</code></pre>"},{"location":"contracts/components/staking/FortaStaking/#max_withdrawal_delay","title":"MAX_WITHDRAWAL_DELAY","text":"<pre><code>uint256 MAX_WITHDRAWAL_DELAY\n</code></pre>"},{"location":"contracts/components/staking/FortaStaking/#max_slashable_percent","title":"MAX_SLASHABLE_PERCENT","text":"<pre><code>uint256 MAX_SLASHABLE_PERCENT\n</code></pre>"},{"location":"contracts/components/staking/FortaStaking/#hundred_percent","title":"HUNDRED_PERCENT","text":"<pre><code>uint256 HUNDRED_PERCENT\n</code></pre>"},{"location":"contracts/components/staking/FortaStaking/#stakedeposited","title":"StakeDeposited","text":"<pre><code>event StakeDeposited(uint8 subjectType, uint256 subject, address account, uint256 amount)\n</code></pre>"},{"location":"contracts/components/staking/FortaStaking/#withdrawalinitiated","title":"WithdrawalInitiated","text":"<pre><code>event WithdrawalInitiated(uint8 subjectType, uint256 subject, address account, uint64 deadline)\n</code></pre>"},{"location":"contracts/components/staking/FortaStaking/#withdrawalexecuted","title":"WithdrawalExecuted","text":"<pre><code>event WithdrawalExecuted(uint8 subjectType, uint256 subject, address account)\n</code></pre>"},{"location":"contracts/components/staking/FortaStaking/#froze","title":"Froze","text":"<pre><code>event Froze(uint8 subjectType, uint256 subject, address by, bool isFrozen)\n</code></pre>"},{"location":"contracts/components/staking/FortaStaking/#slashed","title":"Slashed","text":"<pre><code>event Slashed(uint8 subjectType, uint256 subject, address by, uint256 value)\n</code></pre>"},{"location":"contracts/components/staking/FortaStaking/#slashedsharesent","title":"SlashedShareSent","text":"<pre><code>event SlashedShareSent(uint8 subjectType, uint256 subject, address by, uint256 value)\n</code></pre>"},{"location":"contracts/components/staking/FortaStaking/#delayset","title":"DelaySet","text":"<pre><code>event DelaySet(uint256 newWithdrawalDelay)\n</code></pre>"},{"location":"contracts/components/staking/FortaStaking/#treasuryset","title":"TreasurySet","text":"<pre><code>event TreasurySet(address newTreasury)\n</code></pre>"},{"location":"contracts/components/staking/FortaStaking/#stakehelpersconfigured","title":"StakeHelpersConfigured","text":"<pre><code>event StakeHelpersConfigured(address subjectGateway, address allocator)\n</code></pre>"},{"location":"contracts/components/staking/FortaStaking/#maxstakereached","title":"MaxStakeReached","text":"<pre><code>event MaxStakeReached(uint8 subjectType, uint256 subject)\n</code></pre>"},{"location":"contracts/components/staking/FortaStaking/#tokensswept","title":"TokensSwept","text":"<pre><code>event TokensSwept(address token, address to, uint256 amount)\n</code></pre>"},{"location":"contracts/components/staking/FortaStaking/#slashdelegatorspercentset","title":"SlashDelegatorsPercentSet","text":"<pre><code>event SlashDelegatorsPercentSet(uint256 percent)\n</code></pre>"},{"location":"contracts/components/staking/FortaStaking/#withdrawalnotready","title":"WithdrawalNotReady","text":"<pre><code>error WithdrawalNotReady()\n</code></pre>"},{"location":"contracts/components/staking/FortaStaking/#slashingover90percent","title":"SlashingOver90Percent","text":"<pre><code>error SlashingOver90Percent()\n</code></pre>"},{"location":"contracts/components/staking/FortaStaking/#withdrawalsharesnottransferible","title":"WithdrawalSharesNotTransferible","text":"<pre><code>error WithdrawalSharesNotTransferible()\n</code></pre>"},{"location":"contracts/components/staking/FortaStaking/#frozensubject","title":"FrozenSubject","text":"<pre><code>error FrozenSubject()\n</code></pre>"},{"location":"contracts/components/staking/FortaStaking/#noactiveshares","title":"NoActiveShares","text":"<pre><code>error NoActiveShares()\n</code></pre>"},{"location":"contracts/components/staking/FortaStaking/#noinactiveshares","title":"NoInactiveShares","text":"<pre><code>error NoInactiveShares()\n</code></pre>"},{"location":"contracts/components/staking/FortaStaking/#stakeinactiveorsubjectnotfound","title":"StakeInactiveOrSubjectNotFound","text":"<pre><code>error StakeInactiveOrSubjectNotFound()\n</code></pre>"},{"location":"contracts/components/staking/FortaStaking/#version","title":"version","text":"<pre><code>string version\n</code></pre>"},{"location":"contracts/components/staking/FortaStaking/#constructor","title":"constructor","text":"<pre><code>constructor(address _forwarder) public\n</code></pre>"},{"location":"contracts/components/staking/FortaStaking/#initialize","title":"initialize","text":"<pre><code>function initialize(address __manager, contract IERC20 __stakedToken, uint64 __withdrawalDelay, address __treasury) public\n</code></pre> <p>Initializer method, access point to initialize inheritance tree.</p> Name Type Description __manager address address of AccessManager. __stakedToken contract IERC20 ERC20 to be staked (FORT). __withdrawalDelay uint64 cooldown period between withdrawal init and withdrawal (in seconds). __treasury address address where the slashed tokens go to."},{"location":"contracts/components/staking/FortaStaking/#setreentrancyguard","title":"setReentrancyGuard","text":"<pre><code>function setReentrancyGuard() public\n</code></pre> <p>Reinitializer to setup the reentrancy guard (introduced in v0.1.2)</p>"},{"location":"contracts/components/staking/FortaStaking/#_setstatus","title":"_setStatus","text":"<pre><code>function _setStatus(uint256 newStatus) internal virtual\n</code></pre>"},{"location":"contracts/components/staking/FortaStaking/#_getstatus","title":"_getStatus","text":"<pre><code>function _getStatus() internal virtual returns (uint256)\n</code></pre>"},{"location":"contracts/components/staking/FortaStaking/#treasury","title":"treasury","text":"<pre><code>function treasury() public view returns (address)\n</code></pre> <p>Returns treasury address (slashed tokens destination)</p>"},{"location":"contracts/components/staking/FortaStaking/#activestakefor","title":"activeStakeFor","text":"<pre><code>function activeStakeFor(uint8 subjectType, uint256 subject) public view returns (uint256)\n</code></pre> <p>Get stake of a subject (not marked for withdrawal).</p> Name Type Description subjectType uint8 type id of Stake Subject. See SubjectTypeValidator.sol subject uint256 id identifying subject (external to FortaStaking). Name Type Description [0] uint256 amount of stakedToken actively staked on subject+subjectType."},{"location":"contracts/components/staking/FortaStaking/#totalactivestake","title":"totalActiveStake","text":"<pre><code>function totalActiveStake() public view returns (uint256)\n</code></pre> <p>Get total active stake of all subjects (not marked for withdrawal).</p> Name Type Description [0] uint256 amount of stakedToken actively staked on all subject+subjectTypes."},{"location":"contracts/components/staking/FortaStaking/#inactivestakefor","title":"inactiveStakeFor","text":"<pre><code>function inactiveStakeFor(uint8 subjectType, uint256 subject) external view returns (uint256)\n</code></pre> <p>Get inactive stake of a subject (marked for withdrawal).</p> Name Type Description subjectType uint8 type id of Stake Subject. See SubjectTypeValidator.sol subject uint256 id identifying subject (external to FortaStaking). Name Type Description [0] uint256 amount of stakedToken still staked on subject+subjectType but marked for withdrawal."},{"location":"contracts/components/staking/FortaStaking/#totalinactivestake","title":"totalInactiveStake","text":"<pre><code>function totalInactiveStake() public view returns (uint256)\n</code></pre> <p>Get total inactive stake of all subjects (marked for withdrawal).</p> Name Type Description [0] uint256 amount of stakedToken still staked on all subject+subjectTypes but marked for withdrawal."},{"location":"contracts/components/staking/FortaStaking/#sharesof","title":"sharesOf","text":"<pre><code>function sharesOf(uint8 subjectType, uint256 subject, address account) public view returns (uint256)\n</code></pre> <p>Get (active) shares of an account on a subject, corresponding to a fraction of the subject stake.</p> <p>This is equivalent to getting the ERC1155 balanceOf for keccak256(abi.encodePacked(subjectType, subject)), shifted 9 bits, with the 9th bit set and uint8(subjectType) masked in</p> Name Type Description subjectType uint8 type id of Stake Subject. See SubjectTypeValidator.sol subject uint256 id identifying subject (external to FortaStaking). account address holder of the ERC1155 staking shares. Name Type Description [0] uint256 amount of ERC1155 shares account is in possession in representing stake on subject+subjectType."},{"location":"contracts/components/staking/FortaStaking/#totalshares","title":"totalShares","text":"<pre><code>function totalShares(uint8 subjectType, uint256 subject) external view returns (uint256)\n</code></pre> <p>Get the total (active) shares on a subject.</p> <p>This is equivalent to getting the ERC1155 totalSupply for keccak256(abi.encodePacked(subjectType, subject)), shifted 9 bits, with the 9th bit set and uint8(subjectType) masked in</p> Name Type Description subjectType uint8 type id of Stake Subject. See SubjectTypeValidator.sol subject uint256 id identifying subject (external to FortaStaking). Name Type Description [0] uint256 total ERC1155 shares representing stake on subject+subjectType."},{"location":"contracts/components/staking/FortaStaking/#inactivesharesof","title":"inactiveSharesOf","text":"<pre><code>function inactiveSharesOf(uint8 subjectType, uint256 subject, address account) external view returns (uint256)\n</code></pre> <p>Get inactive shares of an account on a subject, corresponding to a fraction of the subject inactive stake.</p> <p>This is equivalent to getting the ERC1155 balanceOf for keccak256(abi.encodePacked(subjectType, subject)), shifted 9 bits, with the 9th bit unset and uint8(subjectType) masked in.</p> Name Type Description subjectType uint8 type id of Stake Subject. See SubjectTypeValidator.sol subject uint256 id identifying subject (external to FortaStaking). account address holder of the ERC1155 staking shares. Name Type Description [0] uint256 amount of ERC1155 shares account is in possession in representing inactive stake on subject+subjectType, marked for withdrawal."},{"location":"contracts/components/staking/FortaStaking/#totalinactiveshares","title":"totalInactiveShares","text":"<pre><code>function totalInactiveShares(uint8 subjectType, uint256 subject) external view returns (uint256)\n</code></pre> <p>Get the total inactive shares on a subject.</p> <p>This is equivalent to getting the ERC1155 totalSupply for keccak256(abi.encodePacked(subjectType, subject)), shifted 9 bits, with the 9th bit unset and uint8(subjectType) masked in</p> Name Type Description subjectType uint8 type id of Stake Subject. See SubjectTypeValidator.sol subject uint256 id identifying subject (external to FortaStaking). Name Type Description [0] uint256 total ERC1155 shares representing inactive stake on subject+subjectType, marked for withdrawal."},{"location":"contracts/components/staking/FortaStaking/#isfrozen","title":"isFrozen","text":"<pre><code>function isFrozen(uint8 subjectType, uint256 subject) public view returns (bool)\n</code></pre> <p>Checks if a subject frozen (stake of frozen subject cannot be withdrawn).</p> Name Type Description subjectType uint8 type id of Stake Subject. See SubjectTypeValidator.sol subject uint256 id identifying subject (external to FortaStaking). Name Type Description [0] bool true if subject is frozen, false otherwise"},{"location":"contracts/components/staking/FortaStaking/#deposit","title":"deposit","text":"<pre><code>function deposit(uint8 subjectType, uint256 subject, uint256 stakeValue) external returns (uint256)\n</code></pre> <p>Deposit <code>stakeValue</code> tokens for a given <code>subject</code>, and mint the corresponding active ERC1155 shares. will return tokens staked over maximum for the subject. If stakeValue would drive the stake over the maximum, only stakeValue - excess is transferred, but transaction will not fail. Reverts if max stake for subjectType not set, or subject not found.</p> <p>NOTE: Subject type is necessary because we can't infer subject ID uniqueness between scanners, agents, etc Emits a ERC1155.TransferSingle event and StakeDeposited (to allow accounting per subject type) Emits MaxStakeReached(subjectType, activeSharesId) WARNING: To stake from another smart contract (smart contract wallets included), it must be fully ERC1155 compatible, implementing ERC1155Receiver. If not, minting of active and inactive shares will fail. Do not deposit on the constructor if you don't implement ERC1155Receiver. During the construction, the minting will succeed but you will not be able to withdraw or mint new shares from the contract. If this happens, transfer your shares to an EOA or fully ERC1155 compatible contract.</p> Name Type Description subjectType uint8 type id of Stake Subject. See SubjectTypeValidator.sol subject uint256 id identifying subject (external to FortaStaking). stakeValue uint256 amount of staked token. Name Type Description [0] uint256 amount of ERC1155 active shares minted."},{"location":"contracts/components/staking/FortaStaking/#migrate","title":"migrate","text":"<pre><code>function migrate(uint8 oldSubjectType, uint256 oldSubject, uint8 newSubjectType, uint256 newSubject, address staker) external\n</code></pre> <p>deposits active stake from SCANNER to SCANNER_POOL if not frozen. Inactive stake remains for withdrawal in old subject Burns active stake and shares for old subject.</p> <p>No slash has been executed, so new SCANNER_POOL share proportions apply.</p>"},{"location":"contracts/components/staking/FortaStaking/#_getinboundstake","title":"_getInboundStake","text":"<pre><code>function _getInboundStake(uint8 subjectType, uint256 subject, uint256 stakeValue) private view returns (uint256, bool)\n</code></pre> <p>Calculates how much of the incoming stake fits for subject.</p> Name Type Description subjectType uint8 valid subect type subject uint256 the id of the subject stakeValue uint256 stake sent by staker Name Type Description [0] uint256 stakeValue - excess [1] bool true if reached max"},{"location":"contracts/components/staking/FortaStaking/#initiatewithdrawal","title":"initiateWithdrawal","text":"<pre><code>function initiateWithdrawal(uint8 subjectType, uint256 subject, uint256 sharesValue) external returns (uint64)\n</code></pre> <p>Starts the withdrawal process for an amount of shares. Burns active shares and mints inactive shares (non transferrable). Stake will be available for withdraw() after _withdrawalDelay. If the subject has not been slashed, the shares will correspond 1:1 with stake.</p> <p>Emits a WithdrawalInitiated event.</p> Name Type Description subjectType uint8 type id of Stake Subject. See SubjectTypeValidator.sol subject uint256 id identifying subject (external to FortaStaking). sharesValue uint256 amount of shares token. Name Type Description [0] uint64 amount of time until withdrawal is valid."},{"location":"contracts/components/staking/FortaStaking/#withdraw","title":"withdraw","text":"<pre><code>function withdraw(uint8 subjectType, uint256 subject) external returns (uint256)\n</code></pre> <p>Burn <code>sharesValue</code> inactive shares for a given <code>subject</code>, and withdraw the corresponding tokens (if the subject type has not been frozen, and the withdrawal delay time has passed).</p> <p>shares must have been marked for withdrawal before by initiateWithdrawal(). Emits events WithdrawalExecuted and ERC1155.TransferSingle.</p> Name Type Description subjectType uint8 type id of Stake Subject. See SubjectTypeValidator.sol subject uint256 id identifying subject (external to FortaStaking). Name Type Description [0] uint256 amount of withdrawn staked tokens."},{"location":"contracts/components/staking/FortaStaking/#slash","title":"slash","text":"<pre><code>function slash(uint8 subjectType, uint256 subject, uint256 stakeValue, address proposer, uint256 proposerPercent) external returns (uint256)\n</code></pre> <p>Slash a fraction of a subject stake, and transfer it to the treasury. Restricted to the <code>SLASHER_ROLE</code>.</p> <p>This will alter the relationship between shares and stake, reducing shares value for a subject. Emits a Slashed event. Unallocated stake if needed. A slash over a DELEGATED type will propagate to DELEGATORs according to proposerPercent.</p> Name Type Description subjectType uint8 type id of Stake Subject. See SubjectTypeValidator.sol subject uint256 id identifying subject (external to FortaStaking). stakeValue uint256 amount of staked token to be slashed. proposer address address of the slash proposer. Must be nonzero address if proposerPercent &gt; 0 proposerPercent uint256 percentage of stakeValue sent to the proposer. From 0 to MAX_SLASHABLE_PERCENT Name Type Description [0] uint256 stakeValue"},{"location":"contracts/components/staking/FortaStaking/#_slash","title":"_slash","text":"<pre><code>function _slash(uint256 activeSharesId, uint8 subjectType, uint256 subject, uint256 stakeValue) private\n</code></pre> <p>burns slashed stake from active and/or inactive stake for subjectType/subject.</p> Name Type Description activeSharesId uint256 ERC1155 id of the shares being slashed subjectType uint8 type id of Stake Subject. See SubjectTypeValidator.sol subject uint256 id identifying subject (external to FortaStaking). stakeValue uint256 amount of staked token to be slashed."},{"location":"contracts/components/staking/FortaStaking/#freeze","title":"freeze","text":"<pre><code>function freeze(uint8 subjectType, uint256 subject, bool frozen) external\n</code></pre> <p>Freeze/unfreeze withdrawal of a subject stake. This will be used when something suspicious happens with a subject but there is not a strong case yet for slashing. Restricted to the <code>SLASHER_ROLE</code>.</p> <p>Emits a Freeze event.</p> Name Type Description subjectType uint8 type id of Stake Subject. See SubjectTypeValidator.sol subject uint256 id identifying subject (external to FortaStaking). frozen bool true to freeze, false to unfreeze."},{"location":"contracts/components/staking/FortaStaking/#_migratefrozentoopenproposals","title":"_migrateFrozenToOpenProposals","text":"<pre><code>function _migrateFrozenToOpenProposals(uint256 activeSharesId) private\n</code></pre> <p>If there is open cases before upgrading to openProposals (frozen == true), we increment as an extra proposal and set to false. There could be more than 1 open, in that case SLASHING_ARBITER_ROLE should be cautious with not unfreezing. This method will be obsolete when all the _deprecated_frozen are false</p> Name Type Description activeSharesId uint256 of the subject"},{"location":"contracts/components/staking/FortaStaking/#sweep","title":"sweep","text":"<pre><code>function sweep(contract IERC20 token, address recipient) external returns (uint256)\n</code></pre> <p>Sweep all token that might be mistakenly sent to the contract. This covers both unrelated tokens and staked tokens that would be sent through a direct transfer. Restricted to SWEEPER_ROLE. If tokens are the same as staked tokens, only the extra tokens (no stake) will be transferred.</p> <p>WARNING: thoroughly review the token to sweep.</p> Name Type Description token contract IERC20 address of the token to be swept. recipient address destination address of the swept tokens Name Type Description [0] uint256 amount of tokens swept. For unrelated tokens is FortaStaking's balance, for stakedToken its the balance over the active stake + inactive stake"},{"location":"contracts/components/staking/FortaStaking/#relaypermit","title":"relayPermit","text":"<pre><code>function relayPermit(uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external\n</code></pre> <p>Relay a ERC2612 permit signature to the staked token. This cal be bundled with a {deposit} or a {reward} operation using Multicall.</p> Name Type Description value uint256 amount of token allowance for deposit/reward deadline uint256 for the meta-tx to be relayed. v uint8 part of signature r bytes32 part of signature s bytes32 part of signature"},{"location":"contracts/components/staking/FortaStaking/#_beforetokentransfer","title":"_beforeTokenTransfer","text":"<pre><code>function _beforeTokenTransfer(address operator, address from, address to, uint256[] ids, uint256[] amounts, bytes data) internal virtual\n</code></pre> <p>See {ERC1155-_beforeTokenTransfer}.</p>"},{"location":"contracts/components/staking/FortaStaking/#staketoactiveshares","title":"stakeToActiveShares","text":"<pre><code>function stakeToActiveShares(uint256 activeSharesId, uint256 amount) public view returns (uint256)\n</code></pre> <p>Convert active token stake amount to active shares amount</p> Name Type Description activeSharesId uint256 ERC1155 active shares id amount uint256 active stake amount Name Type Description [0] uint256 ERC1155 active shares amount"},{"location":"contracts/components/staking/FortaStaking/#staketoinactiveshares","title":"stakeToInactiveShares","text":"<pre><code>function stakeToInactiveShares(uint256 inactiveSharesId, uint256 amount) public view returns (uint256)\n</code></pre> <p>Convert inactive token stake amount to inactive shares amount</p> Name Type Description inactiveSharesId uint256 ERC1155 inactive shares id amount uint256 inactive stake amount Name Type Description [0] uint256 ERC1155 inactive shares amount"},{"location":"contracts/components/staking/FortaStaking/#activesharestostake","title":"activeSharesToStake","text":"<pre><code>function activeSharesToStake(uint256 activeSharesId, uint256 amount) public view returns (uint256)\n</code></pre> <p>Convert active shares amount to active stake amount.</p> Name Type Description activeSharesId uint256 ERC1155 active shares id amount uint256 ERC1155 active shares amount Name Type Description [0] uint256 active stake amount"},{"location":"contracts/components/staking/FortaStaking/#inactivesharestostake","title":"inactiveSharesToStake","text":"<pre><code>function inactiveSharesToStake(uint256 inactiveSharesId, uint256 amount) public view returns (uint256)\n</code></pre> <p>Convert inactive shares amount to inactive stake amount.</p> Name Type Description inactiveSharesId uint256 ERC1155 inactive shares id amount uint256 ERC1155 inactive shares amount Name Type Description [0] uint256 inactive stake amount"},{"location":"contracts/components/staking/FortaStaking/#setdelay","title":"setDelay","text":"<pre><code>function setDelay(uint64 newDelay) external\n</code></pre> <p>Sets withdrawal delay. Restricted to DEFAULT_ADMIN_ROLE</p> Name Type Description newDelay uint64 in seconds."},{"location":"contracts/components/staking/FortaStaking/#settreasury","title":"setTreasury","text":"<pre><code>function setTreasury(address newTreasury) external\n</code></pre> <p>Sets destination of slashed tokens. Restricted to DEFAULT_ADMIN_ROLE</p> Name Type Description newTreasury address address."},{"location":"contracts/components/staking/FortaStaking/#configurestakehelpers","title":"configureStakeHelpers","text":"<pre><code>function configureStakeHelpers(contract IStakeSubjectGateway _subjectGateway, contract IStakeAllocator _allocator) external\n</code></pre>"},{"location":"contracts/components/staking/FortaStaking/#setslashdelegatorspercent","title":"setSlashDelegatorsPercent","text":"<pre><code>function setSlashDelegatorsPercent(uint256 percent) external\n</code></pre>"},{"location":"contracts/components/staking/FortaStaking/#seturi","title":"setURI","text":"<pre><code>function setURI(string newUri) external\n</code></pre> <p>Sets URI of the ERC1155 tokens. Restricted to DEFAULT_ADMIN_ROLE</p> Name Type Description newUri string root of the hosted metadata."},{"location":"contracts/components/staking/FortaStaking/#_msgsender","title":"_msgSender","text":"<pre><code>function _msgSender() internal view virtual returns (address sender)\n</code></pre> <p>Helper to get either msg msg.sender if not a meta transaction, signer of forwarder metatx if it is.</p>"},{"location":"contracts/components/staking/FortaStaking/#_msgdata","title":"_msgData","text":"<pre><code>function _msgData() internal view virtual returns (bytes)\n</code></pre> <p>Helper to get msg.data if not a meta transaction, forwarder data in metatx if it is.</p>"},{"location":"contracts/components/staking/FortaStaking/#__gap","title":"__gap","text":"<pre><code>uint256[36] __gap\n</code></pre>"},{"location":"contracts/components/staking/FortaStakingUtils/","title":"Forta Staking Utils","text":""},{"location":"contracts/components/staking/FortaStakingUtils/#fortastakingutils","title":"FortaStakingUtils","text":""},{"location":"contracts/components/staking/FortaStakingUtils/#subjecttoactive","title":"subjectToActive","text":"<pre><code>function subjectToActive(uint8 subjectType, uint256 subject) internal pure returns (uint256)\n</code></pre> <p>Encode \"active\" and subjectType in subject by hashing them together, shifting left 9 bits, setting bit 9 (to mark as active) and masking subjectType in</p> Name Type Description subjectType uint8 agents, scanner or future types of stake subject. See SubjectTypeValidator.sol subject uint256 id identifying subject (external to FortaStaking). Name Type Description [0] uint256 ERC1155 token id representing active shares."},{"location":"contracts/components/staking/FortaStakingUtils/#subjecttoinactive","title":"subjectToInactive","text":"<pre><code>function subjectToInactive(uint8 subjectType, uint256 subject) internal pure returns (uint256)\n</code></pre> <p>Encode \"inactive\" and subjectType in subject by hashing them together, shifting left 9 bits, letting bit 9 unset (to mark as inactive) and masking subjectType in.</p> Name Type Description subjectType uint8 agents, scanner or future types of stake subject. See SubjectTypeValidator.sol subject uint256 id identifying subject (external to FortaStaking). Name Type Description [0] uint256 ERC1155 token id representing inactive shares."},{"location":"contracts/components/staking/FortaStakingUtils/#activetoinactive","title":"activeToInactive","text":"<pre><code>function activeToInactive(uint256 activeSharesId) internal pure returns (uint256)\n</code></pre> <p>Unsets bit 9 of an activeSharesId to mark as inactive</p> Name Type Description activeSharesId uint256 ERC1155 token id representing active shares. Name Type Description [0] uint256 ERC1155 token id representing inactive shares."},{"location":"contracts/components/staking/FortaStakingUtils/#inactivetoactive","title":"inactiveToActive","text":"<pre><code>function inactiveToActive(uint256 inactiveSharesId) internal pure returns (uint256)\n</code></pre> <p>Sets bit 9 of an inactiveSharesId to mark as inactive</p> Name Type Description inactiveSharesId uint256 ERC1155 token id representing inactive shares. Name Type Description [0] uint256 ERC1155 token id representing active shares."},{"location":"contracts/components/staking/FortaStakingUtils/#isactive","title":"isActive","text":"<pre><code>function isActive(uint256 sharesId) internal pure returns (bool)\n</code></pre> <p>Checks if shares id is active</p> Name Type Description sharesId uint256 ERC1155 token id representing shares. Name Type Description [0] bool true if active shares, false if inactive"},{"location":"contracts/components/staking/FortaStakingUtils/#subjecttypeofshares","title":"subjectTypeOfShares","text":"<pre><code>function subjectTypeOfShares(uint256 sharesId) internal pure returns (uint8)\n</code></pre> <p>Extracts subject type encoded in shares id</p> Name Type Description sharesId uint256 ERC1155 token id representing shares. Name Type Description [0] uint8 subject type (see SubjectTypeValidator.sol)"},{"location":"contracts/components/staking/IDelegatedStakeSubject/","title":"IDelegatedStakeSubject","text":""},{"location":"contracts/components/staking/IDelegatedStakeSubject/#idelegatedstakesubject","title":"IDelegatedStakeSubject","text":""},{"location":"contracts/components/staking/IDelegatedStakeSubject/#gettotalmanagedsubjects","title":"getTotalManagedSubjects","text":"<pre><code>function getTotalManagedSubjects(uint256 managerId) external view returns (uint256)\n</code></pre>"},{"location":"contracts/components/staking/IDelegatedStakeSubject/#getmanagedstakethreshold","title":"getManagedStakeThreshold","text":"<pre><code>function getManagedStakeThreshold(uint256 managedId) external view returns (struct IStakeSubject.StakeThreshold)\n</code></pre>"},{"location":"contracts/components/staking/IDirectStakeSubject/","title":"IDirectStakeSubject","text":""},{"location":"contracts/components/staking/IDirectStakeSubject/#idirectstakesubject","title":"IDirectStakeSubject","text":""},{"location":"contracts/components/staking/IDirectStakeSubject/#getstakethreshold","title":"getStakeThreshold","text":"<pre><code>function getStakeThreshold(uint256 subject) external view returns (struct IStakeSubject.StakeThreshold)\n</code></pre>"},{"location":"contracts/components/staking/IDirectStakeSubject/#isstakedovermin","title":"isStakedOverMin","text":"<pre><code>function isStakedOverMin(uint256 subject) external view returns (bool)\n</code></pre>"},{"location":"contracts/components/staking/IRewardsDistributor/","title":"IRewardsDistributor","text":""},{"location":"contracts/components/staking/IRewardsDistributor/#irewardsdistributor","title":"IRewardsDistributor","text":""},{"location":"contracts/components/staking/IRewardsDistributor/#didallocate","title":"didAllocate","text":"<pre><code>function didAllocate(uint8 subjectType, uint256 subject, uint256 stakeAmount, uint256 sharesAmount, address staker) external\n</code></pre>"},{"location":"contracts/components/staking/IRewardsDistributor/#didunallocate","title":"didUnallocate","text":"<pre><code>function didUnallocate(uint8 subjectType, uint256 subject, uint256 stakeAmount, uint256 sharesAmount, address staker) external\n</code></pre>"},{"location":"contracts/components/staking/IRewardsDistributor/#didtransfershares","title":"didTransferShares","text":"<pre><code>function didTransferShares(uint256 sharesId, uint8 subjectType, address from, address to, uint256 sharesAmount) external\n</code></pre>"},{"location":"contracts/components/staking/IRewardsDistributor/#irewardsdistributor_1","title":"IRewardsDistributor","text":""},{"location":"contracts/components/staking/IRewardsDistributor/#didallocate_1","title":"didAllocate","text":"<pre><code>function didAllocate(uint8 subjectType, uint256 subject, uint256 stakeAmount, uint256 sharesAmount, address staker) external\n</code></pre>"},{"location":"contracts/components/staking/IRewardsDistributor/#didunallocate_1","title":"didUnallocate","text":"<pre><code>function didUnallocate(uint8 subjectType, uint256 subject, uint256 stakeAmount, uint256 sharesAmount, address staker) external\n</code></pre>"},{"location":"contracts/components/staking/IRewardsDistributor/#didtransfershares_1","title":"didTransferShares","text":"<pre><code>function didTransferShares(uint256 sharesId, uint8 subjectType, address from, address to, uint256 sharesAmount) external\n</code></pre>"},{"location":"contracts/components/staking/IRewardsReceiver/","title":"IRewardsReceiver","text":""},{"location":"contracts/components/staking/IRewardsReceiver/#irewardreceiver","title":"IRewardReceiver","text":""},{"location":"contracts/components/staking/IRewardsReceiver/#onrewardreceived","title":"onRewardReceived","text":"<pre><code>function onRewardReceived(uint8 subjectType, uint256 subject, uint256 amount) external\n</code></pre>"},{"location":"contracts/components/staking/ISlashingExecutor/","title":"ISlashingExecutor","text":""},{"location":"contracts/components/staking/ISlashingExecutor/#islashingexecutor","title":"ISlashingExecutor","text":""},{"location":"contracts/components/staking/ISlashingExecutor/#freeze","title":"freeze","text":"<pre><code>function freeze(uint8 subjectType, uint256 subject, bool frozen) external\n</code></pre>"},{"location":"contracts/components/staking/ISlashingExecutor/#slash","title":"slash","text":"<pre><code>function slash(uint8 subjectType, uint256 subject, uint256 stakeValue, address proposer, uint256 proposerPercent) external returns (uint256)\n</code></pre>"},{"location":"contracts/components/staking/ISlashingExecutor/#treasury","title":"treasury","text":"<pre><code>function treasury() external view returns (address)\n</code></pre>"},{"location":"contracts/components/staking/ISlashingExecutor/#max_slashable_percent","title":"MAX_SLASHABLE_PERCENT","text":"<pre><code>function MAX_SLASHABLE_PERCENT() external view returns (uint256)\n</code></pre>"},{"location":"contracts/components/staking/IStakeAllocator/","title":"IStakeAllocator","text":""},{"location":"contracts/components/staking/IStakeAllocator/#istakeallocator","title":"IStakeAllocator","text":""},{"location":"contracts/components/staking/IStakeAllocator/#depositallocation","title":"depositAllocation","text":"<pre><code>function depositAllocation(uint256 activeSharesId, uint8 subjectType, uint256 subject, address allocator, uint256 stakeAmount, uint256 sharesAmount) external\n</code></pre>"},{"location":"contracts/components/staking/IStakeAllocator/#withdrawallocation","title":"withdrawAllocation","text":"<pre><code>function withdrawAllocation(uint256 activeSharesId, uint8 subjectType, uint256 subject, address allocator, uint256 stakeAmount, uint256 sharesAmount) external\n</code></pre>"},{"location":"contracts/components/staking/IStakeAllocator/#allocatedstakefor","title":"allocatedStakeFor","text":"<pre><code>function allocatedStakeFor(uint8 subjectType, uint256 subject) external view returns (uint256)\n</code></pre>"},{"location":"contracts/components/staking/IStakeAllocator/#allocatedmanagedstake","title":"allocatedManagedStake","text":"<pre><code>function allocatedManagedStake(uint8 subjectType, uint256 subject) external view returns (uint256)\n</code></pre>"},{"location":"contracts/components/staking/IStakeAllocator/#allocatedstakepermanaged","title":"allocatedStakePerManaged","text":"<pre><code>function allocatedStakePerManaged(uint8 subjectType, uint256 subject) external view returns (uint256)\n</code></pre>"},{"location":"contracts/components/staking/IStakeAllocator/#unallocatedstakefor","title":"unallocatedStakeFor","text":"<pre><code>function unallocatedStakeFor(uint8 subjectType, uint256 subject) external view returns (uint256)\n</code></pre>"},{"location":"contracts/components/staking/IStakeAllocator/#allocateownstake","title":"allocateOwnStake","text":"<pre><code>function allocateOwnStake(uint8 subjectType, uint256 subject, uint256 amount) external\n</code></pre>"},{"location":"contracts/components/staking/IStakeAllocator/#unallocateownstake","title":"unallocateOwnStake","text":"<pre><code>function unallocateOwnStake(uint8 subjectType, uint256 subject, uint256 amount) external\n</code></pre>"},{"location":"contracts/components/staking/IStakeAllocator/#unallocatedelegatorstake","title":"unallocateDelegatorStake","text":"<pre><code>function unallocateDelegatorStake(uint8 subjectType, uint256 subject, uint256 amount) external\n</code></pre>"},{"location":"contracts/components/staking/IStakeAllocator/#didtransfershares","title":"didTransferShares","text":"<pre><code>function didTransferShares(uint256 sharesId, uint8 subjectType, address from, address to, uint256 sharesAmount) external\n</code></pre>"},{"location":"contracts/components/staking/IStakeAllocator/#istakeallocator_1","title":"IStakeAllocator","text":""},{"location":"contracts/components/staking/IStakeAllocator/#depositallocation_1","title":"depositAllocation","text":"<pre><code>function depositAllocation(uint256 activeSharesId, uint8 subjectType, uint256 subject, address allocator, uint256 stakeAmount, uint256 sharesAmount) external\n</code></pre>"},{"location":"contracts/components/staking/IStakeAllocator/#withdrawallocation_1","title":"withdrawAllocation","text":"<pre><code>function withdrawAllocation(uint256 activeSharesId, uint8 subjectType, uint256 subject, address allocator, uint256 stakeAmount, uint256 sharesAmount) external\n</code></pre>"},{"location":"contracts/components/staking/IStakeAllocator/#allocatedstakefor_1","title":"allocatedStakeFor","text":"<pre><code>function allocatedStakeFor(uint8 subjectType, uint256 subject) external view returns (uint256)\n</code></pre>"},{"location":"contracts/components/staking/IStakeAllocator/#allocatedstakepermanaged_1","title":"allocatedStakePerManaged","text":"<pre><code>function allocatedStakePerManaged(uint8 subjectType, uint256 subject) external view returns (uint256)\n</code></pre>"},{"location":"contracts/components/staking/IStakeAllocator/#unallocatedstakefor_1","title":"unallocatedStakeFor","text":"<pre><code>function unallocatedStakeFor(uint8 subjectType, uint256 subject) external view returns (uint256)\n</code></pre>"},{"location":"contracts/components/staking/IStakeAllocator/#allocateownstake_1","title":"allocateOwnStake","text":"<pre><code>function allocateOwnStake(uint8 subjectType, uint256 subject, uint256 amount) external\n</code></pre>"},{"location":"contracts/components/staking/IStakeAllocator/#didtransfershares_1","title":"didTransferShares","text":"<pre><code>function didTransferShares(uint256 sharesId, uint8 subjectType, address from, address to, uint256 sharesAmount) external\n</code></pre>"},{"location":"contracts/components/staking/IStakeMigrator/","title":"IStakeMigrator","text":""},{"location":"contracts/components/staking/IStakeMigrator/#istakemigrator","title":"IStakeMigrator","text":""},{"location":"contracts/components/staking/IStakeMigrator/#migrate","title":"migrate","text":"<pre><code>function migrate(uint8 oldSubjectType, uint256 oldSubject, uint8 newSubjectType, uint256 newSubject, address staker) external\n</code></pre>"},{"location":"contracts/components/staking/IStakeSubject/","title":"IStakeSubject","text":""},{"location":"contracts/components/staking/IStakeSubject/#istakesubject","title":"IStakeSubject","text":""},{"location":"contracts/components/staking/IStakeSubject/#stakethreshold","title":"StakeThreshold","text":"<pre><code>struct StakeThreshold {\n  uint256 min;\n  uint256 max;\n  bool activated;\n}\n</code></pre>"},{"location":"contracts/components/staking/IStakeSubject/#stakethresholdmaxlessorequalmin","title":"StakeThresholdMaxLessOrEqualMin","text":"<pre><code>error StakeThresholdMaxLessOrEqualMin()\n</code></pre>"},{"location":"contracts/components/staking/IStakeSubject/#isregistered","title":"isRegistered","text":"<pre><code>function isRegistered(uint256 subject) external view returns (bool)\n</code></pre>"},{"location":"contracts/components/staking/IStakeSubject/#ownerof","title":"ownerOf","text":"<pre><code>function ownerOf(uint256 subject) external view returns (address)\n</code></pre>"},{"location":"contracts/components/staking/IStakeSubjectGateway/","title":"IStakeSubjectGateway","text":""},{"location":"contracts/components/staking/IStakeSubjectGateway/#istakesubjectgateway","title":"IStakeSubjectGateway","text":""},{"location":"contracts/components/staking/IStakeSubjectGateway/#stakesubjectchanged","title":"StakeSubjectChanged","text":"<pre><code>event StakeSubjectChanged(address newHandler, address oldHandler)\n</code></pre>"},{"location":"contracts/components/staking/IStakeSubjectGateway/#setstakesubject","title":"setStakeSubject","text":"<pre><code>function setStakeSubject(uint8 subjectType, address subject) external\n</code></pre>"},{"location":"contracts/components/staking/IStakeSubjectGateway/#getstakesubject","title":"getStakeSubject","text":"<pre><code>function getStakeSubject(uint8 subjectType) external view returns (address)\n</code></pre>"},{"location":"contracts/components/staking/IStakeSubjectGateway/#activestakefor","title":"activeStakeFor","text":"<pre><code>function activeStakeFor(uint8 subjectType, uint256 subject) external view returns (uint256)\n</code></pre>"},{"location":"contracts/components/staking/IStakeSubjectGateway/#maxstakefor","title":"maxStakeFor","text":"<pre><code>function maxStakeFor(uint8 subjectType, uint256 subject) external view returns (uint256)\n</code></pre>"},{"location":"contracts/components/staking/IStakeSubjectGateway/#minstakefor","title":"minStakeFor","text":"<pre><code>function minStakeFor(uint8 subjectType, uint256 subject) external view returns (uint256)\n</code></pre>"},{"location":"contracts/components/staking/IStakeSubjectGateway/#totalstakefor","title":"totalStakeFor","text":"<pre><code>function totalStakeFor(uint8 subjectType, uint256 subject) external view returns (uint256)\n</code></pre>"},{"location":"contracts/components/staking/IStakeSubjectGateway/#isstakeactivatedfor","title":"isStakeActivatedFor","text":"<pre><code>function isStakeActivatedFor(uint8 subjectType, uint256 subject) external view returns (bool)\n</code></pre>"},{"location":"contracts/components/staking/IStakeSubjectGateway/#maxmanagedstakefor","title":"maxManagedStakeFor","text":"<pre><code>function maxManagedStakeFor(uint8 subjectType, uint256 subject) external view returns (uint256)\n</code></pre>"},{"location":"contracts/components/staking/IStakeSubjectGateway/#minmanagedstakefor","title":"minManagedStakeFor","text":"<pre><code>function minManagedStakeFor(uint8 subjectType, uint256 subject) external view returns (uint256)\n</code></pre>"},{"location":"contracts/components/staking/IStakeSubjectGateway/#totalmanagedsubjects","title":"totalManagedSubjects","text":"<pre><code>function totalManagedSubjects(uint8 subjectType, uint256 subject) external view returns (uint256)\n</code></pre>"},{"location":"contracts/components/staking/IStakeSubjectGateway/#canmanageallocation","title":"canManageAllocation","text":"<pre><code>function canManageAllocation(uint8 subjectType, uint256 subject, address allocator) external view returns (bool)\n</code></pre>"},{"location":"contracts/components/staking/IStakeSubjectGateway/#ownerof","title":"ownerOf","text":"<pre><code>function ownerOf(uint8 subjectType, uint256 subject) external view returns (address)\n</code></pre>"},{"location":"contracts/components/staking/RewardsDistributor/","title":"Rewards Distributor","text":""},{"location":"contracts/components/staking/RewardsDistributor/#rewardsdistributor","title":"RewardsDistributor","text":""},{"location":"contracts/components/staking/RewardsDistributor/#version","title":"version","text":"<pre><code>string version\n</code></pre>"},{"location":"contracts/components/staking/RewardsDistributor/#didaccumulaterate","title":"DidAccumulateRate","text":"<pre><code>event DidAccumulateRate(uint8 subjectType, uint256 subject, address staker, uint256 stakeAmount, uint256 sharesAmount)\n</code></pre>"},{"location":"contracts/components/staking/RewardsDistributor/#didreducerate","title":"DidReduceRate","text":"<pre><code>event DidReduceRate(uint8 subjectType, uint256 subject, address staker, uint256 stakeAmount, uint256 sharesAmount)\n</code></pre>"},{"location":"contracts/components/staking/RewardsDistributor/#rewarded","title":"Rewarded","text":"<pre><code>event Rewarded(uint8 subjectType, uint256 subject, uint256 amount, uint256 epochNumber)\n</code></pre>"},{"location":"contracts/components/staking/RewardsDistributor/#claimedrewards","title":"ClaimedRewards","text":"<pre><code>event ClaimedRewards(uint8 subjectType, uint256 subject, address to, uint256 epochNumber, uint256 value)\n</code></pre>"},{"location":"contracts/components/staking/RewardsDistributor/#didtransferrewardshares","title":"DidTransferRewardShares","text":"<pre><code>event DidTransferRewardShares(uint256 sharesId, uint8 subjectType, address from, address to, uint256 sharesAmount)\n</code></pre>"},{"location":"contracts/components/staking/RewardsDistributor/#setdelegationfee","title":"SetDelegationFee","text":"<pre><code>event SetDelegationFee(uint8 subjectType, uint256 subject, uint256 epochNumber, uint256 feeBps)\n</code></pre>"},{"location":"contracts/components/staking/RewardsDistributor/#setdelegationparams","title":"SetDelegationParams","text":"<pre><code>event SetDelegationParams(uint256 epochDelay, uint256 defaultFeeBps)\n</code></pre>"},{"location":"contracts/components/staking/RewardsDistributor/#tokensswept","title":"TokensSwept","text":"<pre><code>event TokensSwept(address token, address to, uint256 amount)\n</code></pre>"},{"location":"contracts/components/staking/RewardsDistributor/#rewardingnonregisteredsubject","title":"RewardingNonRegisteredSubject","text":"<pre><code>error RewardingNonRegisteredSubject(uint8 subjectType, uint256 subject)\n</code></pre>"},{"location":"contracts/components/staking/RewardsDistributor/#alreadyclaimed","title":"AlreadyClaimed","text":"<pre><code>error AlreadyClaimed()\n</code></pre>"},{"location":"contracts/components/staking/RewardsDistributor/#alreadyrewarded","title":"AlreadyRewarded","text":"<pre><code>error AlreadyRewarded(uint256 epochNumber)\n</code></pre>"},{"location":"contracts/components/staking/RewardsDistributor/#setdelegationfeenotready","title":"SetDelegationFeeNotReady","text":"<pre><code>error SetDelegationFeeNotReady()\n</code></pre>"},{"location":"contracts/components/staking/RewardsDistributor/#constructor","title":"constructor","text":"<pre><code>constructor(address _forwarder, address _rewardsToken, address __subjectGateway) public\n</code></pre>"},{"location":"contracts/components/staking/RewardsDistributor/#initialize","title":"initialize","text":"<pre><code>function initialize(address _manager, uint256 _delegationParamsEpochDelay, uint256 _defaultFeeBps) public\n</code></pre>"},{"location":"contracts/components/staking/RewardsDistributor/#didallocate","title":"didAllocate","text":"<pre><code>function didAllocate(uint8 subjectType, uint256 subject, uint256 stakeAmount, uint256 sharesAmount, address staker) external\n</code></pre>"},{"location":"contracts/components/staking/RewardsDistributor/#didunallocate","title":"didUnallocate","text":"<pre><code>function didUnallocate(uint8 subjectType, uint256 subject, uint256 stakeAmount, uint256 sharesAmount, address staker) external\n</code></pre>"},{"location":"contracts/components/staking/RewardsDistributor/#didtransfershares","title":"didTransferShares","text":"<pre><code>function didTransferShares(uint256 sharesId, uint8 subjectType, address from, address to, uint256 sharesAmount) external\n</code></pre>"},{"location":"contracts/components/staking/RewardsDistributor/#reward","title":"reward","text":"<pre><code>function reward(uint8 subjectType, uint256 subjectId, uint256 amount, uint256 epochNumber) external\n</code></pre>"},{"location":"contracts/components/staking/RewardsDistributor/#availablereward","title":"availableReward","text":"<pre><code>function availableReward(uint8 subjectType, uint256 subjectId, uint256 epochNumber, address staker) public view returns (uint256)\n</code></pre>"},{"location":"contracts/components/staking/RewardsDistributor/#claimrewards","title":"claimRewards","text":"<pre><code>function claimRewards(uint8 subjectType, uint256 subjectId, uint256[] epochNumbers) external\n</code></pre>"},{"location":"contracts/components/staking/RewardsDistributor/#setdelegationparams_1","title":"setDelegationParams","text":"<pre><code>function setDelegationParams(uint256 _delegationParamsEpochDelay, uint256 _defaultFeeBps) external\n</code></pre>"},{"location":"contracts/components/staking/RewardsDistributor/#setdelegationfeebps","title":"setDelegationFeeBps","text":"<pre><code>function setDelegationFeeBps(uint8 subjectType, uint256 subjectId, uint16 feeBps) external\n</code></pre> <p>Sets delegation fee for a ScannerPool (required to own the ScannerPoolRegistry NFT). Change in fees will start having an effect in the beginning of the next reward epoch. After the first time setting the parameter, it cannot be set again until delegationParamsEpochDelay epochs pass.</p> Name Type Description subjectType uint8 a DELEGATED subject type. subjectId uint256 the DELEGATED subject id. feeBps uint16"},{"location":"contracts/components/staking/RewardsDistributor/#getdelegationfee","title":"getDelegationFee","text":"<pre><code>function getDelegationFee(uint8 subjectType, uint256 subjectId, uint256 epochNumber) public view returns (uint256)\n</code></pre> <p>Returns current delegation fee for an epoch or defaultFeeBps if not set</p>"},{"location":"contracts/components/staking/RewardsDistributor/#sweep","title":"sweep","text":"<pre><code>function sweep(contract IERC20 token, address recipient) external returns (uint256)\n</code></pre> <p>Sweep all token that might be mistakenly sent to the contract. This covers both unrelated tokens and staked tokens that would be sent through a direct transfer. Restricted to SWEEPER_ROLE. If tokens are the same as staked tokens, only the extra tokens (no rewards) will be transferred.</p> <p>WARNING: thoroughly review the token to sweep.</p> Name Type Description token contract IERC20 address of the token to be swept. recipient address destination address of the swept tokens Name Type Description [0] uint256 amount of tokens swept. For unrelated tokens is RewardDistributor's balance, for stakedToken its the balance minus total rewards distributed;"},{"location":"contracts/components/staking/RewardsDistributor/#getepochnumber","title":"getEpochNumber","text":"<pre><code>function getEpochNumber(uint256 timestamp) external pure returns (uint32)\n</code></pre>"},{"location":"contracts/components/staking/RewardsDistributor/#getcurrentepochnumber","title":"getCurrentEpochNumber","text":"<pre><code>function getCurrentEpochNumber() external view returns (uint32)\n</code></pre>"},{"location":"contracts/components/staking/RewardsDistributor/#getepochstarttimestamp","title":"getEpochStartTimestamp","text":"<pre><code>function getEpochStartTimestamp(uint256 epochNumber) external pure returns (uint256)\n</code></pre>"},{"location":"contracts/components/staking/RewardsDistributor/#getcurrentepochstarttimestamp","title":"getCurrentEpochStartTimestamp","text":"<pre><code>function getCurrentEpochStartTimestamp() external view returns (uint256)\n</code></pre>"},{"location":"contracts/components/staking/RewardsDistributor/#getepochendtimestamp","title":"getEpochEndTimestamp","text":"<pre><code>function getEpochEndTimestamp(uint256 epochNumber) external pure returns (uint256)\n</code></pre>"},{"location":"contracts/components/staking/RewardsDistributor/#getcurrentepochendtimestamp","title":"getCurrentEpochEndTimestamp","text":"<pre><code>function getCurrentEpochEndTimestamp() external view returns (uint256)\n</code></pre>"},{"location":"contracts/components/staking/RewardsDistributor/#iscurrentepoch","title":"isCurrentEpoch","text":"<pre><code>function isCurrentEpoch(uint256 timestamp) external view returns (bool)\n</code></pre>"},{"location":"contracts/components/staking/SlashReasons/","title":"Slash Reasons","text":""},{"location":"contracts/components/staking/SlashReasons/#operational_slash","title":"OPERATIONAL_SLASH","text":"<pre><code>bytes32 OPERATIONAL_SLASH\n</code></pre>"},{"location":"contracts/components/staking/SlashReasons/#misconduct_slash","title":"MISCONDUCT_SLASH","text":"<pre><code>bytes32 MISCONDUCT_SLASH\n</code></pre>"},{"location":"contracts/components/staking/SlashingController/","title":"Slashing Controller","text":""},{"location":"contracts/components/staking/SlashingController/#slashingcontroller","title":"SlashingController","text":""},{"location":"contracts/components/staking/SlashingController/#undefined","title":"UNDEFINED","text":"<pre><code>enum StateMachines.State UNDEFINED\n</code></pre>"},{"location":"contracts/components/staking/SlashingController/#created","title":"CREATED","text":"<pre><code>enum StateMachines.State CREATED\n</code></pre>"},{"location":"contracts/components/staking/SlashingController/#rejected","title":"REJECTED","text":"<pre><code>enum StateMachines.State REJECTED\n</code></pre>"},{"location":"contracts/components/staking/SlashingController/#dismissed","title":"DISMISSED","text":"<pre><code>enum StateMachines.State DISMISSED\n</code></pre>"},{"location":"contracts/components/staking/SlashingController/#in_review","title":"IN_REVIEW","text":"<pre><code>enum StateMachines.State IN_REVIEW\n</code></pre>"},{"location":"contracts/components/staking/SlashingController/#reviewed","title":"REVIEWED","text":"<pre><code>enum StateMachines.State REVIEWED\n</code></pre>"},{"location":"contracts/components/staking/SlashingController/#executed","title":"EXECUTED","text":"<pre><code>enum StateMachines.State EXECUTED\n</code></pre>"},{"location":"contracts/components/staking/SlashingController/#reverted","title":"REVERTED","text":"<pre><code>enum StateMachines.State REVERTED\n</code></pre>"},{"location":"contracts/components/staking/SlashingController/#penaltymode","title":"PenaltyMode","text":"<pre><code>enum PenaltyMode {\n  UNDEFINED,\n  MIN_STAKE,\n  CURRENT_STAKE\n}\n</code></pre>"},{"location":"contracts/components/staking/SlashingController/#slashpenalty","title":"SlashPenalty","text":"<pre><code>struct SlashPenalty {\n  uint256 percentSlashed;\n  enum SlashingController.PenaltyMode mode;\n}\n</code></pre>"},{"location":"contracts/components/staking/SlashingController/#deposit","title":"Deposit","text":"<pre><code>struct Deposit {\n  address proposer;\n  uint256 amount;\n}\n</code></pre>"},{"location":"contracts/components/staking/SlashingController/#proposal","title":"Proposal","text":"<pre><code>struct Proposal {\n  uint256 subjectId;\n  address proposer;\n  bytes32 penaltyId;\n  uint8 subjectType;\n}\n</code></pre>"},{"location":"contracts/components/staking/SlashingController/#_proposalids","title":"_proposalIds","text":"<pre><code>struct Counters.Counter _proposalIds\n</code></pre>"},{"location":"contracts/components/staking/SlashingController/#proposals","title":"proposals","text":"<pre><code>mapping(uint256 =&gt; struct SlashingController.Proposal) proposals\n</code></pre>"},{"location":"contracts/components/staking/SlashingController/#deposits","title":"deposits","text":"<pre><code>mapping(uint256 =&gt; uint256) deposits\n</code></pre>"},{"location":"contracts/components/staking/SlashingController/#penalties","title":"penalties","text":"<pre><code>mapping(bytes32 =&gt; struct SlashingController.SlashPenalty) penalties\n</code></pre>"},{"location":"contracts/components/staking/SlashingController/#slashingexecutor","title":"slashingExecutor","text":"<pre><code>contract ISlashingExecutor slashingExecutor\n</code></pre>"},{"location":"contracts/components/staking/SlashingController/#subjectgateway","title":"subjectGateway","text":"<pre><code>contract StakeSubjectGateway subjectGateway\n</code></pre>"},{"location":"contracts/components/staking/SlashingController/#depositamount","title":"depositAmount","text":"<pre><code>uint256 depositAmount\n</code></pre>"},{"location":"contracts/components/staking/SlashingController/#slashpercenttoproposer","title":"slashPercentToProposer","text":"<pre><code>uint256 slashPercentToProposer\n</code></pre>"},{"location":"contracts/components/staking/SlashingController/#deposittoken","title":"depositToken","text":"<pre><code>contract IERC20 depositToken\n</code></pre>"},{"location":"contracts/components/staking/SlashingController/#_transitiontable","title":"_transitionTable","text":"<pre><code>StateMachines.Machine _transitionTable\n</code></pre>"},{"location":"contracts/components/staking/SlashingController/#version","title":"version","text":"<pre><code>string version\n</code></pre>"},{"location":"contracts/components/staking/SlashingController/#max_evidence_length","title":"MAX_EVIDENCE_LENGTH","text":"<pre><code>uint256 MAX_EVIDENCE_LENGTH\n</code></pre>"},{"location":"contracts/components/staking/SlashingController/#max_char_length","title":"MAX_CHAR_LENGTH","text":"<pre><code>uint256 MAX_CHAR_LENGTH\n</code></pre>"},{"location":"contracts/components/staking/SlashingController/#hundred_percent","title":"HUNDRED_PERCENT","text":"<pre><code>uint256 HUNDRED_PERCENT\n</code></pre>"},{"location":"contracts/components/staking/SlashingController/#slashproposalupdated","title":"SlashProposalUpdated","text":"<pre><code>event SlashProposalUpdated(address updater, uint256 proposalId, enum StateMachines.State stateId, address proposer, uint256 subjectId, uint8 subjectType, bytes32 penaltyId)\n</code></pre>"},{"location":"contracts/components/staking/SlashingController/#evidencesubmitted","title":"EvidenceSubmitted","text":"<pre><code>event EvidenceSubmitted(uint256 proposalId, enum StateMachines.State stateId, string[] evidence)\n</code></pre>"},{"location":"contracts/components/staking/SlashingController/#depositamountchanged","title":"DepositAmountChanged","text":"<pre><code>event DepositAmountChanged(uint256 amount)\n</code></pre>"},{"location":"contracts/components/staking/SlashingController/#slashpercenttoproposerchanged","title":"SlashPercentToProposerChanged","text":"<pre><code>event SlashPercentToProposerChanged(uint256 amount)\n</code></pre>"},{"location":"contracts/components/staking/SlashingController/#depositsubmitted","title":"DepositSubmitted","text":"<pre><code>event DepositSubmitted(uint256 proposalId, address proposer, uint256 amount)\n</code></pre>"},{"location":"contracts/components/staking/SlashingController/#depositreturned","title":"DepositReturned","text":"<pre><code>event DepositReturned(uint256 proposalId, address proposer, uint256 amount)\n</code></pre>"},{"location":"contracts/components/staking/SlashingController/#depositslashed","title":"DepositSlashed","text":"<pre><code>event DepositSlashed(uint256 proposalId, address proposer, uint256 amount)\n</code></pre>"},{"location":"contracts/components/staking/SlashingController/#slashpenaltyadded","title":"SlashPenaltyAdded","text":"<pre><code>event SlashPenaltyAdded(bytes32 penaltyId, uint256 percentSlashed, enum SlashingController.PenaltyMode mode)\n</code></pre>"},{"location":"contracts/components/staking/SlashingController/#slashpenaltyremoved","title":"SlashPenaltyRemoved","text":"<pre><code>event SlashPenaltyRemoved(bytes32 penaltyId, uint256 percentSlashed, enum SlashingController.PenaltyMode mode)\n</code></pre>"},{"location":"contracts/components/staking/SlashingController/#wrongslashpenaltyid","title":"WrongSlashPenaltyId","text":"<pre><code>error WrongSlashPenaltyId(bytes32 penaltyId)\n</code></pre>"},{"location":"contracts/components/staking/SlashingController/#nonregisteredsubject","title":"NonRegisteredSubject","text":"<pre><code>error NonRegisteredSubject(uint8 subjectType, uint256 subjectId)\n</code></pre>"},{"location":"contracts/components/staking/SlashingController/#wrongpercentvalue","title":"WrongPercentValue","text":"<pre><code>error WrongPercentValue(uint256 value)\n</code></pre>"},{"location":"contracts/components/staking/SlashingController/#onlyvalidslashpenaltyid","title":"onlyValidSlashPenaltyId","text":"<pre><code>modifier onlyValidSlashPenaltyId(bytes32 penaltyId)\n</code></pre>"},{"location":"contracts/components/staking/SlashingController/#onlyvalidpercent","title":"onlyValidPercent","text":"<pre><code>modifier onlyValidPercent(uint256 percent)\n</code></pre>"},{"location":"contracts/components/staking/SlashingController/#constructor","title":"constructor","text":"<pre><code>constructor(address _forwarder, address _depositToken) public\n</code></pre>"},{"location":"contracts/components/staking/SlashingController/#initialize","title":"initialize","text":"<pre><code>function initialize(address __manager, contract ISlashingExecutor __executor, contract StakeSubjectGateway __subjectGateway, uint256 __depositAmount, uint256 __slashPercentToProposer, bytes32[] __slashPenaltyIds, struct SlashingController.SlashPenalty[] __slashPenalties) public\n</code></pre> <p>Initializer method, access point to initialize inheritance tree.</p> Name Type Description __manager address address of AccessManager. __executor contract ISlashingExecutor __subjectGateway contract StakeSubjectGateway __depositAmount uint256 __slashPercentToProposer uint256 __slashPenaltyIds bytes32[] __slashPenalties struct SlashingController.SlashPenalty[]"},{"location":"contracts/components/staking/SlashingController/#proposeslash","title":"proposeSlash","text":"<pre><code>function proposeSlash(uint8 _subjectType, uint256 _subjectId, bytes32 _penaltyId, string[] _evidence) external returns (uint256 proposalId)\n</code></pre> <p>Creates a slash proposal pointing to a slashable subject. To do so, the proposer must provide a FORT deposit and present evidence.</p> Name Type Description _subjectType uint8 type of the subject. _subjectId uint256 ERC721 registry id of the stake subject. _penaltyId bytes32 if of the SlashPenalty to inflict upon the subject if the proposal goes through. _evidence string[] IPFS hashes of the evidence files, proof of the subject being slash worthy. Name Type Description proposalId uint256 the proposal identifier."},{"location":"contracts/components/staking/SlashingController/#dismissslashproposal","title":"dismissSlashProposal","text":"<pre><code>function dismissSlashProposal(uint256 _proposalId, string[] _evidence) external\n</code></pre> <p>Arbiter dismisses a slash proposal (the proposal is legitimate, but after investigation, it is not a slashable offense) The deposit is returned to the proposer, and the stake of the subject is unfrozen</p> Name Type Description _proposalId uint256 the proposal identifier. _evidence string[] IPFS hashes of the evidence files, proof of the subject not being slashable."},{"location":"contracts/components/staking/SlashingController/#rejectslashproposal","title":"rejectSlashProposal","text":"<pre><code>function rejectSlashProposal(uint256 _proposalId, string[] _evidence) external\n</code></pre> <p>Arbiter rejects a slash proposal, slashing the deposit of the proposer (the proposal is deemed as spam, misconduct, or similar) and unfreezing the subject's stake.</p> Name Type Description _proposalId uint256 the proposal identifier. _evidence string[] IPFS hashes of the evidence files, justification for slashing the proposer's deposit."},{"location":"contracts/components/staking/SlashingController/#markasinreviewslashproposal","title":"markAsInReviewSlashProposal","text":"<pre><code>function markAsInReviewSlashProposal(uint256 _proposalId) external\n</code></pre> <p>Arbiter recognizes the report as valid and procceeds to investigate. The deposit is returned to proposer, stake remains frozen.</p> Name Type Description _proposalId uint256 the proposal identifier."},{"location":"contracts/components/staking/SlashingController/#reviewslashproposalparameters","title":"reviewSlashProposalParameters","text":"<pre><code>function reviewSlashProposalParameters(uint256 _proposalId, uint8 _subjectType, uint256 _subjectId, bytes32 _penaltyId, string[] _evidence) external\n</code></pre> <p>After investigation, arbiter updates the proposal's incorrect assumptions. This can only be done if the proposal is IN_REVIEW, and presenting evidence for the changes. Changing the subject and subjectType will unfreeze the previous target and freeze the new. Changing the penalty will affect slashing amounts.</p> Name Type Description _proposalId uint256 the proposal identifier. _subjectType uint8 type of the subject. _subjectId uint256 ERC721 registry id of the stake subject. _penaltyId bytes32 if of the SlashPenalty to inflict upon the subject if the proposal goes through. _evidence string[] IPFS hashes of the evidence files, proof of need for proposal changes."},{"location":"contracts/components/staking/SlashingController/#_updateproposal","title":"_updateProposal","text":"<pre><code>function _updateProposal(uint256 _proposalId, uint8 _subjectType, uint256 _subjectId, bytes32 _penaltyId) private\n</code></pre>"},{"location":"contracts/components/staking/SlashingController/#markasreviewedslashproposal","title":"markAsReviewedSlashProposal","text":"<pre><code>function markAsReviewedSlashProposal(uint256 _proposalId) external\n</code></pre> <p>Arbiter marks the proposal as reviewed, so the slasher can execute or revert.</p> Name Type Description _proposalId uint256 the proposal identifier."},{"location":"contracts/components/staking/SlashingController/#revertslashproposal","title":"revertSlashProposal","text":"<pre><code>function revertSlashProposal(uint256 _proposalId, string[] _evidence) external\n</code></pre> <p>The slashing proposal should not be executed. Stake is unfrozen. If the proposal is IN_REVIEW, this can be executed by the SLASHING_ARBITER_ROLE. If the proposal is REVIEWED, this can be executed by the SLASHER_ROLE.</p> Name Type Description _proposalId uint256 the proposal identifier. _evidence string[] IPFS hashes of the evidence files, proof of the slash being not valid."},{"location":"contracts/components/staking/SlashingController/#executeslashproposal","title":"executeSlashProposal","text":"<pre><code>function executeSlashProposal(uint256 _proposalId) external\n</code></pre> <p>The slashing proposal is executed. Subject's stake is slashed and unfrozen. The proposer gets a % of the slashed stake as defined by slashPercentToProposer. Only executable by SLASHER_ROLE</p> Name Type Description _proposalId uint256 the proposal identifier."},{"location":"contracts/components/staking/SlashingController/#getslashedstakevalue","title":"getSlashedStakeValue","text":"<pre><code>function getSlashedStakeValue(uint256 _proposalId) public view returns (uint256)\n</code></pre> <p>gets the stake amount to be slashed. The amount depends on the StakePenalty. In all cases, the amount will be the minimum of the max slashable stake for the subject and: MIN_STAKE: a % of the subject's MIN_STAKE CURRENT_STAKE: a % of the subject's active + inactive stake.</p>"},{"location":"contracts/components/staking/SlashingController/#getsubject","title":"getSubject","text":"<pre><code>function getSubject(uint256 _proposalId) external view returns (uint8 subjectType, uint256 subject)\n</code></pre>"},{"location":"contracts/components/staking/SlashingController/#getproposer","title":"getProposer","text":"<pre><code>function getProposer(uint256 _proposalId) external view returns (address)\n</code></pre>"},{"location":"contracts/components/staking/SlashingController/#setdepositamount","title":"setDepositAmount","text":"<pre><code>function setDepositAmount(uint256 _amount) external\n</code></pre>"},{"location":"contracts/components/staking/SlashingController/#setslashpercenttoproposer","title":"setSlashPercentToProposer","text":"<pre><code>function setSlashPercentToProposer(uint256 _amount) external\n</code></pre>"},{"location":"contracts/components/staking/SlashingController/#setslashpenalties","title":"setSlashPenalties","text":"<pre><code>function setSlashPenalties(bytes32[] _slashReasons, struct SlashingController.SlashPenalty[] _slashPenalties) external\n</code></pre>"},{"location":"contracts/components/staking/SlashingController/#_authorizerevertslashproposal","title":"_authorizeRevertSlashProposal","text":"<pre><code>function _authorizeRevertSlashProposal(uint256 _proposalId) private view\n</code></pre>"},{"location":"contracts/components/staking/SlashingController/#_unfreeze","title":"_unfreeze","text":"<pre><code>function _unfreeze(uint256 _proposalId) private\n</code></pre>"},{"location":"contracts/components/staking/SlashingController/#_freeze","title":"_freeze","text":"<pre><code>function _freeze(uint8 _subjectType, uint256 _subjectId) private\n</code></pre>"},{"location":"contracts/components/staking/SlashingController/#_setslashingexecutor","title":"_setSlashingExecutor","text":"<pre><code>function _setSlashingExecutor(contract ISlashingExecutor _executor) private\n</code></pre>"},{"location":"contracts/components/staking/SlashingController/#_setsubjectgateway","title":"_setsubjectGateway","text":"<pre><code>function _setsubjectGateway(contract StakeSubjectGateway _subjectGateway) private\n</code></pre>"},{"location":"contracts/components/staking/SlashingController/#_setdepositamount","title":"_setDepositAmount","text":"<pre><code>function _setDepositAmount(uint256 _amount) private\n</code></pre>"},{"location":"contracts/components/staking/SlashingController/#_setslashpercenttoproposer","title":"_setSlashPercentToProposer","text":"<pre><code>function _setSlashPercentToProposer(uint256 _amount) private\n</code></pre>"},{"location":"contracts/components/staking/SlashingController/#_setslashpenalties","title":"_setSlashPenalties","text":"<pre><code>function _setSlashPenalties(bytes32[] _slashReasons, struct SlashingController.SlashPenalty[] _slashPenalties) private\n</code></pre>"},{"location":"contracts/components/staking/SlashingController/#_submitevidence","title":"_submitEvidence","text":"<pre><code>function _submitEvidence(uint256 _proposalId, enum StateMachines.State _stateId, string[] _evidence) private\n</code></pre>"},{"location":"contracts/components/staking/SlashingController/#_returndeposit","title":"_returnDeposit","text":"<pre><code>function _returnDeposit(uint256 _proposalId) private\n</code></pre>"},{"location":"contracts/components/staking/SlashingController/#_slashdeposit","title":"_slashDeposit","text":"<pre><code>function _slashDeposit(uint256 _proposalId) private\n</code></pre>"},{"location":"contracts/components/staking/SlashingController/#transitiontable","title":"transitionTable","text":"<pre><code>function transitionTable() public view virtual returns (StateMachines.Machine)\n</code></pre>"},{"location":"contracts/components/staking/StakeAllocator/","title":"Stake Allocator","text":""},{"location":"contracts/components/staking/StakeAllocator/#stakeallocator","title":"StakeAllocator","text":"<p>This contract also manages the allocation of stake. See SubjectTypeValidator.sol for in depth explanation of Subject Agency</p> <p>Stake constants: totalStake = activeStake + inactiveStake activeStake(delegated) = allocatedStake(delegated) + unallocatedStake(delegated) activeStake(delegator) = allocatedStake(delegator) + unallocatedStake(delegator) allocatedStake(managed) = (allocatedStake(delegated) + allocatedStake(delegator)) / totalManagedSubjects(delegated) activeStake(managed) = inactiveStake(managed) = 0;</p>"},{"location":"contracts/components/staking/StakeAllocator/#version","title":"version","text":"<pre><code>string version\n</code></pre>"},{"location":"contracts/components/staking/StakeAllocator/#allocatedstake","title":"AllocatedStake","text":"<pre><code>event AllocatedStake(uint8 subjectType, uint256 subject, bool increase, uint256 amount, uint256 totalAllocated)\n</code></pre>"},{"location":"contracts/components/staking/StakeAllocator/#unallocatedstake","title":"UnallocatedStake","text":"<pre><code>event UnallocatedStake(uint8 subjectType, uint256 subject, bool increase, uint256 amount, uint256 totalAllocated)\n</code></pre>"},{"location":"contracts/components/staking/StakeAllocator/#sendercannotallocatefor","title":"SenderCannotAllocateFor","text":"<pre><code>error SenderCannotAllocateFor(uint8 subjectType, uint256 subject)\n</code></pre>"},{"location":"contracts/components/staking/StakeAllocator/#cannotdelegatestakeundermin","title":"CannotDelegateStakeUnderMin","text":"<pre><code>error CannotDelegateStakeUnderMin(uint8 subjectType, uint256 subject)\n</code></pre>"},{"location":"contracts/components/staking/StakeAllocator/#cannotdelegatenoenabledsubjects","title":"CannotDelegateNoEnabledSubjects","text":"<pre><code>error CannotDelegateNoEnabledSubjects(uint8 subjectType, uint256 subject)\n</code></pre>"},{"location":"contracts/components/staking/StakeAllocator/#constructor","title":"constructor","text":"<pre><code>constructor(address _forwarder, address __subjectGateway, address _rewardsDistributor) public\n</code></pre>"},{"location":"contracts/components/staking/StakeAllocator/#allocatedstakefor","title":"allocatedStakeFor","text":"<pre><code>function allocatedStakeFor(uint8 subjectType, uint256 subject) public view returns (uint256)\n</code></pre> <p>Active stake allocated on subject</p>"},{"location":"contracts/components/staking/StakeAllocator/#allocatedmanagedstake","title":"allocatedManagedStake","text":"<pre><code>function allocatedManagedStake(uint8 subjectType, uint256 subject) public view returns (uint256)\n</code></pre> <p>Total allocated stake in all managed subjects, both from delegated and delegator. Only returns values from DELEGATED types, else 0.</p>"},{"location":"contracts/components/staking/StakeAllocator/#allocatedstakepermanaged","title":"allocatedStakePerManaged","text":"<pre><code>function allocatedStakePerManaged(uint8 subjectType, uint256 subject) external view returns (uint256)\n</code></pre> <p>Returns allocatedManagedStake (own + delegator's) in DELEGATED / total managed subjects, or 0 if not DELEGATED</p>"},{"location":"contracts/components/staking/StakeAllocator/#allocatedownstakepermanaged","title":"allocatedOwnStakePerManaged","text":"<pre><code>function allocatedOwnStakePerManaged(uint8 subjectType, uint256 subject) public view returns (uint256)\n</code></pre> <p>Returns allocatedManagedStake (own only) in DELEGATED / total managed subjects, or 0 if not DELEGATED</p>"},{"location":"contracts/components/staking/StakeAllocator/#allocateddelegatorsstakepermanaged","title":"allocatedDelegatorsStakePerManaged","text":"<pre><code>function allocatedDelegatorsStakePerManaged(uint8 subjectType, uint256 subject) public view returns (uint256)\n</code></pre> <p>Returns allocatedManagedStake (delegators only) in DELEGATED / total managed subjects, or 0 if not DELEGATED</p>"},{"location":"contracts/components/staking/StakeAllocator/#unallocatedstakefor","title":"unallocatedStakeFor","text":"<pre><code>function unallocatedStakeFor(uint8 subjectType, uint256 subject) external view returns (uint256)\n</code></pre> <p>Total active stake not allocated on subjects</p>"},{"location":"contracts/components/staking/StakeAllocator/#allocateownstake","title":"allocateOwnStake","text":"<pre><code>function allocateOwnStake(uint8 subjectType, uint256 subject, uint256 amount) external\n</code></pre> <p>owner of a DELEGATED subject moves tokens from its own unallocated to allocated. It will fail if allocating more than the max for managed stake.</p> Name Type Description subjectType uint8 type id of Stake Subject. See SubjectTypeValidator.sol subject uint256 id identifying subject (external to FortaStaking). amount uint256 amount of stake to move from unallocated to allocated."},{"location":"contracts/components/staking/StakeAllocator/#unallocateownstake","title":"unallocateOwnStake","text":"<pre><code>function unallocateOwnStake(uint8 subjectType, uint256 subject, uint256 amount) external\n</code></pre> <p>owner of a DELEGATED subject moves it's own tokens from allocated to unallocated.</p> Name Type Description subjectType uint8 type id of Stake Subject. See SubjectTypeValidator.sol subject uint256 id identifying subject (external to FortaStaking). amount uint256 amount of incoming staked token."},{"location":"contracts/components/staking/StakeAllocator/#allocatedelegatorstake","title":"allocateDelegatorStake","text":"<pre><code>function allocateDelegatorStake(uint8 subjectType, uint256 subject, uint256 amount) external\n</code></pre> <p>owner of a DELEGATED subject moves tokens from DELEGATOR's unallocated to allocated. It will fail if allocating more than the max for managed stake.</p> Name Type Description subjectType uint8 type id of Stake Subject. See SubjectTypeValidator.sol subject uint256 id identifying subject (external to FortaStaking). amount uint256 amount of stake to move from unallocated to allocated."},{"location":"contracts/components/staking/StakeAllocator/#unallocatedelegatorstake","title":"unallocateDelegatorStake","text":"<pre><code>function unallocateDelegatorStake(uint8 subjectType, uint256 subject, uint256 amount) external\n</code></pre> <p>owner of a DELEGATED subject moves it's own tokens from allocated to unallocated.</p> Name Type Description subjectType uint8 type id of Stake Subject. See SubjectTypeValidator.sol subject uint256 id identifying subject (external to FortaStaking). amount uint256 amount of staked token."},{"location":"contracts/components/staking/StakeAllocator/#depositallocation","title":"depositAllocation","text":"<pre><code>function depositAllocation(uint256 activeSharesId, uint8 subjectType, uint256 subject, address allocator, uint256 stakeAmount, uint256 sharesAmount) external\n</code></pre> <p>Allocates stake on deposit (increment of activeStake) for a DELEGATED subject incrementing it's allocatedStake. If allocatedStake is going to be over the max for the corresponding MANAGED subject, the excess increments unallocatedStake.</p> Name Type Description activeSharesId uint256 ERC1155 id representing the active shares of a subject / subjectType pair. subjectType uint8 type id of Stake Subject. See SubjectTypeValidator.sol subject uint256 id identifying subject (external to FortaStaking). allocator address stakeAmount uint256 amount of incoming staked token. sharesAmount uint256 amount of minted active shares for stake"},{"location":"contracts/components/staking/StakeAllocator/#withdrawallocation","title":"withdrawAllocation","text":"<pre><code>function withdrawAllocation(uint256 activeSharesId, uint8 subjectType, uint256 subject, address allocator, uint256 stakeAmount, uint256 sharesAmount) external\n</code></pre> <p>method to call when substracting activeStake. Will burn unallocatedStake (and allocatedStake if amount is bigger than unallocatedStake). If withdrawal leads to DELEGATED to be below staking minimum, unallocates delegators' stake.</p> Name Type Description activeSharesId uint256 ERC1155 id representing the active shares of a subject / subjectType pair. subjectType uint8 type id of Stake Subject. See SubjectTypeValidator.sol subject uint256 id identifying subject (external to FortaStaking). allocator address stakeAmount uint256 amount of outgoing staked token. sharesAmount uint256 amount of outgoing active shares"},{"location":"contracts/components/staking/StakeAllocator/#didtransfershares","title":"didTransferShares","text":"<pre><code>function didTransferShares(uint256 sharesId, uint8 subjectType, address from, address to, uint256 sharesAmount) external\n</code></pre>"},{"location":"contracts/components/staking/StakeSubjectGateway/","title":"Stake Subject Gateway","text":""},{"location":"contracts/components/staking/StakeSubjectGateway/#stakesubjectgateway","title":"StakeSubjectGateway","text":"<p>Formerly FortaStakingParameters.</p> <p>This contract manages the relationship between the staking contracts and the several affected staking subjects, who hold the responsibility of defining staking thresholds, managed subjects, and related particularities.</p>"},{"location":"contracts/components/staking/StakeSubjectGateway/#nonidelegatedsubjecthandler","title":"NonIDelegatedSubjectHandler","text":"<pre><code>error NonIDelegatedSubjectHandler(uint8 subjectType, address stakeSubject)\n</code></pre>"},{"location":"contracts/components/staking/StakeSubjectGateway/#version","title":"version","text":"<pre><code>string version\n</code></pre>"},{"location":"contracts/components/staking/StakeSubjectGateway/#setstakesubject","title":"setStakeSubject","text":"<pre><code>function setStakeSubject(uint8 subjectType, address subject) external\n</code></pre> <p>Sets stake subject for subject type.</p>"},{"location":"contracts/components/staking/StakeSubjectGateway/#unsetstakesubject","title":"unsetStakeSubject","text":"<pre><code>function unsetStakeSubject(uint8 subjectType) external\n</code></pre>"},{"location":"contracts/components/staking/StakeSubjectGateway/#getstakesubject","title":"getStakeSubject","text":"<pre><code>function getStakeSubject(uint8 subjectType) external view returns (address)\n</code></pre>"},{"location":"contracts/components/staking/StakeSubjectGateway/#maxstakefor","title":"maxStakeFor","text":"<pre><code>function maxStakeFor(uint8 subjectType, uint256 subject) external view returns (uint256)\n</code></pre> <p>Get max stake for that <code>subjectType</code> and <code>subject</code></p> Name Type Description [0] uint256 if subject is DIRECT, returns stakeThreshold.max, if not MAX_UINT. If subject not set, it will return 0."},{"location":"contracts/components/staking/StakeSubjectGateway/#minstakefor","title":"minStakeFor","text":"<pre><code>function minStakeFor(uint8 subjectType, uint256 subject) external view returns (uint256)\n</code></pre> <p>Get min stake for that <code>subjectType</code> and <code>subject</code></p> Name Type Description [0] uint256 if subject is DIRECT, returns stakeThreshold.min, if not 0. If subject not set, it will return MAX_UINT."},{"location":"contracts/components/staking/StakeSubjectGateway/#maxmanagedstakefor","title":"maxManagedStakeFor","text":"<pre><code>function maxManagedStakeFor(uint8 subjectType, uint256 subject) external view returns (uint256)\n</code></pre>"},{"location":"contracts/components/staking/StakeSubjectGateway/#minmanagedstakefor","title":"minManagedStakeFor","text":"<pre><code>function minManagedStakeFor(uint8 subjectType, uint256 subject) external view returns (uint256)\n</code></pre>"},{"location":"contracts/components/staking/StakeSubjectGateway/#totalmanagedsubjects","title":"totalManagedSubjects","text":"<pre><code>function totalManagedSubjects(uint8 subjectType, uint256 subject) external view returns (uint256)\n</code></pre>"},{"location":"contracts/components/staking/StakeSubjectGateway/#isstakeactivatedfor","title":"isStakeActivatedFor","text":"<pre><code>function isStakeActivatedFor(uint8 subjectType, uint256 subject) external view returns (bool)\n</code></pre> <p>Get if staking is activated for that <code>subjectType</code> and <code>subject</code>. If not set, will return false.</p>"},{"location":"contracts/components/staking/StakeSubjectGateway/#activestakefor","title":"activeStakeFor","text":"<pre><code>function activeStakeFor(uint8 subjectType, uint256 subject) external view returns (uint256)\n</code></pre> <p>Gets active stake (amount of staked tokens) on <code>subject</code> id for <code>subjectType</code></p>"},{"location":"contracts/components/staking/StakeSubjectGateway/#totalstakefor","title":"totalStakeFor","text":"<pre><code>function totalStakeFor(uint8 subjectType, uint256 subject) external view returns (uint256)\n</code></pre> <p>Gets active and inactive stake (amount of staked tokens) on <code>subject</code> id for <code>subjectType</code></p>"},{"location":"contracts/components/staking/StakeSubjectGateway/#isregistered","title":"isRegistered","text":"<pre><code>function isRegistered(uint8 subjectType, uint256 subject) external view returns (bool)\n</code></pre> <p>Checks if subject, subjectType is registered</p>"},{"location":"contracts/components/staking/StakeSubjectGateway/#canmanageallocation","title":"canManageAllocation","text":"<pre><code>function canManageAllocation(uint8 subjectType, uint256 subject, address allocator) external view returns (bool)\n</code></pre> <p>Returns true if allocator owns the subject, or is the subject contract itself</p>"},{"location":"contracts/components/staking/StakeSubjectGateway/#ownerof","title":"ownerOf","text":"<pre><code>function ownerOf(uint8 subjectType, uint256 subject) external view returns (address)\n</code></pre>"},{"location":"contracts/components/staking/SubjectTypeValidator/","title":"Subject Type Validator","text":""},{"location":"contracts/components/staking/SubjectTypeValidator/#undefined_subject","title":"UNDEFINED_SUBJECT","text":"<pre><code>uint8 UNDEFINED_SUBJECT\n</code></pre>"},{"location":"contracts/components/staking/SubjectTypeValidator/#scanner_subject","title":"SCANNER_SUBJECT","text":"<pre><code>uint8 SCANNER_SUBJECT\n</code></pre>"},{"location":"contracts/components/staking/SubjectTypeValidator/#agent_subject","title":"AGENT_SUBJECT","text":"<pre><code>uint8 AGENT_SUBJECT\n</code></pre>"},{"location":"contracts/components/staking/SubjectTypeValidator/#scanner_pool_subject","title":"SCANNER_POOL_SUBJECT","text":"<pre><code>uint8 SCANNER_POOL_SUBJECT\n</code></pre>"},{"location":"contracts/components/staking/SubjectTypeValidator/#delegator_scanner_pool_subject","title":"DELEGATOR_SCANNER_POOL_SUBJECT","text":"<pre><code>uint8 DELEGATOR_SCANNER_POOL_SUBJECT\n</code></pre>"},{"location":"contracts/components/staking/SubjectTypeValidator/#subjecttypevalidator","title":"SubjectTypeValidator","text":"<p>Defines the types of staking Subject Types, their agency and relationships. There are different types of subject type agency: - MANAGED --&gt; Cannot be staked on directly, allocation of stake is controlled by their manager, a DELEGATED type - DIRECT --&gt; Can be staked on by multiple different stakers - DELEGATED --&gt; Can be staked on by the owner of the relevant Registry entry. Manages MANAGED subjects. - DELEGATOR --&gt; TBD</p> <p>The current Subject Types and their Agency: - SCANNER_SUBJECT --&gt; MANAGED - AGENT_SUBJECT (detection bots) --&gt; DIRECT - SCANNER_POOL_SUBJECT --&gt; DELEGATED</p>"},{"location":"contracts/components/staking/SubjectTypeValidator/#invalidsubjecttype","title":"InvalidSubjectType","text":"<pre><code>error InvalidSubjectType(uint8 subjectType)\n</code></pre>"},{"location":"contracts/components/staking/SubjectTypeValidator/#forbiddenfortype","title":"ForbiddenForType","text":"<pre><code>error ForbiddenForType(uint8 subjectType, enum SubjectTypeValidator.SubjectStakeAgency provided, enum SubjectTypeValidator.SubjectStakeAgency expected)\n</code></pre>"},{"location":"contracts/components/staking/SubjectTypeValidator/#onlyvalidsubjecttype","title":"onlyValidSubjectType","text":"<pre><code>modifier onlyValidSubjectType(uint8 subjectType)\n</code></pre> <p>check if <code>subjectType</code> belongs to the defined SUBJECT_TYPES</p> Name Type Description subjectType uint8 is not an enum because some contracts using subjectTypes are not upgradeable (StakingEscrow)"},{"location":"contracts/components/staking/SubjectTypeValidator/#onlyagencytype","title":"onlyAgencyType","text":"<pre><code>modifier onlyAgencyType(uint8 subjectType, enum SubjectTypeValidator.SubjectStakeAgency expected)\n</code></pre>"},{"location":"contracts/components/staking/SubjectTypeValidator/#notagencytype","title":"notAgencyType","text":"<pre><code>modifier notAgencyType(uint8 subjectType, enum SubjectTypeValidator.SubjectStakeAgency forbidden)\n</code></pre>"},{"location":"contracts/components/staking/SubjectTypeValidator/#getsubjecttypeagency","title":"getSubjectTypeAgency","text":"<pre><code>function getSubjectTypeAgency(uint8 subjectType) public pure returns (enum SubjectTypeValidator.SubjectStakeAgency)\n</code></pre>"},{"location":"contracts/components/staking/SubjectTypeValidator/#getdelegatorsubjecttype","title":"getDelegatorSubjectType","text":"<pre><code>function getDelegatorSubjectType(uint8 subjectType) public pure returns (uint8)\n</code></pre>"},{"location":"contracts/components/staking/SubjectTypeValidator/#getdelegatedsubjecttype","title":"getDelegatedSubjectType","text":"<pre><code>function getDelegatedSubjectType(uint8 subjectType) public pure returns (uint8)\n</code></pre>"},{"location":"contracts/components/utils/AccessManaged/","title":"Access Managed","text":""},{"location":"contracts/components/utils/AccessManaged/#accessmanagedupgradeable","title":"AccessManagedUpgradeable","text":""},{"location":"contracts/components/utils/AccessManaged/#_accesscontrol","title":"_accessControl","text":"<pre><code>contract IAccessControl _accessControl\n</code></pre>"},{"location":"contracts/components/utils/AccessManaged/#accessmanagerupdated","title":"AccessManagerUpdated","text":"<pre><code>event AccessManagerUpdated(address newAddressManager)\n</code></pre>"},{"location":"contracts/components/utils/AccessManaged/#missingrole","title":"MissingRole","text":"<pre><code>error MissingRole(bytes32 role, address account)\n</code></pre>"},{"location":"contracts/components/utils/AccessManaged/#onlyrole","title":"onlyRole","text":"<pre><code>modifier onlyRole(bytes32 role)\n</code></pre> <p>Checks if _msgSender() has <code>role</code>, reverts if not.</p> Name Type Description role bytes32 the role to be tested, defined in Roles.sol and set in AccessManager instance."},{"location":"contracts/components/utils/AccessManaged/#__accessmanaged_init","title":"__AccessManaged_init","text":"<pre><code>function __AccessManaged_init(address manager) internal\n</code></pre> <p>Initializer method, access point to initialize inheritance tree.</p> Name Type Description manager address address of AccessManager."},{"location":"contracts/components/utils/AccessManaged/#hasrole","title":"hasRole","text":"<pre><code>function hasRole(bytes32 role, address account) internal view returns (bool)\n</code></pre> <p>Checks if <code>account has</code>role` assigned.</p> Name Type Description role bytes32 the role to be tested, defined in Roles.sol and set in AccessManager instance. account address the address to be tested for the role. Name Type Description [0] bool return true if account has role, false otherwise."},{"location":"contracts/components/utils/AccessManaged/#setaccessmanager","title":"setAccessManager","text":"<pre><code>function setAccessManager(address newManager) public\n</code></pre> <p>Sets AccessManager instance. Restricted to DEFAULT_ADMIN_ROLE</p> Name Type Description newManager address address of the new instance of AccessManager."},{"location":"contracts/components/utils/AccessManaged/#__gap","title":"__gap","text":"<pre><code>uint256[49] __gap\n</code></pre>"},{"location":"contracts/components/utils/ForwardedContext/","title":"Forwarded Context","text":""},{"location":"contracts/components/utils/ForwardedContext/#forwardedcontext","title":"ForwardedContext","text":""},{"location":"contracts/components/utils/ForwardedContext/#_trustedforwarder","title":"_trustedForwarder","text":"<pre><code>address _trustedForwarder\n</code></pre>"},{"location":"contracts/components/utils/ForwardedContext/#address_size_bytes","title":"ADDRESS_SIZE_BYTES","text":"<pre><code>uint256 ADDRESS_SIZE_BYTES\n</code></pre>"},{"location":"contracts/components/utils/ForwardedContext/#constructor","title":"constructor","text":"<pre><code>constructor(address trustedForwarder) internal\n</code></pre>"},{"location":"contracts/components/utils/ForwardedContext/#istrustedforwarder","title":"isTrustedForwarder","text":"<pre><code>function isTrustedForwarder(address forwarder) public view virtual returns (bool)\n</code></pre> <p>Checks if <code>forwarder</code> address provided is the trustedForwarder set in the constructor.</p>"},{"location":"contracts/components/utils/ForwardedContext/#_msgsender","title":"_msgSender","text":"<pre><code>function _msgSender() internal view virtual returns (address sender)\n</code></pre> <p>Gets sender of the transaction of signer if meta transaction.</p> <p>If the tx is sent by the trusted forwarded, we assume it is a meta transaction and  the signer address is encoded in the last 20 bytes of msg.data.</p> Name Type Description sender address address of sender of the transaction of signer if meta transaction."},{"location":"contracts/components/utils/ForwardedContext/#_msgdata","title":"_msgData","text":"<pre><code>function _msgData() internal view virtual returns (bytes)\n</code></pre> <p>Gets msg.data of the transaction or meta-tx.</p> <p>If the tx is sent by the trusted forwarded, we assume it is a meta transaction and  msg.data must have the signer address (encoded in the last 20 bytes of msg.data) removed.</p> Name Type Description [0] bytes msg.data of the transaction of msg.data - signer address if meta transaction."},{"location":"contracts/components/utils/IVersioned/","title":"IVersioned","text":""},{"location":"contracts/components/utils/IVersioned/#iversioned","title":"IVersioned","text":""},{"location":"contracts/components/utils/IVersioned/#version","title":"version","text":"<pre><code>function version() external returns (string v)\n</code></pre>"},{"location":"contracts/components/utils/ReentrancyGuardHandler/","title":"Reentrancy Guard Handler","text":""},{"location":"contracts/components/utils/ReentrancyGuardHandler/#reentrancyguardhandlerupgradeable","title":"ReentrancyGuardHandlerUpgradeable","text":"<p>_Based in OZ's ReentracyGuardUpgradeable, but without it's own storage so we can insert the guard respecting storage layout.</p> <p>Contract module that helps prevent reentrant calls to a function.</p> <p>Inheriting from <code>ReentrancyGuard</code> will make the {nonReentrant} modifier available, which can be applied to functions to make sure there are no nested (reentrant) calls to them.</p> <p>Note that because there is a single <code>nonReentrant</code> guard, functions marked as <code>nonReentrant</code> may not call one another. This can be worked around by making those functions <code>private</code>, and then adding <code>external</code> <code>nonReentrant</code> entry points to them.</p> <p>TIP: If you would like to learn more about reentrancy and alternative ways to protect against it, check out our blog post Reentrancy After Istanbul.</p>"},{"location":"contracts/components/utils/ReentrancyGuardHandler/#_not_entered","title":"_NOT_ENTERED","text":"<pre><code>uint256 _NOT_ENTERED\n</code></pre>"},{"location":"contracts/components/utils/ReentrancyGuardHandler/#_entered","title":"_ENTERED","text":"<pre><code>uint256 _ENTERED\n</code></pre>"},{"location":"contracts/components/utils/ReentrancyGuardHandler/#__reentrancyguard_init","title":"__ReentrancyGuard_init","text":"<pre><code>function __ReentrancyGuard_init() internal\n</code></pre>"},{"location":"contracts/components/utils/ReentrancyGuardHandler/#__reentrancyguard_init_unchained","title":"__ReentrancyGuard_init_unchained","text":"<pre><code>function __ReentrancyGuard_init_unchained() internal\n</code></pre>"},{"location":"contracts/components/utils/ReentrancyGuardHandler/#_setstatus","title":"_setStatus","text":"<pre><code>function _setStatus(uint256 newStatus) internal virtual\n</code></pre>"},{"location":"contracts/components/utils/ReentrancyGuardHandler/#_getstatus","title":"_getStatus","text":"<pre><code>function _getStatus() internal virtual returns (uint256)\n</code></pre>"},{"location":"contracts/components/utils/ReentrancyGuardHandler/#nonreentrant","title":"nonReentrant","text":"<pre><code>modifier nonReentrant()\n</code></pre> <p>Prevents a contract from calling itself, directly or indirectly. Calling a <code>nonReentrant</code> function from another <code>nonReentrant</code> function is not supported. It is possible to prevent this from happening by making the <code>nonReentrant</code> function external, and making it call a <code>private</code> function that does the actual work.</p>"},{"location":"contracts/components/utils/Routed/","title":"Routed","text":""},{"location":"contracts/components/utils/Routed/#routedupgradeable","title":"RoutedUpgradeable","text":"<p>Since Router is deprecated, we are keeping RoutedUpgradeable in this state to preserve storage layout in deployed <code>BaseComponentUpgradeable</code> contracts.</p>"},{"location":"contracts/components/utils/Routed/#_deprecated_router","title":"_deprecated_router","text":"<pre><code>address _deprecated_router\n</code></pre>"},{"location":"contracts/components/utils/Routed/#routerupdated","title":"RouterUpdated","text":"<pre><code>event RouterUpdated(address router)\n</code></pre>"},{"location":"contracts/components/utils/Routed/#disablerouter","title":"disableRouter","text":"<pre><code>function disableRouter() public\n</code></pre> <p>Sets Router instance to address(0).</p>"},{"location":"contracts/components/utils/Routed/#__gap","title":"__gap","text":"<pre><code>uint256[49] __gap\n</code></pre>"},{"location":"contracts/components/utils/StateMachines/","title":"State Machines","text":""},{"location":"contracts/components/utils/StateMachines/#statemachines","title":"StateMachines","text":"<p>Library to handle Finite State Machines and codify their transitions in a uint256. NOTE: the number of states is limited to 16. Rewritten by Hadrien Croubois, https://github.com/Amxx</p>"},{"location":"contracts/components/utils/StateMachines/#machine","title":"Machine","text":""},{"location":"contracts/components/utils/StateMachines/#empty_machine","title":"EMPTY_MACHINE","text":"<pre><code>StateMachines.Machine EMPTY_MACHINE\n</code></pre>"},{"location":"contracts/components/utils/StateMachines/#state","title":"State","text":"<pre><code>enum State {\n  _00,\n  _01,\n  _02,\n  _03,\n  _04,\n  _05,\n  _06,\n  _07,\n  _08,\n  _09,\n  _10,\n  _11,\n  _12,\n  _13,\n  _14,\n  _15\n}\n</code></pre>"},{"location":"contracts/components/utils/StateMachines/#statestoedge","title":"statesToEdge","text":"<pre><code>function statesToEdge(enum StateMachines.State fromState, enum StateMachines.State toState) internal pure returns (uint256)\n</code></pre>"},{"location":"contracts/components/utils/StateMachines/#istransitionvalid","title":"isTransitionValid","text":"<pre><code>function isTransitionValid(StateMachines.Machine self, enum StateMachines.State fromState, enum StateMachines.State toState) internal pure returns (bool)\n</code></pre>"},{"location":"contracts/components/utils/StateMachines/#addedgetransition","title":"addEdgeTransition","text":"<pre><code>function addEdgeTransition(StateMachines.Machine self, enum StateMachines.State fromState, enum StateMachines.State toState) internal pure returns (StateMachines.Machine newMachine)\n</code></pre>"},{"location":"contracts/components/utils/StateMachines/#removeedgetransition","title":"removeEdgeTransition","text":"<pre><code>function removeEdgeTransition(StateMachines.Machine self, enum StateMachines.State fromState, enum StateMachines.State toState) internal pure returns (StateMachines.Machine newMachine)\n</code></pre>"},{"location":"contracts/components/utils/StateMachines/#statemachinecontroller","title":"StateMachineController","text":"<p>Contract that allows for the creation and management of finite state machines. The state machines will transition following a commonly defined state set. What each state and state transition means, as well as the business logic of defining a valid transition are left to the inheriting contract.</p>"},{"location":"contracts/components/utils/StateMachines/#statetransition","title":"StateTransition","text":"<pre><code>event StateTransition(uint256 machineId, enum StateMachines.State fromState, enum StateMachines.State toState)\n</code></pre>"},{"location":"contracts/components/utils/StateMachines/#invalidstate","title":"InvalidState","text":"<pre><code>error InvalidState(enum StateMachines.State state)\n</code></pre>"},{"location":"contracts/components/utils/StateMachines/#invalidstatetransition","title":"InvalidStateTransition","text":"<pre><code>error InvalidStateTransition(enum StateMachines.State fromState, enum StateMachines.State toState)\n</code></pre>"},{"location":"contracts/components/utils/StateMachines/#_machines","title":"_machines","text":"<pre><code>mapping(uint256 =&gt; enum StateMachines.State) _machines\n</code></pre>"},{"location":"contracts/components/utils/StateMachines/#onlyinstate","title":"onlyInState","text":"<pre><code>modifier onlyInState(uint256 _machineId, enum StateMachines.State _state)\n</code></pre>"},{"location":"contracts/components/utils/StateMachines/#transitiontable","title":"transitionTable","text":"<pre><code>function transitionTable() public view virtual returns (StateMachines.Machine)\n</code></pre>"},{"location":"contracts/components/utils/StateMachines/#_transition","title":"_transition","text":"<pre><code>function _transition(uint256 _machineId, enum StateMachines.State _newState) internal\n</code></pre>"},{"location":"contracts/components/utils/StateMachines/#currentstate","title":"currentState","text":"<pre><code>function currentState(uint256 _machineId) public view returns (enum StateMachines.State)\n</code></pre> <p>Checks the current state of a machine.</p> Name Type Description _machineId uint256 the identifier of a machine. Name Type Description [0] enum StateMachines.State current state identifier."},{"location":"contracts/errors/GeneralErrors/","title":"GeneralErrors","text":""},{"location":"contracts/errors/GeneralErrors/#zeroaddress","title":"ZeroAddress","text":"<pre><code>error ZeroAddress(string name)\n</code></pre>"},{"location":"contracts/errors/GeneralErrors/#zeroamount","title":"ZeroAmount","text":"<pre><code>error ZeroAmount(string name)\n</code></pre>"},{"location":"contracts/errors/GeneralErrors/#emptyarray","title":"EmptyArray","text":"<pre><code>error EmptyArray(string name)\n</code></pre>"},{"location":"contracts/errors/GeneralErrors/#emptystring","title":"EmptyString","text":"<pre><code>error EmptyString(string name)\n</code></pre>"},{"location":"contracts/errors/GeneralErrors/#unorderedarray","title":"UnorderedArray","text":"<pre><code>error UnorderedArray(string name)\n</code></pre>"},{"location":"contracts/errors/GeneralErrors/#differentlengtharray","title":"DifferentLengthArray","text":"<pre><code>error DifferentLengthArray(string array1, string array2)\n</code></pre>"},{"location":"contracts/errors/GeneralErrors/#arraytoobig","title":"ArrayTooBig","text":"<pre><code>error ArrayTooBig(uint256 length, uint256 max)\n</code></pre>"},{"location":"contracts/errors/GeneralErrors/#stringtoolarge","title":"StringTooLarge","text":"<pre><code>error StringTooLarge(uint256 length, uint256 max)\n</code></pre>"},{"location":"contracts/errors/GeneralErrors/#amounttoolarge","title":"AmountTooLarge","text":"<pre><code>error AmountTooLarge(uint256 amount, uint256 max)\n</code></pre>"},{"location":"contracts/errors/GeneralErrors/#amounttoosmall","title":"AmountTooSmall","text":"<pre><code>error AmountTooSmall(uint256 amount, uint256 min)\n</code></pre>"},{"location":"contracts/errors/GeneralErrors/#unsupportedinterface","title":"UnsupportedInterface","text":"<pre><code>error UnsupportedInterface(string name)\n</code></pre>"},{"location":"contracts/errors/GeneralErrors/#sendernotowner","title":"SenderNotOwner","text":"<pre><code>error SenderNotOwner(address sender, uint256 ownedId)\n</code></pre>"},{"location":"contracts/errors/GeneralErrors/#doesnothaveaccess","title":"DoesNotHaveAccess","text":"<pre><code>error DoesNotHaveAccess(address sender, string access)\n</code></pre>"},{"location":"contracts/errors/GeneralErrors/#doesnothavepermission","title":"DoesNotHavePermission","text":"<pre><code>error DoesNotHavePermission(address sender, uint8 permission, uint256 id)\n</code></pre>"},{"location":"contracts/helpers/BatchRelayer/","title":"BatchRelayer","text":""},{"location":"contracts/helpers/BatchRelayer/#batchrelayer","title":"BatchRelayer","text":"<p>Helper contract for deploy scripts for batch transactions.</p>"},{"location":"contracts/helpers/BatchRelayer/#relay","title":"relay","text":"<pre><code>function relay(address target, bytes[] data) external returns (bytes[] results)\n</code></pre> <p>Calls multiple functions on the contract deployed in <code>target</code> address. Only callable by owner of BatchRelayer.</p> Name Type Description target address the destination contract. data bytes[] encoded method calls with arguments. Name Type Description results bytes[] of the method calls."},{"location":"contracts/mocks/FortaExtendedMock/","title":"FortaExtendedMock","text":""},{"location":"contracts/mocks/FortaExtendedMock/#fortaextendedmock","title":"FortaExtendedMock","text":""},{"location":"contracts/mocks/FortaExtendedMock/#version","title":"version","text":"<pre><code>function version() external pure returns (string)\n</code></pre> <p>Contract version</p> <p>Since FortaCommon is IVersioned, Forta is deployed in L1 and FortaBridgedPolygon in L2, we need to implement the interface with a method instead of immutable variable.</p> Name Type Description [0] string version of FORT deployed in L1"},{"location":"contracts/mocks/RootChainManagerMock/","title":"RootChainManagerMock","text":""},{"location":"contracts/mocks/RootChainManagerMock/#predicatmock","title":"PredicatMock","text":""},{"location":"contracts/mocks/RootChainManagerMock/#lockederc20","title":"LockedERC20","text":"<pre><code>event LockedERC20(address depositor, address depositReceiver, address rootToken, uint256 amount)\n</code></pre>"},{"location":"contracts/mocks/RootChainManagerMock/#locktokens","title":"lockTokens","text":"<pre><code>function lockTokens(address depositor, address depositReceiver, address rootToken, bytes depositData) public\n</code></pre>"},{"location":"contracts/mocks/RootChainManagerMock/#exittokens","title":"exitTokens","text":"<pre><code>function exitTokens(address, address rootToken, bytes log) public\n</code></pre>"},{"location":"contracts/mocks/RootChainManagerMock/#rootchainmanagermock","title":"RootChainManagerMock","text":""},{"location":"contracts/mocks/RootChainManagerMock/#predicate","title":"predicate","text":"<pre><code>contract PredicatMock predicate\n</code></pre>"},{"location":"contracts/mocks/RootChainManagerMock/#bridgedeposit","title":"BridgeDeposit","text":"<pre><code>event BridgeDeposit(address user, address rootToken, bytes depositData)\n</code></pre>"},{"location":"contracts/mocks/RootChainManagerMock/#tokentotype","title":"tokenToType","text":"<pre><code>function tokenToType(address) external pure returns (bytes32)\n</code></pre>"},{"location":"contracts/mocks/RootChainManagerMock/#typetopredicate","title":"typeToPredicate","text":"<pre><code>function typeToPredicate(bytes32) external view returns (address)\n</code></pre>"},{"location":"contracts/mocks/RootChainManagerMock/#depositfor","title":"depositFor","text":"<pre><code>function depositFor(address user, address rootToken, bytes depositData) external\n</code></pre>"},{"location":"contracts/mocks/RootChainManagerMock/#exit","title":"exit","text":"<pre><code>function exit(bytes inputData) external\n</code></pre>"},{"location":"contracts/mocks/Sink/","title":"Sink","text":""},{"location":"contracts/mocks/Sink/#sink","title":"Sink","text":""},{"location":"contracts/mocks/Sink/#gotsignal","title":"GotSignal","text":"<pre><code>event GotSignal(bytes data)\n</code></pre>"},{"location":"contracts/mocks/Sink/#fallback","title":"fallback","text":"<pre><code>fallback() external payable\n</code></pre>"},{"location":"contracts/mocks/VestingWalletExtendedMock/","title":"VestingWalletExtendedMock","text":""},{"location":"contracts/mocks/VestingWalletExtendedMock/#vestingwalletextendedmock","title":"VestingWalletExtendedMock","text":""},{"location":"contracts/mocks/VestingWalletExtendedMock/#version","title":"version","text":"<pre><code>function version() external pure returns (string)\n</code></pre>"},{"location":"contracts/token/Forta/","title":"Forta","text":""},{"location":"contracts/token/Forta/#forta","title":"Forta","text":"<p>This version of the Forta token is living on the root (or parent) chain. That would be: - Mainnet for production - Goerli for testing</p> <p>In addition to all the common forta features, the version is mintable by a specific role.</p>"},{"location":"contracts/token/Forta/#minter_role","title":"MINTER_ROLE","text":"<pre><code>bytes32 MINTER_ROLE\n</code></pre>"},{"location":"contracts/token/Forta/#supply","title":"SUPPLY","text":"<pre><code>uint256 SUPPLY\n</code></pre>"},{"location":"contracts/token/Forta/#mintingmorethansupply","title":"MintingMoreThanSupply","text":"<pre><code>error MintingMoreThanSupply()\n</code></pre>"},{"location":"contracts/token/Forta/#initialize","title":"initialize","text":"<pre><code>function initialize(address admin) public\n</code></pre> <p>Initializer method, access point to initialize inheritance tree.</p> Name Type Description admin address address for the ADMIN_ROLE of the token."},{"location":"contracts/token/Forta/#mint","title":"mint","text":"<pre><code>function mint(address to, uint256 amount) public\n</code></pre> <p>Allow MINTER_ROLE to mint new tokens</p>"},{"location":"contracts/token/Forta/#version","title":"version","text":"<pre><code>function version() external pure virtual returns (string)\n</code></pre> <p>Contract version</p> <p>Since FortaCommon is IVersioned, Forta is deployed in L1 and FortaBridgedPolygon in L2, we need to implement the interface with a method instead of immutable variable.</p> Name Type Description [0] string version of FORT deployed in L1"},{"location":"contracts/token/Forta/#__gap","title":"__gap","text":"<pre><code>uint256[50] __gap\n</code></pre>"},{"location":"contracts/token/FortaBridgedPolygon/","title":"FortaBridgedPolygon","text":""},{"location":"contracts/token/FortaBridgedPolygon/#fortabridgedpolygon","title":"FortaBridgedPolygon","text":"<p>This version of the Forta token is living on the child chain. That would be: - Polygon for production - Mumbai for testing</p> <p>When tokens are deposited from the root chain, the <code>childChainManagerProxy</code> will call the {deposit} function, which will mint corresponding tokens on the child chain. The total supply on the side chain is expected to match the amount of locked tokens on the parent chain.</p> <p>In order to bridge tokens back from the child chain to the parent chain, any user can call either the {withdraw} or the {withdrawTo} function. This will burn tokens here, emitting a burn event (Transfer event from the user to address(0)) in the process. This burn event is needed to trigger unlocking the corresponding tokens on the parent chain.</p>"},{"location":"contracts/token/FortaBridgedPolygon/#childchainmanagerproxy","title":"childChainManagerProxy","text":"<pre><code>address childChainManagerProxy\n</code></pre>"},{"location":"contracts/token/FortaBridgedPolygon/#depositonlybychildchainmanager","title":"DepositOnlyByChildChainManager","text":"<pre><code>error DepositOnlyByChildChainManager()\n</code></pre>"},{"location":"contracts/token/FortaBridgedPolygon/#constructor","title":"constructor","text":"<pre><code>constructor(address _childChainManagerProxy) public\n</code></pre>"},{"location":"contracts/token/FortaBridgedPolygon/#initialize","title":"initialize","text":"<pre><code>function initialize(address admin) public\n</code></pre> <p>Initializer method, access point to initialize inheritance tree.</p> Name Type Description admin address address that will be ADMIN_ROLE."},{"location":"contracts/token/FortaBridgedPolygon/#deposit","title":"deposit","text":"<pre><code>function deposit(address user, bytes depositData) external\n</code></pre> <p>To avoid token locked on the parent chains not being correctly represented on the child chain, this should NEVER revert (exception: _mint can revert if totalSupply() &lt;= _maxSupply()).</p> Name Type Description user address the destination address for the tokens. depositData bytes encoded data sent by the bridge."},{"location":"contracts/token/FortaBridgedPolygon/#withdraw","title":"withdraw","text":"<pre><code>function withdraw(uint256 amount) external\n</code></pre> <p>Burns tokens in L2 so Polygon's PoS bridge will unlock them in L1.</p> Name Type Description amount uint256 of tokens to send to L1"},{"location":"contracts/token/FortaBridgedPolygon/#withdrawto","title":"withdrawTo","text":"<pre><code>function withdrawTo(uint256 amount, address receiver) external\n</code></pre> <p>In order for a token holder on the child chain to be able to withdraw tokens to another address on the parent chain, this function will temporarily transfer the tokens to the address of the receiver on the parent chain so that the burn event is correct.</p> Name Type Description amount uint256 of tokens to send to L1 receiver address destination address in L1"},{"location":"contracts/token/FortaBridgedPolygon/#version","title":"version","text":"<pre><code>function version() external pure returns (string)\n</code></pre> <p>Contract version</p> <p>Since FortaCommon is IVersioned, Forta is deployed in L1 and FortaBridgedPolygon in L2, we need to implement the interface with a method instead of immutable variable.</p> Name Type Description [0] string version of FORT deployed in L2"},{"location":"contracts/token/FortaBridgedPolygon/#__gap","title":"__gap","text":"<pre><code>uint256[49] __gap\n</code></pre>"},{"location":"contracts/token/FortaCommon/","title":"FortaCommon","text":""},{"location":"contracts/token/FortaCommon/#fortacommon","title":"FortaCommon","text":"<p>Contract with the common functionality for both L1 FORT and L2 FortaBridgedPolygon. NOTE: Whitelisting functionality, used before the token was public, is deprecated. The whitelist was disabled setting whitelistDisabled = true, the current code keeps that storage layout for compatibility and removes whitelist code from _beforeTokenTransfer() to save gas. We are keeping the related roles to not break StakingEscrowFactory (already deployed), and the  _setRoleAdmin() in the initializer for historical context.</p>"},{"location":"contracts/token/FortaCommon/#admin_role","title":"ADMIN_ROLE","text":"<pre><code>bytes32 ADMIN_ROLE\n</code></pre>"},{"location":"contracts/token/FortaCommon/#whitelister_role","title":"WHITELISTER_ROLE","text":"<pre><code>bytes32 WHITELISTER_ROLE\n</code></pre>"},{"location":"contracts/token/FortaCommon/#whitelist_role","title":"WHITELIST_ROLE","text":"<pre><code>bytes32 WHITELIST_ROLE\n</code></pre>"},{"location":"contracts/token/FortaCommon/#deprecated_whitelistdisabled","title":"deprecated_whitelistDisabled","text":"<pre><code>bool deprecated_whitelistDisabled\n</code></pre>"},{"location":"contracts/token/FortaCommon/#constructor","title":"constructor","text":"<pre><code>constructor() internal\n</code></pre>"},{"location":"contracts/token/FortaCommon/#__fortacommon_init","title":"__FortaCommon_init","text":"<pre><code>function __FortaCommon_init(address admin) internal\n</code></pre> <p>Initializer method, access point to initialize inheritance tree.</p> <p>sets token name and symbol, permit init and RBAC structure.</p> Name Type Description admin address address for the ADMIN_ROLE of the token."},{"location":"contracts/token/FortaCommon/#_authorizeupgrade","title":"_authorizeUpgrade","text":"<pre><code>function _authorizeUpgrade(address newImplementation) internal virtual\n</code></pre> <p>Access control for the upgrade process</p>"},{"location":"contracts/token/FortaCommon/#setname","title":"setName","text":"<pre><code>function setName(address ensRegistry, string ensName) external\n</code></pre>"},{"location":"contracts/token/FortaCommon/#__gap","title":"__gap","text":"<pre><code>uint256[49] __gap\n</code></pre>"},{"location":"contracts/tools/Distributions/","title":"Distributions","text":""},{"location":"contracts/tools/Distributions/#distributions","title":"Distributions","text":""},{"location":"contracts/tools/Distributions/#balances","title":"Balances","text":"<pre><code>struct Balances {\n  mapping(uint256 =&gt; uint256) _balances;\n  uint256 _totalSupply;\n}\n</code></pre>"},{"location":"contracts/tools/Distributions/#balanceof","title":"balanceOf","text":"<pre><code>function balanceOf(struct Distributions.Balances self, uint256 subjectId) internal view returns (uint256)\n</code></pre>"},{"location":"contracts/tools/Distributions/#totalsupply","title":"totalSupply","text":"<pre><code>function totalSupply(struct Distributions.Balances self) internal view returns (uint256)\n</code></pre>"},{"location":"contracts/tools/Distributions/#mint","title":"mint","text":"<pre><code>function mint(struct Distributions.Balances self, uint256 subjectId, uint256 amount) internal\n</code></pre>"},{"location":"contracts/tools/Distributions/#burn","title":"burn","text":"<pre><code>function burn(struct Distributions.Balances self, uint256 subjectId, uint256 amount) internal\n</code></pre>"},{"location":"contracts/tools/Distributions/#transfer","title":"transfer","text":"<pre><code>function transfer(struct Distributions.Balances self, uint256 from, uint256 to, uint256 amount) internal\n</code></pre>"},{"location":"contracts/tools/Distributions/#signedbalances","title":"SignedBalances","text":"<pre><code>struct SignedBalances {\n  mapping(address =&gt; int256) _balances;\n  int256 _totalSupply;\n}\n</code></pre>"},{"location":"contracts/tools/Distributions/#balanceof_1","title":"balanceOf","text":"<pre><code>function balanceOf(struct Distributions.SignedBalances self, address account) internal view returns (int256)\n</code></pre>"},{"location":"contracts/tools/Distributions/#totalsupply_1","title":"totalSupply","text":"<pre><code>function totalSupply(struct Distributions.SignedBalances self) internal view returns (int256)\n</code></pre>"},{"location":"contracts/tools/Distributions/#mint_1","title":"mint","text":"<pre><code>function mint(struct Distributions.SignedBalances self, address account, int256 amount) internal\n</code></pre>"},{"location":"contracts/tools/Distributions/#burn_1","title":"burn","text":"<pre><code>function burn(struct Distributions.SignedBalances self, address account, int256 amount) internal\n</code></pre>"},{"location":"contracts/tools/Distributions/#transfer_1","title":"transfer","text":"<pre><code>function transfer(struct Distributions.SignedBalances self, address from, address to, int256 amount) internal\n</code></pre>"},{"location":"contracts/tools/ENSReverseRegistration/","title":"ENSReverseRegistration","text":""},{"location":"contracts/tools/ENSReverseRegistration/#ireverseregistrar","title":"IReverseRegistrar","text":""},{"location":"contracts/tools/ENSReverseRegistration/#addr_reverse_node","title":"ADDR_REVERSE_NODE","text":"<pre><code>function ADDR_REVERSE_NODE() external view returns (bytes32)\n</code></pre>"},{"location":"contracts/tools/ENSReverseRegistration/#ens","title":"ens","text":"<pre><code>function ens() external view returns (contract ENS)\n</code></pre>"},{"location":"contracts/tools/ENSReverseRegistration/#defaultresolver","title":"defaultResolver","text":"<pre><code>function defaultResolver() external view returns (address)\n</code></pre>"},{"location":"contracts/tools/ENSReverseRegistration/#claim","title":"claim","text":"<pre><code>function claim(address) external returns (bytes32)\n</code></pre>"},{"location":"contracts/tools/ENSReverseRegistration/#claimwithresolver","title":"claimWithResolver","text":"<pre><code>function claimWithResolver(address, address) external returns (bytes32)\n</code></pre>"},{"location":"contracts/tools/ENSReverseRegistration/#setname","title":"setName","text":"<pre><code>function setName(string) external returns (bytes32)\n</code></pre>"},{"location":"contracts/tools/ENSReverseRegistration/#node","title":"node","text":"<pre><code>function node(address) external pure returns (bytes32)\n</code></pre>"},{"location":"contracts/tools/ENSReverseRegistration/#ensreverseregistration","title":"ENSReverseRegistration","text":""},{"location":"contracts/tools/ENSReverseRegistration/#addr_reverse_node_1","title":"ADDR_REVERSE_NODE","text":"<pre><code>bytes32 ADDR_REVERSE_NODE\n</code></pre>"},{"location":"contracts/tools/ENSReverseRegistration/#setname_1","title":"setName","text":"<pre><code>function setName(address ensregistry, string ensname) internal\n</code></pre>"},{"location":"contracts/tools/FrontRunningProtection/","title":"FrontRunningProtection","text":""},{"location":"contracts/tools/FrontRunningProtection/#frontrunningprotection","title":"FrontRunningProtection","text":"<p>FrontRunningProtection class usef for commit-reveal schemes with deadline. We don't emit events to not broadcast the commits, devs will have to use the getter.</p>"},{"location":"contracts/tools/FrontRunningProtection/#_commits","title":"_commits","text":"<pre><code>mapping(bytes32 =&gt; uint256) _commits\n</code></pre>"},{"location":"contracts/tools/FrontRunningProtection/#commitnotready","title":"CommitNotReady","text":"<pre><code>error CommitNotReady()\n</code></pre>"},{"location":"contracts/tools/FrontRunningProtection/#commitalreadyexists","title":"CommitAlreadyExists","text":"<pre><code>error CommitAlreadyExists()\n</code></pre>"},{"location":"contracts/tools/FrontRunningProtection/#frontrunprotected","title":"frontrunProtected","text":"<pre><code>modifier frontrunProtected(bytes32 commit, uint256 duration)\n</code></pre> <p>Use it to enforce the need of a previous commit within duration Will consume the commit if we are within deadline</p> Name Type Description commit bytes32 the commit ID duration uint256 duration in seconds"},{"location":"contracts/tools/FrontRunningProtection/#getcommittimestamp","title":"getCommitTimestamp","text":"<pre><code>function getCommitTimestamp(bytes32 commit) external view returns (uint256)\n</code></pre> <p>Gets duration for a commit</p> Name Type Description commit bytes32 ID Name Type Description [0] uint256 commit duration or zero if not found"},{"location":"contracts/tools/FrontRunningProtection/#_frontruncommit","title":"_frontrunCommit","text":"<pre><code>function _frontrunCommit(bytes32 commit) internal\n</code></pre> <p>Saves commits deadline if commit does not exist</p> Name Type Description commit bytes32 id"},{"location":"scan-node/configure/","title":"Configure","text":""},{"location":"scan-node/configure/#pick-a-chain","title":"Pick a chain","text":"<p>Forta Network is currently scanning seven chains. Please make sure you have decided which chain you would like your node to scan before continuing to the next steps.</p> <ul> <li>Ethereum</li> <li>Polygon</li> <li>BNB Chain</li> <li>Avalanche</li> <li>Arbitrum</li> <li>Optimism</li> <li>Fantom</li> </ul> <p>You can find info about the per-week reward pool and previously distributed weekly rewards in this Rewards page, which might help you choose the chain to scan.</p>"},{"location":"scan-node/configure/#pick-a-provider","title":"Pick a provider","text":"<p>JSON-RPC API quality matters</p> <p>This is the most important step of configuring a Forta scan node as it has a critical impact on alerting and the SLA (performance) score.</p> <p>There are four types of JSON-RPC APIs which are configurable in <code>~/.forta/config.yml</code> after the next step and each can have a critical impact on the SLA score of the node.</p> <ul> <li><code>scan</code>: This is the API used as the source of the chain data (blocks, transactions) which are fed into running detection bots.</li> <li><code>trace</code>: This is usually the same as the scan API and it needs to support the <code>trace_block</code> method. It is not required for scanning every chain (currently only Ethereum and Fantom).</li> <li><code>jsonRpc</code>: This defaults to scan API by default. It allows bots to make extra JSON-RPC requests to check the chain state. Please make sure that this API can take load as some bots can be heavy.</li> <li><code>registry</code>: This API is different from the other APIs as it always needs to be a Polygon Mainnet JSON-RPC API. It is used for retrieving the list of assigned bots and the latest node releases for auto-upgrade purposes. It is used much more lightly compared to the other APIs listed here.</li> </ul> <p>We strongly recommend:</p> <ul> <li>running your own full node as the provider of the first three APIs,</li> <li>picking a private registry API to avoid disconnection from the network state.</li> </ul> <p>If you would like to run an Ethereum full node you can follow these steps. </p> <p>If you are not willing to run a full node, you can prefer Alchemy, Chainstack or others as your provider.</p>"},{"location":"scan-node/configure/#initialize-the-node","title":"Initialize the node","text":"<p>Initialization creates three things:</p> <ul> <li>A Forta node configuration directory at <code>~/.forta</code></li> <li>A default configuration file at <code>~/.forta/config.yml</code></li> <li>An Ethereum private key at <code>~/.forta/.keys/&lt;keyfile&gt;</code></li> </ul> <p>The private key is used for asserting your node's identity whenever required (e.g. publishing alerts from your scan node).</p> <p>You can run the <code>init</code> command by providing two values:</p> <ul> <li>Passphrase (required): <code>FORTA_PASSPHRASE</code> environment variable or the <code>--passphrase</code> flag</li> <li>Directory path (optional): <code>FORTA_DIR</code> environment variable or the <code>--dir</code> flag</li> </ul> <pre><code>forta init --passphrase &lt;your_passphrase&gt;\n</code></pre> <p>The output is:</p> <pre><code>Scanner address: 0xAAA8C491232cB65a65FBf7F36b71220B3E695AAA\n\nSuccessfully initialized at /home/username/.forta\n</code></pre> <p>If you need to find out your address later again, you can do <code>forta account address</code>.</p>"},{"location":"scan-node/configure/#configure-systemd","title":"Configure systemd","text":"<p>If <code>forta</code> ever stops running, it must be restarted. If you used a package installation method, there is a Forta systemd service that can be enabled and overridden with your passphrase and config directory environment variables.</p> <p>Please do not modify the original <code>forta.service</code> file and instead prefer the override recommended in this section. This is needed because the original file will be replaced next time you update <code>forta</code> through <code>yum</code> or <code>apt</code>.</p> <p>To override systemd service environment, you can set the variables in <code>/etc/systemd/system/forta.service.d/env.conf</code> like:</p> <pre><code>[Service]\nEnvironment=\"FORTA_DIR=&lt;your_forta_config_dir&gt;\"\nEnvironment=\"FORTA_PASSPHRASE=&lt;your_forta_passphrase&gt;\"\n</code></pre> <p>Alternative Systemd Override Path</p> <p>In our previous tests, it was confirmed that this approach works in Ubuntu, Debian, CentOS and Fedora. However, it has been reported by several node operators that it sometimes does not work as expected in some distributions. If you are not able to make this work using the suggested path above, you can try writing to <code>/lib/systemd/system/forta.service.d/env.conf</code> instead, as an alternative.</p>"},{"location":"scan-node/configure/#configure-chain-apis","title":"Configure Chain APIs","text":"<p>In your Forta directory, there now is a <code>config.yml</code> file. You must configure that file so that your scan node knows how to get its blockchain data.</p> <p>To let your scan node pull chain data, you need to provide a valid <code>scan.jsonRpc.url</code>.</p> <p>If you are scanning Ethereum mainnet, <code>trace.jsonRpc.url</code> must also be set as an endpoint that supports <code>trace_block</code> method. If you have your own Ethereum node that supports it (e.g. Erigon), you can use that node. If not, you can use an endpoint from a paid plan like Alchemy Growth plan or one of Chainstack's plans.</p> <p>JSON-RPC APIs</p> <p>Detection bots are able to call JSON-RPC APIs using the scan node's configured endpoints. By default, this is the <code>scan.jsonRpc.url</code> but one can separate bot-specific traffic by specifying a <code>jsonRpcProxy.jsonRpc.url</code>.</p> <p>Other chains</p> <p>If your node is scanning chains other than Ethereum mainnet, please check out the Scanning other chains section to see some examples.</p>"},{"location":"scan-node/configure/#http","title":"HTTP","text":"<p>Here is an example configuration to scan Ethereum mainnet using Alchemy Growth plan and HTTP endpoints:</p> <pre><code>chainId: 1\n\n# The scan settings are used to retrieve the transactions that are analyzed\nscan:\n  jsonRpc:\n    url: https://eth-mainnet.alchemyapi.io/v2/KEY\n\n# This is needed only for scanning Ethereum Mainnet and Fantom\ntrace:\n  jsonRpc:\n    url: https://eth-mainnet.alchemyapi.io/v2/KEY\n\n# Optional: Bots make extra requests to check the chain state. You can point\n# them to a different reliable API by using this. This defaults to `scan.jsonRpc.url`. \njsonRpcProxy:\n  jsonRpc:\n    url: http://different-api:8545\n</code></pre> <p>Another example configuration to scan Ethereum mainnet using your Erigon node's HTTP endpoint:</p> <pre><code>chainId: 1\n\nscan:\n  jsonRpc:\n    url: http://your-node:8545\n\ntrace:\n  jsonRpc:\n    url: http://your-node:8545\n\n# Defaulting to `scan.jsonRpc.url` if not set - the best option when running a node\n# jsonRpcProxy:\n#   jsonRpc:\n#     url: http://your-node:8545\n</code></pre>"},{"location":"scan-node/configure/#websocket","title":"WebSocket","text":"<p>If you have a WebSocket endpoint available from your full node or from your JSON-RPC provider (e.g. Alchemy), you can use that endpoint as <code>scan.jsonRpc.url</code>. This will ensure that your node will always fetch the latest block as fast as possible.</p> <p>Notifications</p> <p>The WebSocket endpoint needs to support block header notifications. Please check the output of <pre><code>docker logs forta-scanner -f\n</code></pre> to see any issues after starting the node.</p> <p>Proxy</p> <p>If you set the scan API as a WebSocket endpoint, please set <code>jsonRpcProxy.jsonRpc.url</code> as an HTTP JSON-RPC API. Your node may get a low score if you skip this!</p> <p>Example:</p> <pre><code>chainId: 1\n\nscan:\n  jsonRpc:\n    url: wss://&lt;websocket-api&gt;\n\ntrace:\n  jsonRpc:\n    url: wss://&lt;websocket-api&gt;\n\njsonRpcProxy:\n  jsonRpc:\n    url: https://&lt;http-api&gt;\n</code></pre>"},{"location":"scan-node/configure/#retries","title":"Retries","text":"<p>The block feed in the node always retries any request whenever <code>eth_getBlockByNumber</code>, <code>eth_getLogs</code> or <code>trace_block</code> does not work. The default retry interval is 8 seconds. While this is a sufficient retry interval on average for all chains, you can reduce this interval so your node catches up faster.</p> <p>Effect to score</p> <p>Reducing the retry interval can help you achieve a higher SLA score in case you have any concerns about your node's current score. Please keep in mind that small retry intervals can cause a bump in the number of total requests because of the increase in the number of retries.</p> <p>To reduce the retry interval to two seconds, you can add <code>retryIntervalSeconds</code> to the scan section of your config like:</p> <pre><code>scan:\n  retryIntervalSeconds: 2\n</code></pre>"},{"location":"scan-node/configure/#configure-registry-api","title":"Configure Registry API","text":"<p>Not optional</p> <p>Quality of this API is as important as the rest of the APIs configured for scanning while it is not used heavily. Please consider using a private API to avoid disconnection from the network state.</p> <p>There are a set of Forta smart contracts on Polygon, which allows finding out:</p> <ul> <li>the latest list of bots which a scan node should run</li> <li>the latest Forta node service Docker image release</li> </ul> <p>All Forta nodes are expected to run with the latest release and the latest list of the assigned bots. To be able to read these values, Forta nodes use <code>https://rpc.ankr.com/polygon</code> by default but this API can rate-limit your node. Please consider changing this to a free Polygon API with high availability, e.g. Alchemy Polygon API, Chainstack Polygon API, by adding the following configuration:</p> <pre><code>registry:\n  jsonRpc:\n    url: https://polygon-mainnet.g.alchemy.com/v2/&lt;your-alchemy-api-key&gt;\n</code></pre>"},{"location":"scan-node/configure/#scanning-other-chains","title":"Scanning other chains","text":"<p>Here are some configuration examples that use free APIs for chains other than Ethereum mainnet.</p> <p>Free APIs</p> <p>The performance of free APIs can be unpredictable as they have unknown rate limits. This can cause your node to have a low SLA score.</p>"},{"location":"scan-node/configure/#bnb-chain","title":"BNB Chain","text":"<p>You can choose from public BNB Chain endpoints at https://docs.binance.org/smart-chain/developer/rpc.html.</p> <pre><code>chainId: 56\n\nscan:\n  jsonRpc:\n    url: https://bsc-dataseed.binance.org/\n\ntrace:\n  enabled: false\n</code></pre>"},{"location":"scan-node/configure/#polygon","title":"Polygon","text":"<pre><code>chainId: 137\n\nscan:\n  jsonRpc:\n    url: https://polygon-rpc.com/\n\ntrace:\n  enabled: false\n</code></pre>"},{"location":"scan-node/configure/#avalanche","title":"Avalanche","text":"<pre><code>chainId: 43114\n\nscan:\n  jsonRpc:\n    url: https://api.avax.network/ext/bc/C/rpc\n\ntrace:\n  enabled: false\n</code></pre>"},{"location":"scan-node/configure/#arbitrum","title":"Arbitrum","text":"<pre><code>chainId: 42161\n\nscan:\n  jsonRpc:\n    url: https://arb1.arbitrum.io/rpc\n\ntrace:\n  enabled: false\n</code></pre>"},{"location":"scan-node/configure/#optimism","title":"Optimism","text":"<pre><code>chainId: 10\n\nscan:\n  jsonRpc:\n    url: https://mainnet.optimism.io\n\ntrace:\n  enabled: false\n</code></pre>"},{"location":"scan-node/configure/#fantom","title":"Fantom","text":"<pre><code>chainId: 250\n\nscan:\n  jsonRpc:\n    url: https://rpc.ftm.tools/\n\ntrace:\n  jsonRpc:\n    url: https://rpcapi-tracing.fantom.network/\n</code></pre>"},{"location":"scan-node/faq/","title":"First Asked Questions","text":""},{"location":"scan-node/faq/#q1-why-is-my-failing-nodes-sla-score-still-zero-after-restart","title":"Q1: Why is my failing node's SLA score still zero after restart?","text":"<p>SLA score is per hour and it is calculated after an hour is over. It could be that it is not calculated just yet.</p> <p>To verify that you have eliminated the problem, please visit the troubleshooting page and see the other questions on this page.</p> <p>Please also make sure that you are running the latest version of the Forta node. See the upgrade page for more details on how to keep your node automatically up-to-date.</p>"},{"location":"scan-node/faq/#q2-why-is-my-node-still-having-a-low-sla-score-after-changing-the-scan-api-from-free-api-x-to-free-api-y","title":"Q2: Why is my node still having a low SLA score after changing the scan API from free API X to free API Y?","text":"<p>Free APIs can enforce unexpected rate limits which might disallow your node from pulling chain data, at some point. Changing from one free API to another does not guarantee that your node will start having good performance.</p> <p>To avoid this kind of situations and loss of rewards, please reconsider the recommendations in the Pick a provider section.</p>"},{"location":"scan-node/faq/#q3-why-do-my-nodes-have-a-different-score-than-the-sla-api-on-the-pool-page","title":"Q3: Why do my nodes have a different score than the SLA API on the pool page?","text":"<p>The SLA API returns the last couple of hours by default, unless you specify a time range. The score shown on the top is the average of those hours.</p> <p>The pool page on Forta App and the scan node page on Forta App show the average of the past 168h (an epoch) continuously. As your node works better and time passes, this number improves. This is useful for the delegators to understand how reliable one pool is over the course of an epoch-long time window.</p> <p>You might sometimes find that even though you have fixed the problem with your node and the SLA API returns a higher score, the pool page still shows a lower score. These two numbers can differ due to the time range difference explained above.</p>"},{"location":"scan-node/faq/#q4-how-do-i-understand-what-forta-status-all-or-forta-status-show-all-format-oneline-is-showing-me","title":"Q4: How do I understand what <code>forta status all</code> or <code>forta status --show all --format oneline</code> is showing me?","text":"<p>Please visit the troubleshooting page to find out more.</p>"},{"location":"scan-node/faq/#q5-why-are-my-rewards-so-low-this-week","title":"Q5: Why are my rewards so low this week?","text":"<p>There are multiple factors that affect the rewards. While the allocated stake amount plays a large role in the proportion of rewards, having a low SLA score has a critical effect on the rewards. If the nodes do not perform well, it does not matter how much stake is deposited. Please see the formula for exact details.</p> <p>As an alternative, you can use the estimator to simplify the calculation:</p> <ol> <li>Visit the estimator spreadsheet.</li> <li>Make a copy of the file to your own Google Drive (File =&gt; Make a Copy).</li> <li>Use the input cells (the yellow ones) to play with different combinations of commission and stake and see the results in the output cells.</li> </ol> <p>Please note that this is just an estimation and may not reflect the exact reward amounts. It is for giving pool owners and delegators a sense of possible outcomes under different conditions.</p>"},{"location":"scan-node/faq/#q6-why-are-my-rewards-lower-after-accepting-delegation-to-my-pool","title":"Q6: Why are my rewards lower after accepting delegation to my pool?","text":"<p>You can validate the condition by using the estimator. Increasing the commission might help.</p>"},{"location":"scan-node/faq/#q7-why-is-forta-status-all-output-showing-a-not-found-error-in-chain-json-rpc-clientrequestblock-by-numbererror","title":"Q7: Why is <code>forta status all</code> output showing a \"not found\" error in <code>chain-json-rpc-client.request.block-by-number.error</code>?","text":"<p>This error occurs whenever the scan node is requesting the next block from the scan API but it is not available just yet. This error is safe to ignore and does not have any side effects on the SLA score.</p> <p>This is still displayed in order to capture whatever error is produced.</p>"},{"location":"scan-node/faq/#q8-why-is-the-forta-scanner-container-showing-many-not-found-errors","title":"Q8: Why is the forta-scanner container showing many \"not found\" errors?","text":"<p>The answer is same as Q3.</p>"},{"location":"scan-node/faq/#q9-why-is-the-forta-scanner-container-showing-many-error-invoking-bot-errors","title":"Q9: Why is the forta-scanner container showing many \"error invoking bot\" errors?","text":"<p>The bot seems to be having a problem while handling inputs given by the node. Please check first if there is a problem with the JSON-RPC API:</p> <pre><code>forta status all | grep service.json-rpc-proxy.api\n</code></pre> <p>If this looks good, then please make sure that your node has enough bandwidth to make outgoing requests (using the Speedtest CLI or similar).</p> <p>If everything looks good and the problem is still not resolved, then it is likely that the bot operates too slowly. There is not much you can do as the operator and this will not have an effect in your node's SLA score.</p>"},{"location":"scan-node/faq/#q10-how-can-i-register-my-node-to-another-pool","title":"Q10: How can I register my node to another pool?","text":"<p>Once a scan node is registered to a pool, it cannot be moved to another pool. You can disable it, withdraw the portion of the stake for it from the pool, deposit that stake on the other pool and register a new node.</p>"},{"location":"scan-node/faq/#q11-how-can-i-remove-a-node-from-my-pool","title":"Q11: How can I remove a node from my pool?","text":"<p>You cannot remove a node from a pool. You can keep it as a disabled node without any negative side effects.</p>"},{"location":"scan-node/faq/#q12-how-can-i-run-more-bots-on-my-node","title":"Q12: How can I run more bots on my node?","text":"<p>The network assigns bots to available nodes as required and the operators do not need to take any actions. Running more bots does not increase the rewards.</p>"},{"location":"scan-node/faq/#q13-why-cannot-i-withdraw-my-stake-even-though-i-initiated-a-withdrawal","title":"Q13: Why cannot I withdraw my stake even though I initiated a withdrawal?","text":"<p>There is a delay of 10 days between initiating a withdrawal and actually withdrawing.</p>"},{"location":"scan-node/faq/#q14-how-can-i-get-fort-on-polygon-mainnet","title":"Q14: How can I get FORT on Polygon Mainnet?","text":"<p>You need to first have FORT on your Ethereum Mainnet wallet and bridge it over to Polygon Mainnet. You can see this bridge tutorial if you are looking for steps.</p>"},{"location":"scan-node/faq/#q15-how-can-i-scan-another-network-with-my-node","title":"Q15: How can I scan another network with my node?","text":"<p>A scan node is registered to scan only one chain. It cannot switch to other chains and cannot scan multiple chains at once.</p>"},{"location":"scan-node/faq/#q16-how-can-i-recover-my-lost-node","title":"Q16: How can I recover my lost node?","text":"<p>The scan node private key does not own or control the staked FORT.</p> <p>You can safely disable the lost scan node from the pool and register a new one.</p> <ul> <li>Disable the lost node from your pool on the Forta App.</li> <li>Do <code>forta init --passphrase &lt;your-passphrase&gt;</code> to initialize a new node.</li> <li>Now you have a new <code>~/.forta</code> directory with a new private key.</li> <li>Copy your backed up config to <code>~/.forta/config.yml</code> or configure that file from scratch.</li> <li>Register the scan node.</li> </ul> <p>That's it!</p>"},{"location":"scan-node/install-forta-node/","title":"Install Forta node","text":""},{"location":"scan-node/install-forta-node/#installation","title":"Installation","text":"<p>The Forta scan node software is available for popular 64-bit Linux distributions using official Forta repositories. Package installation methods are verifiable (auto-verified during installation) and help you install required dependencies.</p>"},{"location":"scan-node/install-forta-node/#install-via-yum-centos-fedora-red-hat-enterprise-linux-etc","title":"Install via YUM (CentOS, Fedora, Red Hat Enterprise Linux etc.)","text":"<pre><code>$ sudo curl https://dist.forta.network/repositories/yum/Forta.repo -o /etc/yum.repos.d/Forta.repo -s\n$ sudo yum install forta\n</code></pre>"},{"location":"scan-node/install-forta-node/#install-via-apt-ubuntu-debian-etc","title":"Install via APT (Ubuntu, Debian etc.)","text":"<pre><code>$ sudo curl https://dist.forta.network/pgp.public -o /usr/share/keyrings/forta-keyring.asc -s\n$ echo 'deb [signed-by=/usr/share/keyrings/forta-keyring.asc] https://dist.forta.network/repositories/apt stable main' | sudo tee -a /etc/apt/sources.list.d/forta.list\n$ sudo apt-get update\n$ sudo apt-get install forta\n</code></pre>"},{"location":"scan-node/install-forta-node/#install-manually","title":"Install Manually","text":"<p>Install Docker (at least v20.10) </p> <p>Download the latest x86-64 release binary and install</p> <pre><code>$ sudo curl https://dist.forta.network/artifacts/forta -o /usr/local/bin/forta\n</code></pre> <p>Make the binary executable</p> <pre><code>$ sudo chmod 755 /usr/local/bin/forta\n</code></pre>"},{"location":"scan-node/introduction/","title":"Introduction","text":""},{"location":"scan-node/introduction/#welcome","title":"Welcome!","text":"<p>Welcome to the official scan node guide!</p> <p>This guide contains the steps and technical recommendations to help you set up your node successfully.</p> <p>For troubleshooting, please always refer to this documentation and check this guide regularly.</p> <p>If you have already read this guide before and you are here for troubleshooting, please check the First Asked Questions section to find out quick answers.</p> <p>For other information including rewards, please check out our node operators page if you have not visited yet.</p> <p>Please join our #node-support channel on Discord for discussions and the latest announcements!</p>"},{"location":"scan-node/introduction/#what-is-a-scan-node","title":"What is a scan node?","text":"<p>A Forta scan node, or scanner,</p> <ul> <li>runs detection bots and feeds them chain data,</li> <li>publishes the alerts generated by the detection bots,</li> <li>generates FORT rewards based on performance (SLA) score.</li> </ul> <p>The scan node software currently does this with the help of two features.</p>"},{"location":"scan-node/introduction/#docker-containers","title":"Docker containers","text":"<p>Forta node orchestrates containers of node services and assigned detection bots, manages their lifecycle, limits and networking.</p>"},{"location":"scan-node/introduction/#json-rpc-apis","title":"JSON-RPC APIs","text":"<p>Forta node uses a set of JSON-RPC APIs to pull chain data and read on-chain registries. These registries are smart contracts on Polygon Mainnet which know the latest list of bots to run and the latest scanner container version to use.</p>"},{"location":"scan-node/introduction/#how-is-the-performance-measured","title":"How is the performance measured?","text":"<p>Forta node sends reports that contain alerts and operational parameters. These outputs are used periodically to measure the quality and performance of a node.</p> <p>The score calculated as a product of this process is called an SLA score. You can find more about this later on the SLA page.</p>"},{"location":"scan-node/introduction/#how-to-achieve-the-best-performance","title":"How to achieve the best performance?","text":"<p>To scan blockchains successfully and generate higher rewards, the scanners need to</p> <ul> <li>have enough resources in the host machine,</li> <li>point to high quality JSON-RPC APIs,</li> <li>be able to load the latest list of detection bot assignments,</li> <li>have enough bandwidth available to pull Docker containers and publish alerts,</li> <li>run the latest container version of the software.</li> </ul> <p>Let's start with host machine setup in the next section!</p>"},{"location":"scan-node/machine-setup/","title":"Machine setup","text":""},{"location":"scan-node/machine-setup/#resources","title":"Resources","text":"<p>You can use any machine from any cloud hosting provider or your very own physical computer, as long as the option you choose is able to satisfy the resource requirements.</p> <p>The following are the host requirements for running one Forta scan node.</p> <ul> <li>64-bit Linux distribution</li> <li>CPU with 4+ cores</li> <li>16GB RAM</li> <li>Connection to internet</li> <li>Docker v20.10+</li> <li>100GB SSD</li> </ul> <p>Running multiple nodes</p> <p>If you would like to use a big machine to run multiple scan nodes, please isolate each node by using virtual machines and dedicate the resources listed above to each node.</p> <p>Trying to run multiple scan nodes in one machine without isolation can cause loss of rewards.</p> <p>Security</p> <p>Forta scan node software uses isolation techniques to prevent detection bot code from executing malicious actions. Please make sure you take extra measures and strengthen your host machines:</p> <ul> <li>Implement iptables rules to disallow access to sensitive subnetworks.</li> <li>Do not equip your machines with strong cloud privileges.</li> </ul>"},{"location":"scan-node/machine-setup/#synchronize-system-time","title":"Synchronize system time","text":"<p>To produce correct timestamps on the alerts and avoid authorization problems at the time of publishing alerts, you must ensure at all times that the system time is correct. If the system time is not correct, your node will fail to publish alerts and may generate no rewards as a result.</p> <p>We suggest using <code>systemd-timesyncd</code> which is widely available and sufficient as a time synchronization daemon. After started, it will periodically synchronize the system time in background.</p> <p>To enable, <code>systemd-timesyncd</code> and check the result, you can do: <pre><code>$ sudo systemctl enable systemd-timesyncd\n$ sudo systemctl start systemd-timesyncd\n$ timedatectl status\n               Local time: Tue 2022-01-01 17:00:00 -03\n           Universal time: Tue 2022-01-01 20:00:00 UTC\n                 RTC time: Tue 2022-01-01 20:00:00\n                Time zone: America/Argentina/Buenos_Aires (-03, -0300)\nSystem clock synchronized: yes\n              NTP service: active  &lt;------------------- (it worked)\n          RTC in local TZ: no\n</code></pre></p>"},{"location":"scan-node/machine-setup/#install-and-configure-docker","title":"Install and Configure Docker","text":"<p>Install Docker (at least v20.10) </p> <p>Add a file called <code>daemon.json</code> to your <code>/etc/docker</code> directory with the following contents:</p> <pre><code>{\n   \"default-address-pools\": [\n        {\n            \"base\":\"172.17.0.0/12\",\n            \"size\":16\n        },\n        {\n            \"base\":\"192.168.0.0/16\",\n            \"size\":20\n        },\n        {\n            \"base\":\"10.99.0.0/16\",\n            \"size\":24\n        }\n    ]\n}\n</code></pre> <p>Avoid networking conflicts</p> <p>Please confirm these network ranges don't conflict with your node's network, especially if you use VPC peering, VPNs, or other non-trivial networking settings.</p> <p>Restart docker with <code>systemctl restart docker</code></p> <p>Ensure docker is running.  You can run <code>docker ps</code> and you should not get any errors and see a list of header columns.</p> <p>Run Docker as a non-root user</p> <p>To run docker as a non-root user, do the following:</p> <p>Add the docker group (it may already exist)</p> <pre><code>sudo groupadd docker\n</code></pre> <p>Add your user to that group.</p> <pre><code>sudo usermod -aG docker your-user\n</code></pre> <p>You must exit and login again to take effect</p> <p>Make sure Docker is running</p> <p>Once <code>docker ps</code> gives you a list of headers, continue to the next section.</p>"},{"location":"scan-node/miscellaneous/","title":"Miscellaneous","text":""},{"location":"scan-node/miscellaneous/#run-an-ethereum-full-node","title":"Run an Ethereum Full Node","text":"<p>Only for Ethereum Mainnet</p> <p>This section was prepared only for Forta node operators who would like to point their Forta nodes to their own Ethereum Mainnet nodes. If your Forta node is scanning chains other than Ethereum Mainnet, you can safely ignore this section altogether.</p> <p>If you are planning on setting up a Forta node, your own full node is the most reliable option as a provider to your Forta node and we strongly recommend it.</p> <p>The final command to run the Ethereum node will be:</p> <pre><code>erigon-rpcdaemon \\\n  --http.vhosts '*' --http.port 8545 \\\n  --http.addr 0.0.0.0 --http.corsdomain '*' \\\n  --http.api 'eth,net,web3,trace' --private.api.addr=localhost:9090 \\\n  --authrpc.addr 0.0.0.0 --authrpc.jwtsecret &lt;secret&gt;\n\nerigon --private.api.addr=localhost:9090\n</code></pre> <p>Ethereum node access</p> <p>Be sure to set <code>--http.vhosts</code> to allow hostname access, and enable <code>eth,net,web3</code> HTTP APIs. Note that <code>trace</code> is only applicable for Ethereum mainnet.</p>"},{"location":"scan-node/miscellaneous/#the-merge","title":"The Merge","text":"<p>To make your Ethereum node support The Merge, your Erigon node (Execution Layer - EL) will need to be run with a beacon node (Consensus Layer - CL). A few consensus layer clients are listed below:</p> <ul> <li>Prysm</li> <li>Lighthouse</li> <li>Lodestar</li> <li>Nimbus</li> <li>Teku</li> </ul> <p>For more information on versions of these clients, please see the Ethereum Merge announcement blog post.</p> <p>You can run the consensus layer client on the same machine as the execution layer client (Erigon) by default Erigon's engine API listens on localhost. If you are running CL client on a different machine than Erigon, you will need to configure the Erigon node to connect to the CL client by passing <code>--authrpc.addr 0.0.0.0</code> and <code>--authrpc.vhosts &lt;CL host&gt;</code>.</p>"},{"location":"scan-node/miscellaneous/#erigon-node-execution-layer-client","title":"Erigon node (execution layer client)","text":"<p>Upgrade your node to the latest \"stable\" version of Erigon <code>2022.08.03-alpha</code>.</p> <p>If you are running Erigon directly from the binary (and not using docker-compose), you will need to pass <code>--authrpc.jwtsecret &lt;secret&gt;</code>. For more information see Erigon documentation.</p> <p>If you are running Erigon using docker-compose, you don't have to pass any extra flags for data dir or JWT secret since these are already configured in the docker-compose file.</p>"},{"location":"scan-node/miscellaneous/#prysm-consensus-layer-client","title":"Prysm (consensus layer client)","text":"<p>Upgrade your node to the latest \"stable\" version of Prysm <code>v3.0.0</code>.</p>"},{"location":"scan-node/miscellaneous/#use-docker","title":"Use Docker","text":"<p>You can install Prysm and run a beacon node using Docker by following Prysm Docker.</p> <p>Architecture Constraints</p> <p>Running with docker might not work on Linux ARM64.</p>"},{"location":"scan-node/miscellaneous/#install-binary","title":"Install binary","text":"<p>Alternatively, you can install Prysm directly by downloading the Prysm client binary and making it executable.</p> <p>You can run your beacon node with the following commands:</p> <pre><code>mkdir prysm &amp;&amp; cd prysm\n\ncurl https://raw.githubusercontent.com/prysmaticlabs/prysm/master/prysm.sh \\\n  --output prysm.sh &amp;&amp;\\ \n  chmod +x prysm.sh\n</code></pre>"},{"location":"scan-node/miscellaneous/#follow-installation-docs","title":"Follow installation docs","text":"<p>As yet another option, you can run a beacon node using Prysm by following Prysm Beacon Node.</p> <p>You will need to pass <code>--jwt-secret=&lt;path_to_erigon_jwt_hex&gt;</code> to the beacon node. It doesn't require <code>--suggested-fee-recipient</code> flag unless you are running a validator.</p> <p>Additionally, you can pass the <code>--slots-per-archive-point</code> flag to the beacon node. A lower number helps improve the CL API performance while increasing the storage cost. For more information on slots per archive point, please refer to Run an archival node section in Prysm docs.</p> <p>After running with any method mentioned above, you should be able to see the beacon node running and syncing. This usually takes a couple of days, but it can take longer depending on your network and hardware specs.</p>"},{"location":"scan-node/monitor/","title":"Monitor","text":""},{"location":"scan-node/monitor/#sla","title":"SLA","text":"<p>The SLA score is a performance score calculated by using the reports the scan nodes are sending. It is used in calculating rewards and making bot assignments. To learn more about how it is calculated, please visit the SLA page.</p> <p>The largest factor in SLA calculation is the number of the latest block scanned.</p> <p>To view your scan node's uptime and SLA simply copy and paste</p> <pre><code>https://app.forta.network/scan-node/{enter-your-scan-node-address-here}\n</code></pre> <p>into your browser's search bar.</p> <p></p> <p>You can use the SLA API for more details insights.</p> <p>Please note that the number in Forta App can differ from what SLA API returns because of time range differences (see Q3 in FAQ).</p>"},{"location":"scan-node/monitor/#prometheus","title":"Prometheus","text":"<p>The health reports presented in the Health section are transformed to metrics and exposed from a Prometheus handler, by the running <code>forta</code> process. This makes it possible to collect and observe these metrics by following these steps:</p>"},{"location":"scan-node/monitor/#1-configure-the-prometheus-port-on-the-node-optional","title":"1. Configure the Prometheus port on the node (Optional)","text":"<p>This step is optional and the default value is 9107. You can configure to a custom value (e.g. 3333) by adding this to your node config:</p> <pre><code>prometheus:\n  port: 3333\n</code></pre>"},{"location":"scan-node/monitor/#2-start-a-prometheus-container","title":"2. Start a Prometheus container","text":"<p>Create a <code>prometheus.yml</code> file like</p> <pre><code>global:\n  scrape_interval:     10s\n  evaluation_interval: 10s\nscrape_configs:\n  - job_name: 'forta'\n    static_configs:\n      - targets: [localhost:9107]\n</code></pre> <p>and then do</p> <pre><code>docker run --rm --network host -p 9090:9090 -v $(pwd)/prometheus.yml:/etc/prometheus/prometheus.yml prom/prometheus\n</code></pre>"},{"location":"scan-node/monitor/#3-start-a-grafana-container","title":"3. Start a Grafana container","text":"<pre><code>docker run --rm --network host -p 3000:3000 grafana/grafana-enterprise\n</code></pre>"},{"location":"scan-node/monitor/#4-make-a-grafana-dashboard","title":"4. Make a Grafana dashboard","text":"<p>Visit the Grafana UI at http://localhost:3000 and then open \"Connections\" from the menu on the left. You can add your Prometheus container as the source of your Forta node. Find \"Prometheus\" from among the data sources and add new connection.</p> <p>Then, visit \"Dashboards\" from the menu on the left, click on \"New\" and then \"Import\".</p> <p>You can import this dashboard export to get started!</p> <p></p>"},{"location":"scan-node/monitor/#interpreting-the-metrics","title":"Interpreting the metrics","text":"<p>The metrics mostly represent the time elapsed since the last action.</p> <p>Most of the metrics have an internal meaning so let's list them down with their tags and explain what they actually signal to us:</p>"},{"location":"scan-node/monitor/#forta_json_rpc_activity_seconds","title":"forta_json_rpc_activity_seconds","text":"<p>This is the first layer of streaming block data to the bots. The values represent the delay since last activity.</p> <ul> <li><code>block_by_number</code> (scan API request)</li> <li><code>trace_block</code>: (trace API request - hide/ignore unless scanning Ethereum or Fantom)</li> </ul>"},{"location":"scan-node/monitor/#forta_stream_activity_seconds","title":"forta_stream_activity_seconds","text":"<p>This is the second layer of streaming block data to the bots. The values represent the delay since last activity.</p> <ul> <li><code>tx_stream_block</code></li> <li><code>tx_stream_tx</code></li> </ul>"},{"location":"scan-node/monitor/#forta_analyzer_activity_seconds","title":"forta_analyzer_activity_seconds","text":"<p>This is the third layer of streaming block data to the bots. It is also the final layer where the outputs from the bots are collected. The values represent the delay since last activity.</p> <p>(Combiner/combination means inputting previous alerts to bots.)</p> <ul> <li><code>block_analyzer_input</code></li> <li><code>block_analyzer_output</code></li> <li><code>tx_analyzer_input</code></li> <li><code>tx_analyzer_output</code></li> <li><code>combiner_alert_analyzer_input</code></li> <li><code>combiner_alert_analyzer_output</code></li> </ul>"},{"location":"scan-node/monitor/#forta_publisher_activity_seconds","title":"forta_publisher_activity_seconds","text":"<p>This is the layer where the alerts are sent out from the node. The values represent the delay since last activity.</p> <ul> <li><code>batch_publish_attempt</code>: Checking conditions to send an alert batch</li> <li><code>batch_skip</code>: Skipping to send a batch because it is not necessary (hide/ignore if very large)</li> <li><code>batch_publish</code>: Sending an alert batch</li> <li><code>metrics_flush</code>: Sending bot and system metrics inside the batch</li> </ul>"},{"location":"scan-node/monitor/#forta_inspector","title":"forta_inspector","text":"<p>This metric includes various inspector values visible in the <code>forta status all | grep inspector</code> output.</p> <p>Values:</p> <ul> <li><code>1</code>: OK</li> <li><code>-1</code>: Not OK</li> <li><code>-3</code>: Unknown/irrelevant</li> </ul>"},{"location":"scan-node/monitor/#forta_bot_registry_activity_seconds","title":"forta_bot_registry_activity_seconds","text":"<p>This metric is relevant to checking the list of assigned bots. The values represent the delay since last activity.</p> <ul> <li><code>check</code>: A bot registry check attempt</li> <li><code>change_detected</code>: Either a change in assignments were detected or synchronization was forced (e.g. after 5m)</li> </ul>"},{"location":"scan-node/monitor/#forta_active_bots","title":"forta_active_bots","text":"<p>The values represent the counts.</p> <ul> <li><code>total</code>: How many bots the node is currently doing I/O with</li> <li><code>lagging</code>: How many bots are slow at processing inputs and are missing newer inputs</li> </ul>"},{"location":"scan-node/monitor/#errors","title":"Errors","text":"<p>Tags from various different metrics represent visible errors.</p> <p>Values:</p> <ul> <li><code>0</code>: No error visible</li> <li><code>1</code>: An error is visible</li> </ul> <p>Tags:</p> <ul> <li><code>forta_bot_registry_errors</code> - <code>check</code>: Checking the list of assigned bots</li> <li><code>forta_json_rpc_errors</code> - <code>trace_block</code>: Trace API requests</li> <li><code>forta_publisher_errors</code> - <code>batch_publish</code>: Publishing alert batches</li> <li><code>forta_telemetry_errors</code> - <code>bot_logs_sync</code>: Sending bot container logs</li> <li><code>forta_telemetry_errors</code> - <code>telemetry_sync</code>: Sending to public telemetry handler</li> <li><code>forta_telemetry_errors</code> - <code>custom_telemetry_sync</code>: Sending to custom telemetry handler (if specified in config)</li> </ul>"},{"location":"scan-node/monitor/#telemetry","title":"Telemetry","text":"<p>The health reports presented in the Health section are forwarded to Forta telemetry handler every 5 minutes, after sensitive data is obfuscated (e.g. API URLs that contain keys). This is useful for core developers to understand what is going on with scan nodes and resolve issues.</p> <p>You can specify a custom telemetry handler in the <code>config.yml</code> file if you would like to receive these health reports from your nodes every minute:</p> <pre><code>telemetry:\n  customUrl: http://&lt;enter-your-telemetry-handler-url-here&gt;\n</code></pre> <p>The forwarded content is a gzipped JSON which is similar to the <code>forta status --show all --format json</code> output.</p> <pre><code>[\n  ...\n  {\n    \"name\": \"forta.container.forta-scanner.service.agent-pool.agents.total\",\n    \"status\": \"ok\",\n    \"details\": \"14\"\n  },\n  {\n    \"name\": \"forta.container.forta-scanner.service.block-analyzer.event.input.time\",\n    \"status\": \"ok\",\n    \"details\": \"2022-08-17T10:36:20Z\"\n  },\n  {\n    \"name\": \"forta.container.forta-scanner.service.block-analyzer.event.output.time\",\n    \"status\": \"ok\",\n    \"details\": \"2022-08-17T10:36:20Z\"\n  },\n  {\n    \"name\": \"forta.container.forta-scanner.service.block-feed.last-block\",\n    \"status\": \"info\",\n    \"details\": \"15358230\"\n  }\n  ...\n]\n</code></pre>"},{"location":"scan-node/register/","title":"Register","text":""},{"location":"scan-node/register/#staking","title":"Staking","text":"<p>All nodes need to be registered to run within a specific pool. Scan nodes in a pool become operational in the network when their pool has enough stake i.e. FORT token allocation.</p> <p>Please visit the pool management guide to find out how you can create, manage and stake on a pool. If you have not created a pool so far, please make sure you have created one. The pool you create needs to scan the same chain as the scan node you are about to register.</p> <p>All pools require stake</p> <p>It is not possible to register a new node without staking more on it to satisfy the minimum first. Scan nodes in the unstaked or understaked pools will not be assigned any detection bots and will not generate any rewards.</p> <p>Why do scan nodes require stake?</p> <p>Forta Network ensure network reliability by enforcing two main mechanisms that use the stake:</p> <ul> <li>Rewarding: Node operators are incentivized with rewards to ensure that their Forta nodes are running with good health and as expected. The stake amount is used in reward calculations.</li> <li>Slashing: Node operators are discouraged from harmful actions. Upon detection, they lose rewards and a specific portion is removed from the deposited pool stake. This can cause the staked amount to go under minimum required and all nodes in the pool to enter into disabled state.</li> </ul> <p>Please see the formula and the slashing policy if you are interested in more details.</p>"},{"location":"scan-node/register/#registration","title":"Registration","text":"<p>Each scan node has an Ethereum private key that makes some features possible:</p> <ul> <li>Receiving detection bots to run</li> <li>Asserting authority on the outputted alerts</li> <li>Identification for rewards and slashing</li> </ul> <p>The private key for the scan node is generated at the <code>forta init</code> step. Please prefer continuing with this private key and do not replace it with your custom private key in order to avoid confusion and security risks.</p> <p>Use correct chain ID</p> <p>Make sure you have set the <code>chainId</code> in your config.yml correctly before registering your node. Your scan node can be registered only once and to scan a specific chain.</p>"},{"location":"scan-node/register/#forta-app","title":"Forta App","text":"<ul> <li>doing <code>forta authorize pool --passphrase &lt;your-passphrase&gt; --id &lt;your-pool-id&gt;</code>,</li> <li>copying the token over to Forta App as described in the pool management page of the docs.</li> </ul>"},{"location":"scan-node/register/#polygonscan","title":"Polygonscan","text":"<ul> <li>do <code>forta authorize pool --passphrase &lt;your-passphrase&gt; --id &lt;your-pool-id&gt; --polygonscan</code>,</li> <li>visit the <code>registerScannerNode</code> method,</li> <li>click on \"Connect to Web3\" on the top and connect your wallet,</li> <li>copy the values from the first step, click on \"Write\".</li> </ul>"},{"location":"scan-node/run/","title":"Run","text":""},{"location":"scan-node/run/#start-docker","title":"Start Docker","text":"<p>Ensure Docker is running by using the docker command <code>docker ps</code>.  If it is not running, start docker before running Forta.</p>"},{"location":"scan-node/run/#start-forta","title":"Start Forta","text":""},{"location":"scan-node/run/#start-forta-via-systemd","title":"Start Forta via systemd","text":"<p>Run the systemd service to start Forta</p> <pre><code>sudo systemctl daemon-reload\nsudo systemctl enable forta\nsudo systemctl start forta\n</code></pre>"},{"location":"scan-node/run/#start-forta-manually","title":"Start Forta manually","text":"<p>Run the <code>forta run</code> command to start processing blocks.</p> <pre><code>forta run --passphrase &lt;your_passphrase&gt;\n</code></pre> <p>Please prefer the systemd option to handle restarts better.</p>"},{"location":"scan-node/run/#verify-execution","title":"Verify execution","text":"<p>Run <code>forta status</code> command to see how your scanner is doing. As more services start, this status output will be dynamically updated. If you see any yellows or reds, please check the error messages, your config and your machine's network connectivity. If you can't make any sense of it, please let us know.</p> <p>You can also view the forta-scanner logs for batches of alerts.</p> <pre><code>docker logs -f forta-scanner\n</code></pre> <p>Bot Assignments</p> <p>Your scan node might not have any bots assigned.  This is okay.  As bots are added to the network, the network will assign bots to your node.</p> <p>To see a list of bots that the node is running, use this command.</p> <pre><code>docker ps | grep forta-agent\n</code></pre>"},{"location":"scan-node/troubleshoot/","title":"Troubleshoot","text":""},{"location":"scan-node/troubleshoot/#health","title":"Health","text":"<p>The Forta node CLI (<code>forta</code>) has a <code>status</code> command which displays a list of human friendly health reports.</p> <pre><code>forta.container.forta-inspector.summary\n\u2b24 ok\n\nforta.container.forta-json-rpc.summary\n\u2b24 ok\n\nforta.container.forta-public-api.summary\n\u2b24 ok\n\nforta.container.forta-scanner.summary\n\u2b24 ok: at block 17455932.\n\nforta.container.forta-supervisor.summary\n\u2b24 ok: all 6 service containers are running.\n</code></pre> <p>Upon extending this command with <code>--show all --format oneline</code> or by simply using <code>status all</code>, it returns a full list of statuses from the trackers internally used.</p> <p>Values</p> <p>Positive numbers mean a successful result. <code>-1</code> is failure and <code>-3</code> means unknown/irrelevant. The ones that are <code>-1</code> can effect the SLA score and the effect of this can be visible from <code>inspector.expected-score</code> report value (it would be zero).</p> <p>Let's visit some of the useful ones:</p>"},{"location":"scan-node/troubleshoot/#inspector","title":"<code>inspector</code>","text":"<p>These are the results of the inspections made in the node periodically. It runs once at startup and then approximately every 10 minutes.</p> <p>For chains other than Ethereum Mainnet, <code>is-eth2</code> is irrelevant.</p> <ul> <li><code>api.refs.valid</code>: Scan, trace and proxy should have the same hash for the same API call. This tells about the configuration consistency.</li> <li><code>expected-score</code>: This is the expected inspection score according to the node's knowledge. The inspection score has a critical effect on your node's SLA score.</li> <li><code>proxy-api</code>:  Should have positive numbers.</li> <li><code>registry-api</code>: This tells if your node is able to load the detection bots. This might affect your SLA score.</li> <li><code>resources.memory</code>: Total memory must be at least 16 GB and available must be at least 2 GB.</li> <li><code>scan-api</code>:  Should have positive numbers.</li> <li><code>trace-api</code>:  Should have positive numbers if scanning chains with ID 1 and 250.</li> </ul>"},{"location":"scan-node/troubleshoot/#chain-json-rpc-client","title":"<code>chain-json-rpc-client</code>","text":"<p><code>request.block-by-number.error</code> can sometimes say \"not found\". This is because the next block is requested and it is just yet not available. This is okay. We just need to surface whatever error is happening.</p> <p>If it's an error different than a periodically appearing and disappearing \"not found\" (or similar), then it is likely that your scan API does not work. Please revisit this section in this case.</p>"},{"location":"scan-node/troubleshoot/#trace-json-rpc-client","title":"<code>trace-json-rpc-client</code>","text":"<p><code>request.trace-block.error</code> can rarely fail when it is different from the scan API and they are slightly out of sync (i.e. the trace API does not have the block yet). It safe to ignore unless the error looks like a very specific one and is persistent.</p>"},{"location":"scan-node/troubleshoot/#publisher","title":"<code>publisher</code>","text":"<ul> <li><code>event.batch-publish-attempt.time</code>: This \"attempt\" should just look recent.</li> <li><code>event.batch-publish.time</code>: This should not look much older than 1m if there are bots. If there are no bots, then this period is 15m.</li> <li><code>event.batch-publish.error</code>: This error is a sign that your node is failing to deliver alerts and will have a low SLA score.</li> </ul>"},{"location":"scan-node/troubleshoot/#bot-registry","title":"<code>bot-registry</code>","text":"<ul> <li><code>event.checked.time</code>: Should not be much longer than 10m. If it is, then please check your bandwidth.</li> <li><code>event.checked.error</code>: This is a sign that your node is failing to load the bot list or auto-upgrade. It is okay if an error appears sometimes. Make sure that it is not persistent and visit this section in case it is persistent.</li> </ul> <pre><code>$ forta status all\n\u2b24 ok | forta.container.forta-inspector | running\n\u2b24 info | forta.container.forta-inspector.service.inspector.api.refs.valid | 1\n\u2b24 info | forta.container.forta-inspector.service.inspector.expected-score | 1\n\u2b24 ok | forta.container.forta-inspector.service.inspector.last-error\n\u2b24 info | forta.container.forta-inspector.service.inspector.network.access.outbound | 1\n\u2b24 info | forta.container.forta-inspector.service.inspector.network.speed.download | -3\n\u2b24 info | forta.container.forta-inspector.service.inspector.network.speed.upload | -3\n\u2b24 info | forta.container.forta-inspector.service.inspector.proxy-api.accessible | 1\n\u2b24 info | forta.container.forta-inspector.service.inspector.proxy-api.chain-id | 1\n\u2b24 info | forta.container.forta-inspector.service.inspector.proxy-api.history-support | 1\n\u2b24 info | forta.container.forta-inspector.service.inspector.proxy-api.is-eth2 | 1\n\u2b24 info | forta.container.forta-inspector.service.inspector.proxy-api.module.eth | 1\n\u2b24 info | forta.container.forta-inspector.service.inspector.proxy-api.module.net | 1\n\u2b24 info | forta.container.forta-inspector.service.inspector.proxy-api.module.web3 | 1\n\u2b24 info | forta.container.forta-inspector.service.inspector.proxy-api.offset.scan.max | 367\n\u2b24 info | forta.container.forta-inspector.service.inspector.proxy-api.offset.scan.mean | 182.5\n\u2b24 info | forta.container.forta-inspector.service.inspector.proxy-api.offset.scan.median | 182.5\n\u2b24 info | forta.container.forta-inspector.service.inspector.proxy-api.offset.scan.samples | 2\n\u2b24 info | forta.container.forta-inspector.service.inspector.registry-api.accessible | 1\n\u2b24 info | forta.container.forta-inspector.service.inspector.registry-api.assignments | 1\n\u2b24 info | forta.container.forta-inspector.service.inspector.registry-api.ens | 1\n\u2b24 info | forta.container.forta-inspector.service.inspector.resources.cpu.benchmark | 751051706\n\u2b24 info | forta.container.forta-inspector.service.inspector.resources.cpu.usage | 9.571788413844256\n\u2b24 info | forta.container.forta-inspector.service.inspector.resources.memory.available | 4509470720\n\u2b24 info | forta.container.forta-inspector.service.inspector.resources.memory.total | 16419328000\n\u2b24 info | forta.container.forta-inspector.service.inspector.resources.storage.available | 1420687622144\n\u2b24 info | forta.container.forta-inspector.service.inspector.resources.storage.total | 538439368704\n\u2b24 info | forta.container.forta-inspector.service.inspector.scan-api.accessible | 1\n\u2b24 info | forta.container.forta-inspector.service.inspector.scan-api.chain-id | 1\n\u2b24 info | forta.container.forta-inspector.service.inspector.scan-api.is-eth2 | 1\n\u2b24 info | forta.container.forta-inspector.service.inspector.scan-api.module.eth | 1\n\u2b24 info | forta.container.forta-inspector.service.inspector.scan-api.module.net | 1\n\u2b24 info | forta.container.forta-inspector.service.inspector.trace-api.accessible | 1\n\u2b24 info | forta.container.forta-inspector.service.inspector.trace-api.chain-id | 1\n\u2b24 info | forta.container.forta-inspector.service.inspector.trace-api.is-eth2 | 1\n\u2b24 info | forta.container.forta-inspector.service.inspector.trace-api.supported | 1\n\u2b24 ok | forta.container.forta-inspector.summary\n\u2b24 ok | forta.container.forta-json-rpc | running\n\u2b24 ok | forta.container.forta-json-rpc.service.json-rpc-proxy.api\n\u2b24 ok | forta.container.forta-json-rpc.summary\n\u2b24 ok | forta.container.forta-jwt-provider | running\n\u2b24 ok | forta.container.forta-jwt-provider.service.jwt-provider.api\n\u2b24 ok | forta.container.forta-nats | running\n\u2b24 ok | forta.container.forta-public-api | running\n\u2b24 ok | forta.container.forta-public-api.service.public-api-proxy.api\n\u2b24 ok | forta.container.forta-public-api.summary\n\u2b24 ok | forta.container.forta-scanner | running\n\u2b24 info | forta.container.forta-scanner.service.alert-feed.last-alert\n\u2b24 ok | forta.container.forta-scanner.service.block-analyzer.event.input.time | 2023-06-11T09:19:05Z\n\u2b24 unknown | forta.container.forta-scanner.service.block-analyzer.event.output.time\n\u2b24 info | forta.container.forta-scanner.service.block-feed.last-block | 17455940\n\u2b24 ok | forta.container.forta-scanner.service.chain-json-rpc-client.request.block-by-number.error\n\u2b24 ok | forta.container.forta-scanner.service.chain-json-rpc-client.request.block-by-number.time | 2023-06-11T09:19:24Z\n\u2b24 ok | forta.container.forta-scanner.service.chain-json-rpc-client.request.get-transaction-receipt.error\n\u2b24 unknown | forta.container.forta-scanner.service.chain-json-rpc-client.request.get-transaction-receipt.time\n\u2b24 ok | forta.container.forta-scanner.service.chain-json-rpc-client.request.trace-block.error\n\u2b24 unknown | forta.container.forta-scanner.service.chain-json-rpc-client.request.trace-block.time\n\u2b24 unknown | forta.container.forta-scanner.service.combiner-alert-analyzer.event.input.time\n\u2b24 unknown | forta.container.forta-scanner.service.combiner-alert-analyzer.event.output.time\n\u2b24 ok | forta.container.forta-scanner.service.publisher.event.batch-publish-attempt.time | 2023-06-11T09:19:15Z\n\u2b24 ok | forta.container.forta-scanner.service.publisher.event.batch-publish.error\n\u2b24 unknown | forta.container.forta-scanner.service.publisher.event.batch-publish.time\n\u2b24 info | forta.container.forta-scanner.service.publisher.event.batch-skip.reason | because this node runs no bots and slow report deadline has not exceeded yet\n\u2b24 info | forta.container.forta-scanner.service.publisher.event.batch-skip.time | 2023-06-11T09:19:15Z\n\u2b24 unknown | forta.container.forta-scanner.service.publisher.event.metrics-flush.time\n\u2b24 info | forta.container.forta-scanner.service.sender.agents.lagging | 0\n\u2b24 failing | forta.container.forta-scanner.service.sender.agents.total | 0\n\u2b24 ok | forta.container.forta-scanner.service.trace-json-rpc-client.request.block-by-number.error\n\u2b24 unknown | forta.container.forta-scanner.service.trace-json-rpc-client.request.block-by-number.time\n\u2b24 ok | forta.container.forta-scanner.service.trace-json-rpc-client.request.get-transaction-receipt.error\n\u2b24 unknown | forta.container.forta-scanner.service.trace-json-rpc-client.request.get-transaction-receipt.time\n\u2b24 ok | forta.container.forta-scanner.service.trace-json-rpc-client.request.trace-block.error\n\u2b24 ok | forta.container.forta-scanner.service.trace-json-rpc-client.request.trace-block.time | 2023-06-11T09:19:05Z\n\u2b24 ok | forta.container.forta-scanner.service.tx-analyzer.event.input.time | 2023-06-11T09:19:05Z\n\u2b24 unknown | forta.container.forta-scanner.service.tx-analyzer.event.output.time\n\u2b24 ok | forta.container.forta-scanner.service.tx-stream.event.block.time | 2023-06-11T09:19:05Z\n\u2b24 ok | forta.container.forta-scanner.service.tx-stream.event.transaction.time | 2023-06-11T09:19:05Z\n\u2b24 ok | forta.container.forta-scanner.summary | at block 17455940.\n\u2b24 ok | forta.container.forta-supervisor | running\n\u2b24 info | forta.container.forta-supervisor.service.bot-registry.event.change-detected.time | 2023-06-11T09:12:52Z\n\u2b24 ok | forta.container.forta-supervisor.service.bot-registry.event.checked.error\n\u2b24 info | forta.container.forta-supervisor.service.bot-registry.event.checked.time | 2023-06-11T09:08:41Z\n\u2b24 ok | forta.container.forta-supervisor.service.supervisor.containers.managed | 6\n\u2b24 ok | forta.container.forta-supervisor.service.supervisor.event.agent-logs-sync.error\n\u2b24 ok | forta.container.forta-supervisor.service.supervisor.event.agent-logs-sync.time | 2023-06-11T09:18:39Z\n\u2b24 ok | forta.container.forta-supervisor.service.supervisor.event.custom-telemetry-sync.error\n\u2b24 unknown | forta.container.forta-supervisor.service.supervisor.event.custom-telemetry-sync.time\n\u2b24 info | forta.container.forta-supervisor.service.supervisor.event.run-agent.time\n\u2b24 info | forta.container.forta-supervisor.service.supervisor.event.stop-agent.time\n\u2b24 ok | forta.container.forta-supervisor.service.supervisor.event.telemetry-sync.error\n\u2b24 unknown | forta.container.forta-supervisor.service.supervisor.event.telemetry-sync.time\n\u2b24 info | forta.container.forta-supervisor.service.supervisor.local-mode | false\n\u2b24 ok | forta.container.forta-supervisor.summary | all 6 service containers are running.\n\u2b24 info | forta.version\n</code></pre>"},{"location":"scan-node/upgrade/","title":"Keep Your Node Up-To-Date","text":""},{"location":"scan-node/upgrade/#deprecation","title":"Deprecation","text":"<p>All nodes need to start running the latest container versions within 48 hours after the latest release, by default. The releases made on GitHub may contain a release config that overrides the version support and reduces the deprecation time:</p> <pre><code># @begin release_config\ndeprecationPolicy:\n  supportedVersions:\n    - v0.7.9\n  activatesInHours: 72\n# @end release_config\n</code></pre> <p>The nodes which run unallowed versions may receive a low SLA score.</p>"},{"location":"scan-node/upgrade/#auto-updates","title":"Auto-updates","text":"<p>To help you in this process, the node software includes an auto-updater that detects new container images, pulls, stops old containers and starts new containers.</p> <p>In order to ensure that this feature works at all times, please set the registry API to a reliable one, as suggested in the Configure Registry API section.</p> <p>Each node updates at a specific time within the release interval. This interval is 24 hours unless overridden by the config in the release made on GitHub: <pre><code># @begin release_config\nautoUpdateInHours: 6\n# @end release_config\n</code></pre></p> <p>To receive the container update without stopping the bots and updating the CLI, please do <pre><code>docker kill forta-updater\n</code></pre> and the updater container will pick up the latest release when it is started again.</p> <p>Manual Update</p> <p>You need manual update through APT or YUM only if you need to receive the latest CLI features. As in the above example, CLI of an older version is able to successfully run the service container image of the newer version.</p> <p>To disable the auto-update behavior, you can add this to your config:</p> <pre><code>autoUpdate:\n  disable: true\n</code></pre> <p>Disabling Auto-Updates</p> <p>Disabling this feature is strongly discouraged. Not following the latest version can cause loss of rewards.</p>"},{"location":"scan-node/upgrade/#check-the-running-version","title":"Check the running version","text":"<p>Starting with v0.7.10, <code>forta version</code> outputs the CLI and container version separately. While using the CLI from versions provides a better experience, it is only necessary to have the latest container version.</p> <p>Example output:</p> <pre><code>$ forta version\n{\n  \"cli\": {\n    \"commit\": \"ef621ff8cf9e467e021630a6c0367214883e1130\",\n    \"ipfs\": \"QmbnNB1iyrNthzSptqxXkdz4RHfU3g5Y7QesLhbmv5xrF2\",\n    \"version\": \"v0.1.2\"\n  },\n  \"containers\": {\n    \"commit\": \"ef621ff8cf9e467e021630a6c0367214883e1130\",\n    \"ipfs\": \"QmbnNB1iyrNthzSptqxXkdz4RHfU3g5Y7QesLhbmv5xrF2\",\n    \"version\": \"v0.2.3\"\n  }\n}\n</code></pre> <p>Container version will be visible after running the node in the following steps.</p>"}]}